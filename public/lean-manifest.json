{
  "version": "1.0",
  "generated": "2026-01-10T22:18:36.258Z",
  "modules": {
    "Init.BinderNameHint": {
      "path": "Init/BinderNameHint.olean",
      "imports": [
        "Init.Tactics"
      ]
    },
    "Init.BinderPredicates": {
      "path": "Init/BinderPredicates.olean",
      "imports": [
        "Init.NotationExtra"
      ]
    },
    "Init.ByCases": {
      "path": "Init/ByCases.olean",
      "imports": [
        "Init.Classical"
      ]
    },
    "Init.Classical": {
      "path": "Init/Classical.olean",
      "imports": [
        "Init.PropLemmas"
      ]
    },
    "Init.Coe": {
      "path": "Init/Coe.olean",
      "imports": [
        "Init.Prelude",
        "Init.Prelude"
      ]
    },
    "Init.Control.Basic": {
      "path": "Init/Control/Basic.olean",
      "imports": [
        "Init.Core",
        "Init.BinderNameHint"
      ]
    },
    "Init.Control.EState": {
      "path": "Init/Control/EState.olean",
      "imports": [
        "Init.Data.ToString.Basic"
      ]
    },
    "Init.Control.Except": {
      "path": "Init/Control/Except.olean",
      "imports": [
        "Init.Control.Basic",
        "Init.Control.Id"
      ]
    },
    "Init.Control.ExceptCps": {
      "path": "Init/Control/ExceptCps.olean",
      "imports": [
        "Init.Control.Lawful.Basic"
      ]
    },
    "Init.Control.Id": {
      "path": "Init/Control/Id.olean",
      "imports": [
        "Init.Core",
        "Init.Control.MonadAttach"
      ]
    },
    "Init.Control.Lawful.Basic": {
      "path": "Init/Control/Lawful/Basic.olean",
      "imports": [
        "Init.Ext"
      ]
    },
    "Init.Control.Lawful.Instances": {
      "path": "Init/Control/Lawful/Instances.olean",
      "imports": [
        "Init.Control.Lawful.Basic",
        "all",
        "Init.Control.Option",
        "all",
        "all",
        "Init.Control.StateRef"
      ]
    },
    "Init.Control.Lawful.Lemmas": {
      "path": "Init/Control/Lawful/Lemmas.olean",
      "imports": [
        "Init.Control.Lawful.Basic",
        "Init.ByCases"
      ]
    },
    "Init.Control.Lawful.MonadAttach.Instances": {
      "path": "Init/Control/Lawful/MonadAttach/Instances.olean",
      "imports": [
        "Init.Control.Reader",
        "Init.Control.Lawful.Instances",
        "Init.Control.Lawful.MonadAttach.Lemmas"
      ]
    },
    "Init.Control.Lawful.MonadAttach.Lemmas": {
      "path": "Init/Control/Lawful/MonadAttach/Lemmas.olean",
      "imports": [
        "Init.Control.MonadAttach",
        "all",
        "Init.Control.Lawful.Lemmas",
        "Init.Control.Lawful.MonadLift.Lemmas"
      ]
    },
    "Init.Control.Lawful.MonadAttach": {
      "path": "Init/Control/Lawful/MonadAttach.olean",
      "imports": [
        "Init.Control.Lawful.MonadAttach.Lemmas",
        "Init.Control.Lawful.MonadAttach.Instances"
      ]
    },
    "Init.Control.Lawful.MonadLift.Basic": {
      "path": "Init/Control/Lawful/MonadLift/Basic.olean",
      "imports": [
        "Init.Control.Basic"
      ]
    },
    "Init.Control.Lawful.MonadLift.Instances": {
      "path": "Init/Control/Lawful/MonadLift/Instances.olean",
      "imports": [
        "all",
        "all",
        "Init.Control.ExceptCps",
        "all",
        "all",
        "Init.Control.StateCps",
        "all",
        "all",
        "Init.Control.Lawful.MonadLift.Lemmas",
        "Init.Control.Lawful.Instances"
      ]
    },
    "Init.Control.Lawful.MonadLift.Lemmas": {
      "path": "Init/Control/Lawful/MonadLift/Lemmas.olean",
      "imports": [
        "Init.Control.Id",
        "Init.Control.Lawful.Basic",
        "Init.Control.Lawful.MonadLift.Basic"
      ]
    },
    "Init.Control.Lawful.MonadLift": {
      "path": "Init/Control/Lawful/MonadLift.olean",
      "imports": [
        "Init.Control.Lawful.MonadLift.Basic",
        "Init.Control.Lawful.MonadLift.Lemmas",
        "Init.Control.Lawful.MonadLift.Instances"
      ]
    },
    "Init.Control.Lawful": {
      "path": "Init/Control/Lawful.olean",
      "imports": [
        "Init.Control.Lawful.Basic",
        "Init.Control.Lawful.Instances",
        "Init.Control.Lawful.Lemmas",
        "Init.Control.Lawful.MonadLift",
        "Init.Control.Lawful.MonadAttach"
      ]
    },
    "Init.Control.MonadAttach": {
      "path": "Init/Control/MonadAttach.olean",
      "imports": [
        "Init.Control.Basic"
      ]
    },
    "Init.Control.Option": {
      "path": "Init/Control/Option.olean",
      "imports": [
        "Init.Data.Option.Basic",
        "Init.Control.Except"
      ]
    },
    "Init.Control.Reader": {
      "path": "Init/Control/Reader.olean",
      "imports": [
        "Init.Control.Except"
      ]
    },
    "Init.Control.State": {
      "path": "Init/Control/State.olean",
      "imports": [
        "Init.Control.Except"
      ]
    },
    "Init.Control.StateCps": {
      "path": "Init/Control/StateCps.olean",
      "imports": [
        "Init.Control.Lawful.Basic"
      ]
    },
    "Init.Control.StateRef": {
      "path": "Init/Control/StateRef.olean",
      "imports": [
        "Init.System.ST"
      ]
    },
    "Init.Control": {
      "path": "Init/Control.olean",
      "imports": [
        "Init.Control.Basic",
        "Init.Control.State",
        "Init.Control.StateRef",
        "Init.Control.Id",
        "Init.Control.Except",
        "Init.Control.Reader",
        "Init.Control.Option",
        "Init.Control.Lawful",
        "Init.Control.StateCps",
        "Init.Control.ExceptCps",
        "Init.Control.MonadAttach"
      ]
    },
    "Init.Conv": {
      "path": "Init/Conv.olean",
      "imports": [
        "Init.Tactics",
        "Init.Meta"
      ]
    },
    "Init.Core": {
      "path": "Init/Core.olean",
      "imports": [
        "Init.SizeOf"
      ]
    },
    "Init.Data.AC": {
      "path": "Init/Data/AC.olean",
      "imports": [
        "Init.ByCases"
      ]
    },
    "Init.Data.Array.Attach": {
      "path": "Init/Data/Array/Attach.olean",
      "imports": [
        "Init.Data.Array.Count",
        "all"
      ]
    },
    "Init.Data.Array.Basic": {
      "path": "Init/Data/Array/Basic.olean",
      "imports": [
        "Init.GetElem",
        "Init.Data.List.ToArrayImpl",
        "all",
        "Init.Data.Array.Set",
        "all"
      ]
    },
    "Init.Data.Array.BasicAux": {
      "path": "Init/Data/Array/BasicAux.olean",
      "imports": [
        "all",
        "Init.Data.Nat.Linear"
      ]
    },
    "Init.Data.Array.BinSearch": {
      "path": "Init/Data/Array/BinSearch.olean",
      "imports": [
        "Init.Data.Int.DivMod.Lemmas"
      ]
    },
    "Init.Data.Array.Bootstrap": {
      "path": "Init/Data/Array/Bootstrap.olean",
      "imports": [
        "Init.Data.List.TakeDrop",
        "all"
      ]
    },
    "Init.Data.Array.Count": {
      "path": "Init/Data/Array/Count.olean",
      "imports": [
        "all",
        "Init.Data.Array.Lemmas",
        "Init.Data.List.Nat.Count"
      ]
    },
    "Init.Data.Array.DecidableEq": {
      "path": "Init/Data/Array/DecidableEq.olean",
      "imports": [
        "all",
        "Init.Data.BEq",
        "Init.Data.List.Nat.BEq"
      ]
    },
    "Init.Data.Array.Erase": {
      "path": "Init/Data/Array/Erase.olean",
      "imports": [
        "all",
        "Init.Data.Array.Lemmas"
      ]
    },
    "Init.Data.Array.Extract": {
      "path": "Init/Data/Array/Extract.olean",
      "imports": [
        "Init.Data.Array.Lemmas"
      ]
    },
    "Init.Data.Array.FinRange": {
      "path": "Init/Data/Array/FinRange.olean",
      "imports": [
        "Init.Data.Array.OfFn"
      ]
    },
    "Init.Data.Array.Find": {
      "path": "Init/Data/Array/Find.olean",
      "imports": [
        "Init.Data.List.Nat.Find",
        "all",
        "Init.Data.Array.Range"
      ]
    },
    "Init.Data.Array.GetLit": {
      "path": "Init/Data/Array/GetLit.olean",
      "imports": [
        "Init.Data.Array.Basic"
      ]
    },
    "Init.Data.Array.InsertIdx": {
      "path": "Init/Data/Array/InsertIdx.olean",
      "imports": [
        "Init.Data.Array.Lemmas"
      ]
    },
    "Init.Data.Array.InsertionSort": {
      "path": "Init/Data/Array/InsertionSort.olean",
      "imports": [
        "Init.Data.Array.Basic"
      ]
    },
    "Init.Data.Array.Lemmas": {
      "path": "Init/Data/Array/Lemmas.olean",
      "imports": [
        "Init.Data.List.Nat.Basic",
        "Init.Data.Array.Mem",
        "Init.Data.Array.DecidableEq",
        "Init.Data.Range.Lemmas",
        "Init.Data.List.ToArray",
        "all",
        "all",
        "all"
      ]
    },
    "Init.Data.Array.Lex.Basic": {
      "path": "Init/Data/Array/Lex/Basic.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.Iterators",
        "Init.Data.Range.Polymorphic.Nat",
        "Init.Data.Iterators.Consumers"
      ]
    },
    "Init.Data.Array.Lex.Lemmas": {
      "path": "Init/Data/Array/Lex/Lemmas.olean",
      "imports": [
        "all",
        "Init.Data.Array.Lex.Basic",
        "Init.Data.Array.Lemmas",
        "Init.Data.List.Lex",
        "Init.Data.Range.Polymorphic.NatLemmas"
      ]
    },
    "Init.Data.Array.Lex": {
      "path": "Init/Data/Array/Lex.olean",
      "imports": [
        "Init.Data.Array.Lex.Basic",
        "Init.Data.Array.Lex.Lemmas"
      ]
    },
    "Init.Data.Array.MapIdx": {
      "path": "Init/Data/Array/MapIdx.olean",
      "imports": [
        "all",
        "Init.Data.Array.OfFn",
        "Init.Data.List.MapIdx",
        "all"
      ]
    },
    "Init.Data.Array.Mem": {
      "path": "Init/Data/Array/Mem.olean",
      "imports": [
        "Init.Data.List.BasicAux"
      ]
    },
    "Init.Data.Array.Monadic": {
      "path": "Init/Data/Array/Monadic.olean",
      "imports": [
        "all",
        "all",
        "Init.Data.Array.Attach"
      ]
    },
    "Init.Data.Array.OfFn": {
      "path": "Init/Data/Array/OfFn.olean",
      "imports": [
        "all",
        "Init.Data.Array.Monadic",
        "Init.Data.List.FinRange"
      ]
    },
    "Init.Data.Array.Perm": {
      "path": "Init/Data/Array/Perm.olean",
      "imports": [
        "Init.Data.List.Nat.Perm",
        "all",
        "Init.Data.Array.Lemmas"
      ]
    },
    "Init.Data.Array.QSort.Basic": {
      "path": "Init/Data/Array/QSort/Basic.olean",
      "imports": [
        "Init.Data.Vector.Basic",
        "Init.Data.Ord.Basic"
      ]
    },
    "Init.Data.Array.QSort": {
      "path": "Init/Data/Array/QSort.olean",
      "imports": [
        "Init.Data.Array.QSort.Basic"
      ]
    },
    "Init.Data.Array.Range": {
      "path": "Init/Data/Array/Range.olean",
      "imports": [
        "all",
        "all",
        "Init.Data.Array.MapIdx",
        "Init.Data.Array.Zip"
      ]
    },
    "Init.Data.Array.Set": {
      "path": "Init/Data/Array/Set.olean",
      "imports": [
        "Init.Tactics"
      ]
    },
    "Init.Data.Array.Subarray.Split": {
      "path": "Init/Data/Array/Subarray/Split.olean",
      "imports": [
        "Init.Data.Array.Subarray",
        "all",
        "Init.Omega"
      ]
    },
    "Init.Data.Array.Subarray": {
      "path": "Init/Data/Array/Subarray.olean",
      "imports": [
        "Init.Data.Array.Basic",
        "Init.Data.Array.GetLit",
        "Init.Data.Slice.Basic"
      ]
    },
    "Init.Data.Array.TakeDrop": {
      "path": "Init/Data/Array/TakeDrop.olean",
      "imports": [
        "all",
        "Init.Data.Array.Lemmas"
      ]
    },
    "Init.Data.Array.Zip": {
      "path": "Init/Data/Array/Zip.olean",
      "imports": [
        "all",
        "Init.Data.Array.TakeDrop"
      ]
    },
    "Init.Data.Array": {
      "path": "Init/Data/Array.olean",
      "imports": [
        "Init.Data.Array.Basic",
        "Init.Data.Array.QSort",
        "Init.Data.Array.BinSearch",
        "Init.Data.Array.InsertionSort",
        "Init.Data.Array.DecidableEq",
        "Init.Data.Array.Mem",
        "Init.Data.Array.Attach",
        "Init.Data.Array.BasicAux",
        "Init.Data.Array.Lemmas",
        "Init.Data.Array.TakeDrop",
        "Init.Data.Array.Bootstrap",
        "Init.Data.Array.GetLit",
        "Init.Data.Array.MapIdx",
        "Init.Data.Array.Set",
        "Init.Data.Array.Monadic",
        "Init.Data.Array.FinRange",
        "Init.Data.Array.Perm",
        "Init.Data.Array.Find",
        "Init.Data.Array.Lex",
        "Init.Data.Array.Range",
        "Init.Data.Array.Erase",
        "Init.Data.Array.Zip",
        "Init.Data.Array.InsertIdx",
        "Init.Data.Array.Extract"
      ]
    },
    "Init.Data.BEq": {
      "path": "Init/Data/BEq.olean",
      "imports": [
        "Init.Data.Bool"
      ]
    },
    "Init.Data.BitVec.Basic": {
      "path": "Init/Data/BitVec/Basic.olean",
      "imports": [
        "Init.Data.Nat.Bitwise.Lemmas",
        "Init.Data.Int.Bitwise.Basic"
      ]
    },
    "Init.Data.BitVec.BasicAux": {
      "path": "Init/Data/BitVec/BasicAux.olean",
      "imports": [
        "Init.Data.Fin.Basic"
      ]
    },
    "Init.Data.BitVec.Bitblast": {
      "path": "Init/Data/BitVec/Bitblast.olean",
      "imports": [
        "all",
        "Init.Data.Int.DivMod",
        "all",
        "all",
        "Init.Data.BitVec.Decidable",
        "Init.Data.BitVec.Folds",
        "Init.BinderPredicates"
      ]
    },
    "Init.Data.BitVec.Bootstrap": {
      "path": "Init/Data/BitVec/Bootstrap.olean",
      "imports": [
        "Init.Data.BitVec.Basic",
        "all",
        "Init.Data.Int.Bitwise.Lemmas",
        "Init.Ext"
      ]
    },
    "Init.Data.BitVec.Decidable": {
      "path": "Init/Data/BitVec/Decidable.olean",
      "imports": [
        "Init.Data.BitVec.Bootstrap",
        "Init.Ext"
      ]
    },
    "Init.Data.BitVec.Folds": {
      "path": "Init/Data/BitVec/Folds.olean",
      "imports": [
        "all",
        "Init.Data.BitVec.Lemmas",
        "Init.Data.Fin.Iterate"
      ]
    },
    "Init.Data.BitVec.Lemmas": {
      "path": "Init/Data/BitVec/Lemmas.olean",
      "imports": [
        "all",
        "all",
        "Init.Data.Fin.Lemmas",
        "Init.Data.Int.Bitwise.Lemmas",
        "Init.Data.Int.LemmasAux",
        "Init.Data.BitVec.Bootstrap",
        "Init.Data.List.BasicAux",
        "Init.Data.List.Lemmas"
      ]
    },
    "Init.Data.BitVec": {
      "path": "Init/Data/BitVec.olean",
      "imports": [
        "Init.Data.BitVec.BasicAux",
        "Init.Data.BitVec.Basic",
        "Init.Data.BitVec.Bootstrap",
        "Init.Data.BitVec.Bitblast",
        "Init.Data.BitVec.Decidable",
        "Init.Data.BitVec.Lemmas",
        "Init.Data.BitVec.Folds"
      ]
    },
    "Init.Data.Bool": {
      "path": "Init/Data/Bool.olean",
      "imports": [
        "Init.NotationExtra"
      ]
    },
    "Init.Data.ByteArray.Basic": {
      "path": "Init/Data/ByteArray/Basic.olean",
      "imports": [
        "Init.Data.UInt.Basic",
        "all",
        "Init.Data.Array.Extract"
      ]
    },
    "Init.Data.ByteArray.Bootstrap": {
      "path": "Init/Data/ByteArray/Bootstrap.olean",
      "imports": [
        "Init.Data.List.Basic"
      ]
    },
    "Init.Data.ByteArray.Extra": {
      "path": "Init/Data/ByteArray/Extra.olean",
      "imports": [
        "Init.Data.ByteArray.Basic",
        "Init.Data.String.Basic"
      ]
    },
    "Init.Data.ByteArray.Lemmas": {
      "path": "Init/Data/ByteArray/Lemmas.olean",
      "imports": [
        "Init.Data.ByteArray.Basic"
      ]
    },
    "Init.Data.ByteArray": {
      "path": "Init/Data/ByteArray.olean",
      "imports": [
        "Init.Data.ByteArray.Basic",
        "Init.Data.ByteArray.Bootstrap",
        "Init.Data.ByteArray.Extra",
        "Init.Data.ByteArray.Lemmas"
      ]
    },
    "Init.Data.Cast": {
      "path": "Init/Data/Cast.olean",
      "imports": [
        "Init.Coe"
      ]
    },
    "Init.Data.Char.Basic": {
      "path": "Init/Data/Char/Basic.olean",
      "imports": [
        "Init.Data.UInt.BasicAux"
      ]
    },
    "Init.Data.Char.Lemmas": {
      "path": "Init/Data/Char/Lemmas.olean",
      "imports": [
        "all",
        "Init.Data.UInt.Lemmas"
      ]
    },
    "Init.Data.Char.Order": {
      "path": "Init/Data/Char/Order.olean",
      "imports": [
        "Init.Data.Char.Basic",
        "Init.Data.Char.Lemmas",
        "Init.Data.Order.Factories"
      ]
    },
    "Init.Data.Char": {
      "path": "Init/Data/Char.olean",
      "imports": [
        "Init.Data.Char.Basic",
        "Init.Data.Char.Lemmas",
        "Init.Data.Char.Order"
      ]
    },
    "Init.Data.Dyadic.Basic": {
      "path": "Init/Data/Dyadic/Basic.olean",
      "imports": [
        "Init.Data.Rat.Lemmas",
        "Init.Data.Int.Bitwise.Lemmas",
        "Init.Hints"
      ]
    },
    "Init.Data.Dyadic.Instances": {
      "path": "Init/Data/Dyadic/Instances.olean",
      "imports": [
        "Init.Data.Dyadic.Basic",
        "Init.Grind.Ordered.Ring"
      ]
    },
    "Init.Data.Dyadic.Inv": {
      "path": "Init/Data/Dyadic/Inv.olean",
      "imports": [
        "Init.Data.Dyadic.Round",
        "Init.Grind.Ordered.Ring"
      ]
    },
    "Init.Data.Dyadic.Round": {
      "path": "Init/Data/Dyadic/Round.olean",
      "imports": [
        "Init.Data.Dyadic.Basic",
        "all",
        "Init.Grind.Ordered.Rat",
        "Init.Grind.Ordered.Field"
      ]
    },
    "Init.Data.Dyadic": {
      "path": "Init/Data/Dyadic.olean",
      "imports": [
        "Init.Data.Dyadic.Basic",
        "Init.Data.Dyadic.Instances",
        "Init.Data.Dyadic.Round",
        "Init.Data.Dyadic.Inv"
      ]
    },
    "Init.Data.Fin.Basic": {
      "path": "Init/Data/Fin/Basic.olean",
      "imports": [
        "Init.Data.Nat.Bitwise.Basic"
      ]
    },
    "Init.Data.Fin.Bitwise": {
      "path": "Init/Data/Fin/Bitwise.olean",
      "imports": [
        "Init.Data.Nat.Bitwise"
      ]
    },
    "Init.Data.Fin.Fold": {
      "path": "Init/Data/Fin/Fold.olean",
      "imports": [
        "Init.Control.Lawful.Basic",
        "Init.Data.Fin.Lemmas"
      ]
    },
    "Init.Data.Fin.Iterate": {
      "path": "Init/Data/Fin/Iterate.olean",
      "imports": [
        "Init.PropLemmas"
      ]
    },
    "Init.Data.Fin.Lemmas": {
      "path": "Init/Data/Fin/Lemmas.olean",
      "imports": [
        "Init.Data.Nat.Lemmas",
        "Init.Ext",
        "Init.Data.Order.Lemmas"
      ]
    },
    "Init.Data.Fin.Log2": {
      "path": "Init/Data/Fin/Log2.olean",
      "imports": [
        "Init.Data.Nat.Log2"
      ]
    },
    "Init.Data.Fin": {
      "path": "Init/Data/Fin.olean",
      "imports": [
        "Init.Data.Fin.Basic",
        "Init.Data.Fin.Log2",
        "Init.Data.Fin.Iterate",
        "Init.Data.Fin.Fold",
        "Init.Data.Fin.Lemmas"
      ]
    },
    "Init.Data.Float": {
      "path": "Init/Data/Float.olean",
      "imports": [
        "Init.Data.ToString.Basic"
      ]
    },
    "Init.Data.Float32": {
      "path": "Init/Data/Float32.olean",
      "imports": [
        "Init.Data.Float"
      ]
    },
    "Init.Data.FloatArray.Basic": {
      "path": "Init/Data/FloatArray/Basic.olean",
      "imports": [
        "Init.Data.Float",
        "Init.Ext",
        "Init.Data.Array.DecidableEq"
      ]
    },
    "Init.Data.FloatArray": {
      "path": "Init/Data/FloatArray.olean",
      "imports": [
        "Init.Data.FloatArray.Basic"
      ]
    },
    "Init.Data.Format.Basic": {
      "path": "Init/Data/Format/Basic.olean",
      "imports": [
        "Init.Control.State",
        "Init.Data.Int.Basic",
        "Init.Data.String.Bootstrap"
      ]
    },
    "Init.Data.Format.Instances": {
      "path": "Init/Data/Format/Instances.olean",
      "imports": [
        "Init.Data.Array.Basic",
        "Init.Data.String.Search"
      ]
    },
    "Init.Data.Format.Macro": {
      "path": "Init/Data/Format/Macro.olean",
      "imports": [
        "Init.Data.Format.Basic",
        "Init.Data.ToString.Macro"
      ]
    },
    "Init.Data.Format.Syntax": {
      "path": "Init/Data/Format/Syntax.olean",
      "imports": [
        "Init.Data.Format.Macro",
        "Init.Data.Format.Instances",
        "Init.Meta",
        "Init.Data.ToString.Name"
      ]
    },
    "Init.Data.Format": {
      "path": "Init/Data/Format.olean",
      "imports": [
        "Init.Data.Format.Basic",
        "Init.Data.Format.Macro",
        "Init.Data.Format.Instances",
        "Init.Data.Format.Syntax"
      ]
    },
    "Init.Data.Function": {
      "path": "Init/Data/Function.olean",
      "imports": [
        "Init.Grind.Tactics"
      ]
    },
    "Init.Data.Hashable": {
      "path": "Init/Data/Hashable.olean",
      "imports": [
        "Init.Data.String.Basic"
      ]
    },
    "Init.Data.Int.Basic": {
      "path": "Init/Data/Int/Basic.olean",
      "imports": [
        "Init.Data.Cast",
        "Init.Data.Nat.Div.Basic"
      ]
    },
    "Init.Data.Int.Bitwise.Basic": {
      "path": "Init/Data/Int/Bitwise/Basic.olean",
      "imports": [
        "Init.Data.Int.Basic",
        "Init.Data.Nat.Bitwise.Basic"
      ]
    },
    "Init.Data.Int.Bitwise.Lemmas": {
      "path": "Init/Data/Int/Bitwise/Lemmas.olean",
      "imports": [
        "Init.Data.Nat.Bitwise.Lemmas",
        "Init.Data.Int.Bitwise.Basic",
        "all",
        "Init.Data.Int.DivMod.Lemmas"
      ]
    },
    "Init.Data.Int.Bitwise": {
      "path": "Init/Data/Int/Bitwise.olean",
      "imports": [
        "Init.Data.Int.Bitwise.Basic",
        "Init.Data.Int.Bitwise.Lemmas"
      ]
    },
    "Init.Data.Int.Compare": {
      "path": "Init/Data/Int/Compare.olean",
      "imports": [
        "Init.Data.Ord.Basic",
        "all",
        "Init.Data.Int.Order",
        "Init.Omega"
      ]
    },
    "Init.Data.Int.Cooper": {
      "path": "Init/Data/Int/Cooper.olean",
      "imports": [
        "Init.Data.Int.Gcd"
      ]
    },
    "Init.Data.Int.DivMod.Basic": {
      "path": "Init/Data/Int/DivMod/Basic.olean",
      "imports": [
        "Init.Data.Int.Basic"
      ]
    },
    "Init.Data.Int.DivMod.Bootstrap": {
      "path": "Init/Data/Int/DivMod/Bootstrap.olean",
      "imports": [
        "Init.Data.Int.DivMod.Basic",
        "Init.Data.Int.Order",
        "Init.Data.Nat.Dvd",
        "Init.RCases"
      ]
    },
    "Init.Data.Int.DivMod.Lemmas": {
      "path": "Init/Data/Int/DivMod/Lemmas.olean",
      "imports": [
        "Init.Data.Nat.Div.Lemmas",
        "Init.TacticsExtra"
      ]
    },
    "Init.Data.Int.DivMod.Pow": {
      "path": "Init/Data/Int/DivMod/Pow.olean",
      "imports": [
        "Init.Data.Int.DivMod.Lemmas",
        "Init.Data.Int.Pow"
      ]
    },
    "Init.Data.Int.DivMod": {
      "path": "Init/Data/Int/DivMod.olean",
      "imports": [
        "Init.Data.Int.DivMod.Basic",
        "Init.Data.Int.DivMod.Bootstrap",
        "Init.Data.Int.DivMod.Lemmas",
        "Init.Data.Int.DivMod.Pow"
      ]
    },
    "Init.Data.Int.Gcd": {
      "path": "Init/Data/Int/Gcd.olean",
      "imports": [
        "Init.Data.Nat.Lcm",
        "Init.Data.Int.DivMod.Lemmas",
        "Init.Data.Int.Pow"
      ]
    },
    "Init.Data.Int.Lemmas": {
      "path": "Init/Data/Int/Lemmas.olean",
      "imports": [
        "Init.PropLemmas"
      ]
    },
    "Init.Data.Int.LemmasAux": {
      "path": "Init/Data/Int/LemmasAux.olean",
      "imports": [
        "Init.Data.Int.Pow"
      ]
    },
    "Init.Data.Int.Linear": {
      "path": "Init/Data/Int/Linear.olean",
      "imports": [
        "Init.Data.Int.LemmasAux",
        "Init.Data.Int.Cooper",
        "all",
        "Init.Data.AC",
        "all",
        "Init.LawfulBEqTactics"
      ]
    },
    "Init.Data.Int.OfNat": {
      "path": "Init/Data/Int/OfNat.olean",
      "imports": [
        "Init.Data.Int.Linear",
        "Init.GrindInstances.ToInt"
      ]
    },
    "Init.Data.Int.Order": {
      "path": "Init/Data/Int/Order.olean",
      "imports": [
        "Init.Data.Int.Lemmas",
        "Init.ByCases",
        "Init.Data.Order.Factories",
        "Init.Data.Order.Lemmas"
      ]
    },
    "Init.Data.Int.Pow": {
      "path": "Init/Data/Int/Pow.olean",
      "imports": [
        "Init.Data.Nat.Lemmas"
      ]
    },
    "Init.Data.Int": {
      "path": "Init/Data/Int.olean",
      "imports": [
        "Init.Data.Int.Basic",
        "Init.Data.Int.Bitwise",
        "Init.Data.Int.Compare",
        "Init.Data.Int.DivMod",
        "Init.Data.Int.Gcd",
        "Init.Data.Int.Lemmas",
        "Init.Data.Int.LemmasAux",
        "Init.Data.Int.Order",
        "Init.Data.Int.Pow",
        "Init.Data.Int.Cooper",
        "Init.Data.Int.Linear",
        "Init.Data.Int.OfNat"
      ]
    },
    "Init.Data.Iterators.Basic": {
      "path": "Init/Data/Iterators/Basic.olean",
      "imports": [
        "Init.Classical",
        "Init.Ext"
      ]
    },
    "Init.Data.Iterators.Combinators.Attach": {
      "path": "Init/Data/Iterators/Combinators/Attach.olean",
      "imports": [
        "Init.Data.Iterators.Combinators.Monadic.Attach",
        "Init.Data.Iterators.Combinators.FilterMap"
      ]
    },
    "Init.Data.Iterators.Combinators.FilterMap": {
      "path": "Init/Data/Iterators/Combinators/FilterMap.olean",
      "imports": [
        "Init.Data.Iterators.Combinators.Monadic.FilterMap"
      ]
    },
    "Init.Data.Iterators.Combinators.FlatMap": {
      "path": "Init/Data/Iterators/Combinators/FlatMap.olean",
      "imports": [
        "Init.Data.Iterators.Combinators.FilterMap",
        "Init.Data.Iterators.Combinators.Monadic.FlatMap"
      ]
    },
    "Init.Data.Iterators.Combinators.Monadic.Attach": {
      "path": "Init/Data/Iterators/Combinators/Monadic/Attach.olean",
      "imports": [
        "Init.Data.Iterators.Internal.Termination",
        "Init.Data.Iterators.Consumers.Loop"
      ]
    },
    "Init.Data.Iterators.Combinators.Monadic.FilterMap": {
      "path": "Init/Data/Iterators/Combinators/Monadic/FilterMap.olean",
      "imports": [
        "Init.Data.Iterators.Consumers.Loop",
        "Init.Data.Iterators.PostconditionMonad",
        "Init.Data.Iterators.Internal.Termination"
      ]
    },
    "Init.Data.Iterators.Combinators.Monadic.FlatMap": {
      "path": "Init/Data/Iterators/Combinators/Monadic/FlatMap.olean",
      "imports": [
        "Init.Data.Iterators.Combinators.Monadic.FilterMap",
        "Init.Data.Option.Lemmas"
      ]
    },
    "Init.Data.Iterators.Combinators.Monadic.Take": {
      "path": "Init/Data/Iterators/Combinators/Monadic/Take.olean",
      "imports": [
        "Init.Data.Nat.Lemmas",
        "Init.Data.Iterators.Consumers.Monadic.Collect",
        "Init.Data.Iterators.Consumers.Monadic.Loop",
        "Init.Data.Iterators.Internal.Termination"
      ]
    },
    "Init.Data.Iterators.Combinators.Monadic.ULift": {
      "path": "Init/Data/Iterators/Combinators/Monadic/ULift.olean",
      "imports": [
        "Init.Data.Iterators.Internal.Termination",
        "Init.Data.Iterators.Consumers.Monadic"
      ]
    },
    "Init.Data.Iterators.Combinators.Monadic": {
      "path": "Init/Data/Iterators/Combinators/Monadic.olean",
      "imports": [
        "Init.Data.Iterators.Combinators.Monadic.FilterMap",
        "Init.Data.Iterators.Combinators.Monadic.FlatMap",
        "Init.Data.Iterators.Combinators.Monadic.Take",
        "Init.Data.Iterators.Combinators.Monadic.ULift"
      ]
    },
    "Init.Data.Iterators.Combinators.Take": {
      "path": "Init/Data/Iterators/Combinators/Take.olean",
      "imports": [
        "Init.Data.Iterators.Combinators.Monadic.Take"
      ]
    },
    "Init.Data.Iterators.Combinators.ULift": {
      "path": "Init/Data/Iterators/Combinators/ULift.olean",
      "imports": [
        "Init.Data.Iterators.Combinators.Monadic.ULift"
      ]
    },
    "Init.Data.Iterators.Combinators": {
      "path": "Init/Data/Iterators/Combinators.olean",
      "imports": [
        "Init.Data.Iterators.Combinators.Monadic",
        "Init.Data.Iterators.Combinators.FilterMap",
        "Init.Data.Iterators.Combinators.FlatMap",
        "Init.Data.Iterators.Combinators.Take",
        "Init.Data.Iterators.Combinators.ULift"
      ]
    },
    "Init.Data.Iterators.Consumers.Access": {
      "path": "Init/Data/Iterators/Consumers/Access.olean",
      "imports": [
        "Init.Data.Iterators.Consumers.Loop",
        "Init.Data.Iterators.Consumers.Monadic.Access"
      ]
    },
    "Init.Data.Iterators.Consumers.Collect": {
      "path": "Init/Data/Iterators/Consumers/Collect.olean",
      "imports": [
        "Init.Data.Iterators.Consumers.Partial",
        "Init.Data.Iterators.Consumers.Total",
        "Init.Data.Iterators.Consumers.Monadic.Collect"
      ]
    },
    "Init.Data.Iterators.Consumers.Loop": {
      "path": "Init/Data/Iterators/Consumers/Loop.olean",
      "imports": [
        "Init.Data.Iterators.Consumers.Collect",
        "Init.Data.Iterators.Consumers.Monadic.Loop"
      ]
    },
    "Init.Data.Iterators.Consumers.Monadic.Access": {
      "path": "Init/Data/Iterators/Consumers/Monadic/Access.olean",
      "imports": [
        "Init.Data.Iterators.Basic"
      ]
    },
    "Init.Data.Iterators.Consumers.Monadic.Collect": {
      "path": "Init/Data/Iterators/Consumers/Monadic/Collect.olean",
      "imports": [
        "Init.Data.Iterators.Consumers.Monadic.Partial",
        "Init.Data.Iterators.Consumers.Monadic.Total",
        "Init.Data.Iterators.Internal.LawfulMonadLiftFunction",
        "Init.WFExtrinsicFix"
      ]
    },
    "Init.Data.Iterators.Consumers.Monadic.Loop": {
      "path": "Init/Data/Iterators/Consumers/Monadic/Loop.olean",
      "imports": [
        "Init.Data.Iterators.Consumers.Monadic.Partial",
        "Init.Data.Iterators.Internal.LawfulMonadLiftFunction",
        "Init.WFExtrinsicFix",
        "Init.Data.Iterators.Consumers.Monadic.Total"
      ]
    },
    "Init.Data.Iterators.Consumers.Monadic.Partial": {
      "path": "Init/Data/Iterators/Consumers/Monadic/Partial.olean",
      "imports": [
        "Init.Data.Iterators.Basic"
      ]
    },
    "Init.Data.Iterators.Consumers.Monadic.Total": {
      "path": "Init/Data/Iterators/Consumers/Monadic/Total.olean",
      "imports": [
        "Init.Data.Iterators.Basic"
      ]
    },
    "Init.Data.Iterators.Consumers.Monadic": {
      "path": "Init/Data/Iterators/Consumers/Monadic.olean",
      "imports": [
        "Init.Data.Iterators.Consumers.Monadic.Access",
        "Init.Data.Iterators.Consumers.Monadic.Collect",
        "Init.Data.Iterators.Consumers.Monadic.Loop",
        "Init.Data.Iterators.Consumers.Monadic.Partial"
      ]
    },
    "Init.Data.Iterators.Consumers.Partial": {
      "path": "Init/Data/Iterators/Consumers/Partial.olean",
      "imports": [
        "Init.Data.Iterators.Basic"
      ]
    },
    "Init.Data.Iterators.Consumers.Stream": {
      "path": "Init/Data/Iterators/Consumers/Stream.olean",
      "imports": [
        "Init.Data.Stream",
        "Init.Data.Iterators.Consumers.Access"
      ]
    },
    "Init.Data.Iterators.Consumers.Total": {
      "path": "Init/Data/Iterators/Consumers/Total.olean",
      "imports": [
        "Init.Data.Iterators.Basic"
      ]
    },
    "Init.Data.Iterators.Consumers": {
      "path": "Init/Data/Iterators/Consumers.olean",
      "imports": [
        "Init.Data.Iterators.Consumers.Monadic",
        "Init.Data.Iterators.Consumers.Access",
        "Init.Data.Iterators.Consumers.Collect",
        "Init.Data.Iterators.Consumers.Loop",
        "Init.Data.Iterators.Consumers.Partial",
        "Init.Data.Iterators.Consumers.Total",
        "Init.Data.Iterators.Consumers.Stream"
      ]
    },
    "Init.Data.Iterators.Internal.LawfulMonadLiftFunction": {
      "path": "Init/Data/Iterators/Internal/LawfulMonadLiftFunction.olean",
      "imports": [
        "Init.Control.Lawful.MonadLift"
      ]
    },
    "Init.Data.Iterators.Internal.Termination": {
      "path": "Init/Data/Iterators/Internal/Termination.olean",
      "imports": [
        "Init.Data.Iterators.Basic"
      ]
    },
    "Init.Data.Iterators.Internal": {
      "path": "Init/Data/Iterators/Internal.olean",
      "imports": [
        "Init.Data.Iterators.Internal.LawfulMonadLiftFunction",
        "Init.Data.Iterators.Internal.Termination"
      ]
    },
    "Init.Data.Iterators.Lemmas.Basic": {
      "path": "Init/Data/Iterators/Lemmas/Basic.olean",
      "imports": [
        "Init.Data.Iterators.Basic"
      ]
    },
    "Init.Data.Iterators.Lemmas.Combinators.Attach": {
      "path": "Init/Data/Iterators/Lemmas/Combinators/Attach.olean",
      "imports": [
        "Init.Data.Iterators.Combinators.Attach",
        "all",
        "all",
        "Init.Data.Iterators.Lemmas.Combinators.Monadic.Attach",
        "Init.Data.Iterators.Lemmas.Consumers.Collect",
        "Init.Data.Iterators.Lemmas.Consumers.Loop",
        "Init.Data.Array.Attach"
      ]
    },
    "Init.Data.Iterators.Lemmas.Combinators.FilterMap": {
      "path": "Init/Data/Iterators/Lemmas/Combinators/FilterMap.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Consumers",
        "Init.Data.Iterators.Lemmas.Combinators.Monadic.FilterMap",
        "Init.Data.Iterators.Combinators.FilterMap",
        "Init.Control.Lawful.MonadAttach.Lemmas"
      ]
    },
    "Init.Data.Iterators.Lemmas.Combinators.FlatMap": {
      "path": "Init/Data/Iterators/Lemmas/Combinators/FlatMap.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Combinators.FilterMap",
        "Init.Data.Iterators.Combinators.FlatMap",
        "all",
        "Init.Data.Iterators.Lemmas.Combinators.Monadic.FlatMap",
        "Init.Control.Lawful.MonadAttach.Lemmas"
      ]
    },
    "Init.Data.Iterators.Lemmas.Combinators.Monadic.Attach": {
      "path": "Init/Data/Iterators/Lemmas/Combinators/Monadic/Attach.olean",
      "imports": [
        "Init.Data.Iterators.Combinators.Monadic.Attach",
        "all",
        "Init.Data.Iterators.Lemmas.Consumers.Monadic.Collect",
        "Init.Data.Iterators.Lemmas.Consumers.Monadic.Loop"
      ]
    },
    "Init.Data.Iterators.Lemmas.Combinators.Monadic.FilterMap": {
      "path": "Init/Data/Iterators/Lemmas/Combinators/Monadic/FilterMap.olean",
      "imports": [
        "Init.Data.Iterators.Combinators.Monadic.FilterMap",
        "Init.Data.Iterators.Lemmas.Consumers.Monadic",
        "all",
        "Init.Control.Lawful.MonadAttach.Lemmas",
        "Init.Data.Array.Monadic"
      ]
    },
    "Init.Data.Iterators.Lemmas.Combinators.Monadic.FlatMap": {
      "path": "Init/Data/Iterators/Lemmas/Combinators/Monadic/FlatMap.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Combinators.Monadic.FilterMap",
        "Init.Data.Iterators.Combinators.Monadic.FlatMap",
        "all"
      ]
    },
    "Init.Data.Iterators.Lemmas.Combinators.Monadic.Take": {
      "path": "Init/Data/Iterators/Lemmas/Combinators/Monadic/Take.olean",
      "imports": [
        "Init.Data.Iterators.Combinators.Monadic.Take",
        "Init.Data.Iterators.Lemmas.Consumers.Monadic"
      ]
    },
    "Init.Data.Iterators.Lemmas.Combinators.Monadic.ULift": {
      "path": "Init/Data/Iterators/Lemmas/Combinators/Monadic/ULift.olean",
      "imports": [
        "Init.Data.Iterators.Combinators.Monadic.ULift",
        "Init.Data.Iterators.Lemmas.Consumers.Monadic.Collect",
        "Init.Data.Iterators.Lemmas.Consumers.Monadic.Loop"
      ]
    },
    "Init.Data.Iterators.Lemmas.Combinators.Monadic": {
      "path": "Init/Data/Iterators/Lemmas/Combinators/Monadic.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Combinators.Monadic.Attach",
        "Init.Data.Iterators.Lemmas.Combinators.Monadic.FilterMap",
        "Init.Data.Iterators.Lemmas.Combinators.Monadic.FlatMap",
        "Init.Data.Iterators.Lemmas.Combinators.Monadic.Take",
        "Init.Data.Iterators.Lemmas.Combinators.Monadic.ULift"
      ]
    },
    "Init.Data.Iterators.Lemmas.Combinators.Take": {
      "path": "Init/Data/Iterators/Lemmas/Combinators/Take.olean",
      "imports": [
        "Init.Data.Iterators.Combinators.Take",
        "Init.Data.Iterators.Lemmas.Combinators.Monadic.Take",
        "Init.Data.Iterators.Lemmas.Consumers"
      ]
    },
    "Init.Data.Iterators.Lemmas.Combinators.ULift": {
      "path": "Init/Data/Iterators/Lemmas/Combinators/ULift.olean",
      "imports": [
        "Init.Data.Iterators.Combinators.ULift",
        "all",
        "Init.Data.Iterators.Lemmas.Combinators.Monadic.ULift",
        "Init.Data.Iterators.Lemmas.Consumers.Collect",
        "Init.Data.Iterators.Lemmas.Consumers.Loop"
      ]
    },
    "Init.Data.Iterators.Lemmas.Combinators": {
      "path": "Init/Data/Iterators/Lemmas/Combinators.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Combinators.Attach",
        "Init.Data.Iterators.Lemmas.Combinators.Monadic",
        "Init.Data.Iterators.Lemmas.Combinators.FilterMap",
        "Init.Data.Iterators.Lemmas.Combinators.FlatMap",
        "Init.Data.Iterators.Lemmas.Combinators.Take",
        "Init.Data.Iterators.Lemmas.Combinators.ULift"
      ]
    },
    "Init.Data.Iterators.Lemmas.Consumers.Collect": {
      "path": "Init/Data/Iterators/Lemmas/Consumers/Collect.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Basic",
        "Init.Data.Iterators.Lemmas.Consumers.Monadic.Collect",
        "Init.Data.Iterators.Consumers.Access",
        "all",
        "all",
        "all",
        "all"
      ]
    },
    "Init.Data.Iterators.Lemmas.Consumers.Loop": {
      "path": "Init/Data/Iterators/Lemmas/Consumers/Loop.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Consumers.Collect",
        "Init.Data.Iterators.Lemmas.Consumers.Monadic.Loop",
        "all",
        "all",
        "all",
        "Init.Data.Array.Monadic"
      ]
    },
    "Init.Data.Iterators.Lemmas.Consumers.Monadic.Collect": {
      "path": "Init/Data/Iterators/Lemmas/Consumers/Monadic/Collect.olean",
      "imports": [
        "Init.Data.Array.Lemmas",
        "Init.Data.Iterators.Lemmas.Monadic.Basic",
        "Init.Data.Iterators.Consumers.Monadic.Collect",
        "all",
        "all",
        "all"
      ]
    },
    "Init.Data.Iterators.Lemmas.Consumers.Monadic.Loop": {
      "path": "Init/Data/Iterators/Lemmas/Consumers/Monadic/Loop.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Consumers.Monadic.Collect",
        "Init.Data.Iterators.Consumers.Monadic.Loop",
        "all"
      ]
    },
    "Init.Data.Iterators.Lemmas.Consumers.Monadic": {
      "path": "Init/Data/Iterators/Lemmas/Consumers/Monadic.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Consumers.Monadic.Collect",
        "Init.Data.Iterators.Lemmas.Consumers.Monadic.Loop"
      ]
    },
    "Init.Data.Iterators.Lemmas.Consumers": {
      "path": "Init/Data/Iterators/Lemmas/Consumers.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Consumers.Monadic",
        "Init.Data.Iterators.Lemmas.Consumers.Collect",
        "Init.Data.Iterators.Lemmas.Consumers.Loop"
      ]
    },
    "Init.Data.Iterators.Lemmas.Monadic.Basic": {
      "path": "Init/Data/Iterators/Lemmas/Monadic/Basic.olean",
      "imports": [
        "Init.Data.Iterators.Basic"
      ]
    },
    "Init.Data.Iterators.Lemmas.Producers.List": {
      "path": "Init/Data/Iterators/Lemmas/Producers/List.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Consumers.Collect",
        "Init.Data.Iterators.Producers.List",
        "Init.Data.Iterators.Lemmas.Producers.Monadic.List"
      ]
    },
    "Init.Data.Iterators.Lemmas.Producers.Monadic.List": {
      "path": "Init/Data/Iterators/Lemmas/Producers/Monadic/List.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Consumers.Monadic",
        "Init.Data.Iterators.Producers.Monadic.List"
      ]
    },
    "Init.Data.Iterators.Lemmas.Producers.Monadic": {
      "path": "Init/Data/Iterators/Lemmas/Producers/Monadic.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Producers.Monadic.List"
      ]
    },
    "Init.Data.Iterators.Lemmas.Producers": {
      "path": "Init/Data/Iterators/Lemmas/Producers.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Producers.Monadic",
        "Init.Data.Iterators.Lemmas.Producers.List"
      ]
    },
    "Init.Data.Iterators.Lemmas": {
      "path": "Init/Data/Iterators/Lemmas.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Consumers",
        "Init.Data.Iterators.Lemmas.Combinators",
        "Init.Data.Iterators.Lemmas.Producers"
      ]
    },
    "Init.Data.Iterators.PostconditionMonad": {
      "path": "Init/Data/Iterators/PostconditionMonad.olean",
      "imports": [
        "Init.Control.Lawful.Basic",
        "Init.Data.Subtype.Basic",
        "Init.PropLemmas",
        "Init.Control.Lawful.MonadLift.Basic"
      ]
    },
    "Init.Data.Iterators.Producers.List": {
      "path": "Init/Data/Iterators/Producers/List.olean",
      "imports": [
        "Init.Data.Iterators.Producers.Monadic.List"
      ]
    },
    "Init.Data.Iterators.Producers.Monadic.List": {
      "path": "Init/Data/Iterators/Producers/Monadic/List.olean",
      "imports": [
        "Init.Data.Iterators.Consumers",
        "Init.Data.Iterators.Internal.Termination"
      ]
    },
    "Init.Data.Iterators.Producers.Monadic": {
      "path": "Init/Data/Iterators/Producers/Monadic.olean",
      "imports": [
        "Init.Data.Iterators.Producers.Monadic.List"
      ]
    },
    "Init.Data.Iterators.Producers": {
      "path": "Init/Data/Iterators/Producers.olean",
      "imports": [
        "Init.Data.Iterators.Producers.Monadic",
        "Init.Data.Iterators.Producers.List"
      ]
    },
    "Init.Data.Iterators.ToIterator": {
      "path": "Init/Data/Iterators/ToIterator.olean",
      "imports": [
        "Init.Data.Iterators.Consumers.Loop"
      ]
    },
    "Init.Data.Iterators": {
      "path": "Init/Data/Iterators.olean",
      "imports": [
        "Init.Data.Iterators.Basic",
        "Init.Data.Iterators.PostconditionMonad",
        "Init.Data.Iterators.Consumers",
        "Init.Data.Iterators.Producers",
        "Init.Data.Iterators.Combinators",
        "Init.Data.Iterators.Lemmas",
        "Init.Data.Iterators.ToIterator",
        "Init.Data.Iterators.Internal"
      ]
    },
    "Init.Data.LawfulHashable": {
      "path": "Init/Data/LawfulHashable.olean",
      "imports": [
        "Init.Core"
      ]
    },
    "Init.Data.List.Attach": {
      "path": "Init/Data/List/Attach.olean",
      "imports": [
        "all",
        "Init.Data.List.Count",
        "Init.Data.Subtype.Basic"
      ]
    },
    "Init.Data.List.Basic": {
      "path": "Init/Data/List/Basic.olean",
      "imports": [
        "Init.Data.List.Notation",
        "Init.Data.Nat.Div.Basic"
      ]
    },
    "Init.Data.List.BasicAux": {
      "path": "Init/Data/List/BasicAux.olean",
      "imports": [
        "Init.Data.Nat.Linear"
      ]
    },
    "Init.Data.List.Control": {
      "path": "Init/Data/List/Control.olean",
      "imports": [
        "Init.Control.Lawful"
      ]
    },
    "Init.Data.List.Count": {
      "path": "Init/Data/List/Count.olean",
      "imports": [
        "Init.Data.List.Sublist"
      ]
    },
    "Init.Data.List.Erase": {
      "path": "Init/Data/List/Erase.olean",
      "imports": [
        "Init.Data.List.Find"
      ]
    },
    "Init.Data.List.FinRange": {
      "path": "Init/Data/List/FinRange.olean",
      "imports": [
        "all",
        "Init.Data.List.Monadic"
      ]
    },
    "Init.Data.List.Find": {
      "path": "Init/Data/List/Find.olean",
      "imports": [
        "Init.Data.List.Range",
        "Init.Data.List.Impl",
        "all",
        "Init.Data.Fin.Lemmas"
      ]
    },
    "Init.Data.List.Impl": {
      "path": "Init/Data/List/Impl.olean",
      "imports": [
        "Init.Data.Array.Bootstrap"
      ]
    },
    "Init.Data.List.Lemmas": {
      "path": "Init/Data/List/Lemmas.olean",
      "imports": [
        "Init.Data.Option.Lemmas",
        "Init.Data.List.BasicAux",
        "all",
        "Init.Data.List.Control",
        "all",
        "Init.BinderPredicates",
        "Init.Grind.Annotated"
      ]
    },
    "Init.Data.List.Lex": {
      "path": "Init/Data/List/Lex.olean",
      "imports": [
        "Init.Data.List.Nat.TakeDrop",
        "Init.Data.Order.Lemmas"
      ]
    },
    "Init.Data.List.MapIdx": {
      "path": "Init/Data/List/MapIdx.olean",
      "imports": [
        "Init.Data.List.Nat.Range",
        "Init.Data.Option.Attach"
      ]
    },
    "Init.Data.List.MinMax": {
      "path": "Init/Data/List/MinMax.olean",
      "imports": [
        "Init.Data.List.Pairwise",
        "Init.Data.Subtype.Order",
        "Init.Data.Order.Lemmas"
      ]
    },
    "Init.Data.List.Monadic": {
      "path": "Init/Data/List/Monadic.olean",
      "imports": [
        "Init.Data.List.Attach",
        "Init.Data.List.OfFn",
        "Init.Data.Array.Bootstrap",
        "all"
      ]
    },
    "Init.Data.List.Nat.BEq": {
      "path": "Init/Data/List/Nat/BEq.olean",
      "imports": [
        "Init.Data.Nat.Lemmas",
        "Init.Data.List.Lemmas"
      ]
    },
    "Init.Data.List.Nat.Basic": {
      "path": "Init/Data/List/Nat/Basic.olean",
      "imports": [
        "Init.Data.List.Find",
        "Init.Data.List.MinMax",
        "Init.Data.Nat.Order"
      ]
    },
    "Init.Data.List.Nat.Count": {
      "path": "Init/Data/List/Nat/Count.olean",
      "imports": [
        "Init.Data.List.Count",
        "Init.Data.Nat.Lemmas"
      ]
    },
    "Init.Data.List.Nat.Erase": {
      "path": "Init/Data/List/Nat/Erase.olean",
      "imports": [
        "Init.Data.List.Nat.TakeDrop",
        "Init.Data.List.Erase"
      ]
    },
    "Init.Data.List.Nat.Find": {
      "path": "Init/Data/List/Nat/Find.olean",
      "imports": [
        "Init.Data.List.Nat.Range"
      ]
    },
    "Init.Data.List.Nat.InsertIdx": {
      "path": "Init/Data/List/Nat/InsertIdx.olean",
      "imports": [
        "Init.Data.List.Nat.Modify"
      ]
    },
    "Init.Data.List.Nat.Modify": {
      "path": "Init/Data/List/Nat/Modify.olean",
      "imports": [
        "Init.Data.List.Nat.Erase"
      ]
    },
    "Init.Data.List.Nat.Pairwise": {
      "path": "Init/Data/List/Nat/Pairwise.olean",
      "imports": [
        "Init.Data.List.Nat.TakeDrop"
      ]
    },
    "Init.Data.List.Nat.Perm": {
      "path": "Init/Data/List/Nat/Perm.olean",
      "imports": [
        "Init.Data.List.Nat.TakeDrop",
        "Init.Data.List.Perm"
      ]
    },
    "Init.Data.List.Nat.Range": {
      "path": "Init/Data/List/Nat/Range.olean",
      "imports": [
        "Init.Data.List.Nat.TakeDrop",
        "Init.Data.List.Erase"
      ]
    },
    "Init.Data.List.Nat.Sublist": {
      "path": "Init/Data/List/Nat/Sublist.olean",
      "imports": [
        "Init.Data.List.Nat.Basic",
        "Init.Data.List.Nat.TakeDrop"
      ]
    },
    "Init.Data.List.Nat.TakeDrop": {
      "path": "Init/Data/List/Nat/TakeDrop.olean",
      "imports": [
        "Init.Data.List.Find"
      ]
    },
    "Init.Data.List.Nat": {
      "path": "Init/Data/List/Nat.olean",
      "imports": [
        "Init.Data.List.Nat.Basic",
        "Init.Data.List.Nat.Pairwise",
        "Init.Data.List.Nat.Range",
        "Init.Data.List.Nat.Sublist",
        "Init.Data.List.Nat.TakeDrop",
        "Init.Data.List.Nat.Count",
        "Init.Data.List.Nat.Erase",
        "Init.Data.List.Nat.Find",
        "Init.Data.List.Nat.BEq",
        "Init.Data.List.Nat.Modify",
        "Init.Data.List.Nat.InsertIdx",
        "Init.Data.List.Nat.Perm"
      ]
    },
    "Init.Data.List.Notation": {
      "path": "Init/Data/List/Notation.olean",
      "imports": [
        "Init.Data.Nat.Div.Basic"
      ]
    },
    "Init.Data.List.OfFn": {
      "path": "Init/Data/List/OfFn.olean",
      "imports": [
        "Init.Data.Fin.Fold",
        "Init.Data.List.Lemmas"
      ]
    },
    "Init.Data.List.Pairwise": {
      "path": "Init/Data/List/Pairwise.olean",
      "imports": [
        "Init.Data.List.Attach"
      ]
    },
    "Init.Data.List.Perm": {
      "path": "Init/Data/List/Perm.olean",
      "imports": [
        "Init.Data.List.Erase",
        "all"
      ]
    },
    "Init.Data.List.Range": {
      "path": "Init/Data/List/Range.olean",
      "imports": [
        "Init.Data.List.Pairwise",
        "Init.Data.List.Zip"
      ]
    },
    "Init.Data.List.Sort.Basic": {
      "path": "Init/Data/List/Sort/Basic.olean",
      "imports": [
        "Init.Data.List.Nat.TakeDrop"
      ]
    },
    "Init.Data.List.Sort.Impl": {
      "path": "Init/Data/List/Sort/Impl.olean",
      "imports": [
        "all",
        "Init.Data.List.Sort.Lemmas"
      ]
    },
    "Init.Data.List.Sort.Lemmas": {
      "path": "Init/Data/List/Sort/Lemmas.olean",
      "imports": [
        "Init.Data.List.Perm",
        "Init.Data.List.Sort.Basic",
        "all",
        "Init.Data.List.Nat.Range"
      ]
    },
    "Init.Data.List.Sort": {
      "path": "Init/Data/List/Sort.olean",
      "imports": [
        "Init.Data.List.Sort.Basic",
        "Init.Data.List.Sort.Impl",
        "Init.Data.List.Sort.Lemmas"
      ]
    },
    "Init.Data.List.Sublist": {
      "path": "Init/Data/List/Sublist.olean",
      "imports": [
        "Init.Data.List.TakeDrop"
      ]
    },
    "Init.Data.List.TakeDrop": {
      "path": "Init/Data/List/TakeDrop.olean",
      "imports": [
        "all",
        "Init.Data.List.Lemmas"
      ]
    },
    "Init.Data.List.ToArray": {
      "path": "Init/Data/List/ToArray.olean",
      "imports": [
        "all",
        "Init.Data.List.Monadic",
        "Init.Data.List.Nat.InsertIdx",
        "all",
        "all"
      ]
    },
    "Init.Data.List.ToArrayImpl": {
      "path": "Init/Data/List/ToArrayImpl.olean",
      "imports": [
        "Init.Data.List.Basic"
      ]
    },
    "Init.Data.List.Zip": {
      "path": "Init/Data/List/Zip.olean",
      "imports": [
        "Init.Data.List.TakeDrop",
        "Init.Data.Function"
      ]
    },
    "Init.Data.List": {
      "path": "Init/Data/List.olean",
      "imports": [
        "Init.Data.List.Attach",
        "Init.Data.List.Basic",
        "Init.Data.List.BasicAux",
        "Init.Data.List.Control",
        "Init.Data.List.Count",
        "Init.Data.List.Erase",
        "Init.Data.List.Find",
        "Init.Data.List.Impl",
        "Init.Data.List.Lemmas",
        "Init.Data.List.MinMax",
        "Init.Data.List.Monadic",
        "Init.Data.List.Nat",
        "Init.Data.List.Notation",
        "Init.Data.List.Pairwise",
        "Init.Data.List.Sublist",
        "Init.Data.List.TakeDrop",
        "Init.Data.List.Zip",
        "Init.Data.List.Perm",
        "Init.Data.List.Sort",
        "Init.Data.List.ToArray",
        "Init.Data.List.ToArrayImpl",
        "Init.Data.List.MapIdx",
        "Init.Data.List.OfFn",
        "Init.Data.List.FinRange",
        "Init.Data.List.Lex"
      ]
    },
    "Init.Data.Nat.Basic": {
      "path": "Init/Data/Nat/Basic.olean",
      "imports": [
        "Init.SimpLemmas",
        "Init.Data.NeZero",
        "Init.Grind.Tactics"
      ]
    },
    "Init.Data.Nat.Bitwise.Basic": {
      "path": "Init/Data/Nat/Bitwise/Basic.olean",
      "imports": [
        "Init.Data.Nat.Div.Basic"
      ]
    },
    "Init.Data.Nat.Bitwise.Lemmas": {
      "path": "Init/Data/Nat/Bitwise/Lemmas.olean",
      "imports": [
        "Init.Data.Int.Pow",
        "all",
        "Init.Data.Nat.Simproc",
        "Init.TacticsExtra",
        "Init.BinderPredicates"
      ]
    },
    "Init.Data.Nat.Bitwise": {
      "path": "Init/Data/Nat/Bitwise.olean",
      "imports": [
        "Init.Data.Nat.Bitwise.Basic",
        "Init.Data.Nat.Bitwise.Lemmas"
      ]
    },
    "Init.Data.Nat.Compare": {
      "path": "Init/Data/Nat/Compare.olean",
      "imports": [
        "Init.Data.Ord.Basic",
        "all"
      ]
    },
    "Init.Data.Nat.Control": {
      "path": "Init/Data/Nat/Control.olean",
      "imports": [
        "Init.Omega"
      ]
    },
    "Init.Data.Nat.Coprime": {
      "path": "Init/Data/Nat/Coprime.olean",
      "imports": [
        "Init.Data.Nat.Gcd"
      ]
    },
    "Init.Data.Nat.Div.Basic": {
      "path": "Init/Data/Nat/Div/Basic.olean",
      "imports": [
        "Init.WFTactics",
        "Init.MetaTypes"
      ]
    },
    "Init.Data.Nat.Div.Lemmas": {
      "path": "Init/Data/Nat/Div/Lemmas.olean",
      "imports": [
        "Init.Data.Nat.Simproc",
        "Init.TacticsExtra"
      ]
    },
    "Init.Data.Nat.Div": {
      "path": "Init/Data/Nat/Div.olean",
      "imports": [
        "Init.Data.Nat.Div.Basic",
        "Init.Data.Nat.Div.Lemmas"
      ]
    },
    "Init.Data.Nat.Dvd": {
      "path": "Init/Data/Nat/Dvd.olean",
      "imports": [
        "Init.Meta"
      ]
    },
    "Init.Data.Nat.Fold": {
      "path": "Init/Data/Nat/Fold.olean",
      "imports": [
        "Init.Data.List.FinRange"
      ]
    },
    "Init.Data.Nat.Gcd": {
      "path": "Init/Data/Nat/Gcd.olean",
      "imports": [
        "Init.Data.Nat.Dvd",
        "Init.NotationExtra",
        "Init.RCases"
      ]
    },
    "Init.Data.Nat.Lcm": {
      "path": "Init/Data/Nat/Lcm.olean",
      "imports": [
        "Init.Data.Nat.Lemmas"
      ]
    },
    "Init.Data.Nat.Lemmas": {
      "path": "Init/Data/Nat/Lemmas.olean",
      "imports": [
        "all",
        "Init.Data.Nat.MinMax",
        "Init.Data.Nat.Log2",
        "all",
        "Init.Data.Nat.Power2",
        "Init.Data.Nat.Mod",
        "Init.TacticsExtra",
        "Init.BinderPredicates"
      ]
    },
    "Init.Data.Nat.Linear": {
      "path": "Init/Data/Nat/Linear.olean",
      "imports": [
        "Init.ByCases",
        "Init.Data.Prod",
        "Init.Data.RArray",
        "Init.LawfulBEqTactics"
      ]
    },
    "Init.Data.Nat.Log2": {
      "path": "Init/Data/Nat/Log2.olean",
      "imports": [
        "Init.Data.Nat.Linear"
      ]
    },
    "Init.Data.Nat.MinMax": {
      "path": "Init/Data/Nat/MinMax.olean",
      "imports": [
        "Init.ByCases"
      ]
    },
    "Init.Data.Nat.Mod": {
      "path": "Init/Data/Nat/Mod.olean",
      "imports": [
        "Init.Omega"
      ]
    },
    "Init.Data.Nat.Order": {
      "path": "Init/Data/Nat/Order.olean",
      "imports": [
        "Init.Data.Nat.Basic",
        "Init.Data.Nat.MinMax",
        "Init.Data.Order.Factories"
      ]
    },
    "Init.Data.Nat.Power2": {
      "path": "Init/Data/Nat/Power2.olean",
      "imports": [
        "Init.Data.Nat.Linear"
      ]
    },
    "Init.Data.Nat.SOM": {
      "path": "Init/Data/Nat/SOM.olean",
      "imports": [
        "Init.Data.List.BasicAux"
      ]
    },
    "Init.Data.Nat.Simproc": {
      "path": "Init/Data/Nat/Simproc.olean",
      "imports": [
        "Init.Data.Bool",
        "Init.Data.Nat.Lemmas"
      ]
    },
    "Init.Data.Nat": {
      "path": "Init/Data/Nat.olean",
      "imports": [
        "Init.Data.Nat.Basic",
        "Init.Data.Nat.Div",
        "Init.Data.Nat.Dvd",
        "Init.Data.Nat.Gcd",
        "Init.Data.Nat.Coprime",
        "Init.Data.Nat.MinMax",
        "Init.Data.Nat.Order",
        "Init.Data.Nat.Bitwise",
        "Init.Data.Nat.Control",
        "Init.Data.Nat.Log2",
        "Init.Data.Nat.Power2",
        "Init.Data.Nat.Linear",
        "Init.Data.Nat.SOM",
        "Init.Data.Nat.Lemmas",
        "Init.Data.Nat.Mod",
        "Init.Data.Nat.Lcm",
        "Init.Data.Nat.Compare",
        "Init.Data.Nat.Simproc",
        "Init.Data.Nat.Fold",
        "Init.Data.Nat.Order"
      ]
    },
    "Init.Data.NeZero": {
      "path": "Init/Data/NeZero.olean",
      "imports": [
        "Init.Data.Zero"
      ]
    },
    "Init.Data.OfScientific": {
      "path": "Init/Data/OfScientific.olean",
      "imports": [
        "Init.Data.Float32",
        "Init.Data.Nat.Log2"
      ]
    },
    "Init.Data.Option.Array": {
      "path": "Init/Data/Option/Array.olean",
      "imports": [
        "Init.Data.Array.Lemmas",
        "Init.Data.Option.List",
        "all"
      ]
    },
    "Init.Data.Option.Attach": {
      "path": "Init/Data/Option/Attach.olean",
      "imports": [
        "Init.Data.Option.Array",
        "Init.Data.Array.Attach"
      ]
    },
    "Init.Data.Option.Basic": {
      "path": "Init/Data/Option/Basic.olean",
      "imports": [
        "Init.Control.Basic",
        "Init.Grind.Tactics"
      ]
    },
    "Init.Data.Option.BasicAux": {
      "path": "Init/Data/Option/BasicAux.olean",
      "imports": [
        "Init.Util"
      ]
    },
    "Init.Data.Option.Coe": {
      "path": "Init/Data/Option/Coe.olean",
      "imports": [
        "Init.Coe"
      ]
    },
    "Init.Data.Option.Instances": {
      "path": "Init/Data/Option/Instances.olean",
      "imports": [
        "Init.Data.Option.Basic"
      ]
    },
    "Init.Data.Option.Lemmas": {
      "path": "Init/Data/Option/Lemmas.olean",
      "imports": [
        "all",
        "Init.Data.Option.Instances",
        "all",
        "Init.Data.BEq",
        "Init.Classical",
        "Init.Ext"
      ]
    },
    "Init.Data.Option.List": {
      "path": "Init/Data/Option/List.olean",
      "imports": [
        "Init.Data.List.Lemmas",
        "all",
        "all"
      ]
    },
    "Init.Data.Option.Monadic": {
      "path": "Init/Data/Option/Monadic.olean",
      "imports": [
        "all",
        "Init.Data.Option.Attach"
      ]
    },
    "Init.Data.Option": {
      "path": "Init/Data/Option.olean",
      "imports": [
        "Init.Data.Option.Basic",
        "Init.Data.Option.BasicAux",
        "Init.Data.Option.Coe",
        "Init.Data.Option.Instances",
        "Init.Data.Option.Lemmas",
        "Init.Data.Option.Attach",
        "Init.Data.Option.List",
        "Init.Data.Option.Monadic",
        "Init.Data.Option.Array"
      ]
    },
    "Init.Data.Ord.Array": {
      "path": "Init/Data/Ord/Array.olean",
      "imports": [
        "Init.Data.Ord.Basic",
        "Init.Omega"
      ]
    },
    "Init.Data.Ord.Basic": {
      "path": "Init/Data/Ord/Basic.olean",
      "imports": [
        "Init.ByCases",
        "Init.Ext",
        "Init.PropLemmas"
      ]
    },
    "Init.Data.Ord.BitVec": {
      "path": "Init/Data/Ord/BitVec.olean",
      "imports": [
        "Init.Data.Order.Ord",
        "Init.Data.BitVec.Lemmas"
      ]
    },
    "Init.Data.Ord.SInt": {
      "path": "Init/Data/Ord/SInt.olean",
      "imports": [
        "Init.Data.Order.Ord",
        "Init.Data.SInt.Lemmas"
      ]
    },
    "Init.Data.Ord.String": {
      "path": "Init/Data/Ord/String.olean",
      "imports": [
        "Init.Data.Order.Ord",
        "Init.Data.String.Lemmas"
      ]
    },
    "Init.Data.Ord.UInt": {
      "path": "Init/Data/Ord/UInt.olean",
      "imports": [
        "Init.Data.Order.Ord",
        "Init.Data.UInt.Lemmas"
      ]
    },
    "Init.Data.Ord.Vector": {
      "path": "Init/Data/Ord/Vector.olean",
      "imports": [
        "Init.Data.Order.Ord",
        "Init.Data.Vector.Lemmas"
      ]
    },
    "Init.Data.Ord": {
      "path": "Init/Data/Ord.olean",
      "imports": [
        "Init.Data.Ord.Basic",
        "Init.Data.Ord.BitVec",
        "Init.Data.Ord.SInt",
        "Init.Data.Ord.String",
        "Init.Data.Ord.UInt",
        "Init.Data.Ord.Vector",
        "Init.Data.Ord.Array"
      ]
    },
    "Init.Data.Order.Classes": {
      "path": "Init/Data/Order/Classes.olean",
      "imports": [
        "Init.Core"
      ]
    },
    "Init.Data.Order.ClassesExtra": {
      "path": "Init/Data/Order/ClassesExtra.olean",
      "imports": [
        "Init.Data.Order.Classes",
        "Init.Data.Ord.Basic"
      ]
    },
    "Init.Data.Order.Factories": {
      "path": "Init/Data/Order/Factories.olean",
      "imports": [
        "Init.Data.Order.Classes",
        "Init.Classical"
      ]
    },
    "Init.Data.Order.FactoriesExtra": {
      "path": "Init/Data/Order/FactoriesExtra.olean",
      "imports": [
        "Init.Data.Order.ClassesExtra",
        "Init.Data.Order.Ord",
        "Init.Data.Order.Lemmas"
      ]
    },
    "Init.Data.Order.Lemmas": {
      "path": "Init/Data/Order/Lemmas.olean",
      "imports": [
        "Init.Data.Order.Factories",
        "all",
        "Init.Classical",
        "Init.Data.BEq"
      ]
    },
    "Init.Data.Order.LemmasExtra": {
      "path": "Init/Data/Order/LemmasExtra.olean",
      "imports": [
        "Init.Data.Order.FactoriesExtra",
        "Init.Data.Order.Lemmas",
        "Init.ByCases"
      ]
    },
    "Init.Data.Order.Ord": {
      "path": "Init/Data/Order/Ord.olean",
      "imports": [
        "Init.Data.List.Lemmas",
        "Init.Data.Array.DecidableEq",
        "Init.Data.Ord.Array",
        "Init.Data.BEq"
      ]
    },
    "Init.Data.Order.PackageFactories": {
      "path": "Init/Data/Order/PackageFactories.olean",
      "imports": [
        "Init.Data.Order.LemmasExtra"
      ]
    },
    "Init.Data.Order": {
      "path": "Init/Data/Order.olean",
      "imports": [
        "Init.Data.Order.Ord",
        "Init.Data.Order.Classes",
        "Init.Data.Order.ClassesExtra",
        "Init.Data.Order.Lemmas",
        "Init.Data.Order.LemmasExtra",
        "Init.Data.Order.Factories",
        "Init.Data.Order.FactoriesExtra",
        "Init.Data.Order.PackageFactories"
      ]
    },
    "Init.Data.PLift": {
      "path": "Init/Data/PLift.olean",
      "imports": [
        "Init.Core"
      ]
    },
    "Init.Data.Prod": {
      "path": "Init/Data/Prod.olean",
      "imports": [
        "Init.NotationExtra"
      ]
    },
    "Init.Data.Queue": {
      "path": "Init/Data/Queue.olean",
      "imports": [
        "Init.Data.List.Control"
      ]
    },
    "Init.Data.RArray": {
      "path": "Init/Data/RArray.olean",
      "imports": [
        "Init.PropLemmas"
      ]
    },
    "Init.Data.Random": {
      "path": "Init/Data/Random.olean",
      "imports": [
        "Init.System.IO",
        "Init.Data.ByteArray.Extra"
      ]
    },
    "Init.Data.Range.Basic": {
      "path": "Init/Data/Range/Basic.olean",
      "imports": [
        "Init.Omega"
      ]
    },
    "Init.Data.Range.Lemmas": {
      "path": "Init/Data/Range/Lemmas.olean",
      "imports": [
        "Init.Data.Range.Basic",
        "all",
        "Init.Data.List.Range",
        "Init.Data.List.Monadic",
        "Init.Data.Nat.Div.Lemmas"
      ]
    },
    "Init.Data.Range.Polymorphic.Basic": {
      "path": "Init/Data/Range/Polymorphic/Basic.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.PRange"
      ]
    },
    "Init.Data.Range.Polymorphic.BitVec": {
      "path": "Init/Data/Range/Polymorphic/BitVec.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.Instances",
        "Init.Data.Order.Lemmas",
        "Init.Data.UInt",
        "Init.Omega"
      ]
    },
    "Init.Data.Range.Polymorphic.GetElemTactic": {
      "path": "Init/Data/Range/Polymorphic/GetElemTactic.olean",
      "imports": [
        "Init.Data.Vector.Basic",
        "Init.Data.Slice.Array.Lemmas"
      ]
    },
    "Init.Data.Range.Polymorphic.Instances": {
      "path": "Init/Data/Range/Polymorphic/Instances.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.Basic",
        "Init.Data.Nat.Lemmas",
        "Init.Data.Order.Lemmas"
      ]
    },
    "Init.Data.Range.Polymorphic.Int": {
      "path": "Init/Data/Range/Polymorphic/Int.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.Instances",
        "Init.Data.Int.Order",
        "Init.Omega"
      ]
    },
    "Init.Data.Range.Polymorphic.IntLemmas": {
      "path": "Init/Data/Range/Polymorphic/IntLemmas.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.Int",
        "Init.Data.Range.Polymorphic.Lemmas"
      ]
    },
    "Init.Data.Range.Polymorphic.Internal.SignedBitVec": {
      "path": "Init/Data/Range/Polymorphic/Internal/SignedBitVec.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.BitVec"
      ]
    },
    "Init.Data.Range.Polymorphic.Iterators": {
      "path": "Init/Data/Range/Polymorphic/Iterators.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.RangeIterator",
        "Init.Data.Range.Polymorphic.Basic",
        "Init.Data.Iterators.Combinators.Attach"
      ]
    },
    "Init.Data.Range.Polymorphic.Lemmas": {
      "path": "Init/Data/Range/Polymorphic/Lemmas.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Consumers.Loop",
        "Init.Data.Iterators.Lemmas.Consumers.Collect",
        "all",
        "all",
        "Init.Data.Range.Polymorphic.Iterators",
        "all",
        "all",
        "Init.Data.Array.Monadic"
      ]
    },
    "Init.Data.Range.Polymorphic.Nat": {
      "path": "Init/Data/Range/Polymorphic/Nat.olean",
      "imports": [
        "Init.Data.Nat.Lemmas",
        "Init.Data.Nat.Order",
        "Init.Data.Range.Polymorphic.Instances",
        "Init.Data.Order.Lemmas"
      ]
    },
    "Init.Data.Range.Polymorphic.NatLemmas": {
      "path": "Init/Data/Range/Polymorphic/NatLemmas.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.Nat",
        "Init.Data.Range.Polymorphic.Lemmas"
      ]
    },
    "Init.Data.Range.Polymorphic.PRange": {
      "path": "Init/Data/Range/Polymorphic/PRange.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.UpwardEnumerable"
      ]
    },
    "Init.Data.Range.Polymorphic.RangeIterator": {
      "path": "Init/Data/Range/Polymorphic/RangeIterator.olean",
      "imports": [
        "Init.Data.Iterators.Internal.Termination",
        "Init.Data.Iterators.Consumers.Access",
        "Init.Data.Iterators.Lemmas.Consumers.Monadic.Loop",
        "Init.Data.Range.Polymorphic.PRange",
        "Init.Data.List.Sublist",
        "Init.WFExtrinsicFix"
      ]
    },
    "Init.Data.Range.Polymorphic.SInt": {
      "path": "Init/Data/Range/Polymorphic/SInt.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.Instances",
        "Init.Data.Order.Lemmas",
        "Init.Data.SInt",
        "Init.Data.Range.Polymorphic.UInt",
        "all",
        "all"
      ]
    },
    "Init.Data.Range.Polymorphic.Stream": {
      "path": "Init/Data/Range/Polymorphic/Stream.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.Iterators",
        "Init.Data.Iterators.Consumers.Stream"
      ]
    },
    "Init.Data.Range.Polymorphic.UInt": {
      "path": "Init/Data/Range/Polymorphic/UInt.olean",
      "imports": [
        "Init.Omega",
        "Init.Data.Range.Polymorphic.BitVec"
      ]
    },
    "Init.Data.Range.Polymorphic.UpwardEnumerable": {
      "path": "Init/Data/Range/Polymorphic/UpwardEnumerable.olean",
      "imports": [
        "Init.Data.Option.Lemmas",
        "Init.Data.Order.Classes"
      ]
    },
    "Init.Data.Range.Polymorphic": {
      "path": "Init/Data/Range/Polymorphic.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.Basic",
        "Init.Data.Range.Polymorphic.Iterators",
        "Init.Data.Range.Polymorphic.Stream",
        "Init.Data.Range.Polymorphic.Lemmas",
        "Init.Data.Range.Polymorphic.Nat",
        "Init.Data.Range.Polymorphic.Int",
        "Init.Data.Range.Polymorphic.BitVec",
        "Init.Data.Range.Polymorphic.UInt",
        "Init.Data.Range.Polymorphic.SInt",
        "Init.Data.Range.Polymorphic.NatLemmas",
        "Init.Data.Range.Polymorphic.IntLemmas",
        "Init.Data.Range.Polymorphic.GetElemTactic"
      ]
    },
    "Init.Data.Range": {
      "path": "Init/Data/Range.olean",
      "imports": [
        "Init.Data.Range.Basic",
        "Init.Data.Range.Lemmas"
      ]
    },
    "Init.Data.Rat.Basic": {
      "path": "Init/Data/Rat/Basic.olean",
      "imports": [
        "Init.Data.Nat.Coprime",
        "Init.Data.Hashable",
        "Init.Data.OfScientific",
        "Init.Data.Int.Bitwise"
      ]
    },
    "Init.Data.Rat.Lemmas": {
      "path": "Init/Data/Rat/Lemmas.olean",
      "imports": [
        "Init.Data.Rat.Basic",
        "Init.Data.Int.Gcd",
        "Init.Data.Int.Bitwise.Lemmas"
      ]
    },
    "Init.Data.Rat": {
      "path": "Init/Data/Rat.olean",
      "imports": [
        "Init.Data.Rat.Basic",
        "Init.Data.Rat.Lemmas"
      ]
    },
    "Init.Data.Repr": {
      "path": "Init/Data/Repr.olean",
      "imports": [
        "Init.Data.Format.Basic"
      ]
    },
    "Init.Data.SInt.Basic": {
      "path": "Init/Data/SInt/Basic.olean",
      "imports": [
        "Init.Data.UInt.Basic"
      ]
    },
    "Init.Data.SInt.Bitwise": {
      "path": "Init/Data/SInt/Bitwise.olean",
      "imports": [
        "all",
        "Init.Data.UInt.Bitwise",
        "all",
        "all",
        "all",
        "Init.Data.SInt.Lemmas"
      ]
    },
    "Init.Data.SInt.Float": {
      "path": "Init/Data/SInt/Float.olean",
      "imports": [
        "Init.Data.Float",
        "Init.Data.SInt.Basic"
      ]
    },
    "Init.Data.SInt.Float32": {
      "path": "Init/Data/SInt/Float32.olean",
      "imports": [
        "Init.Data.Float32",
        "Init.Data.SInt.Basic"
      ]
    },
    "Init.Data.SInt.Lemmas": {
      "path": "Init/Data/SInt/Lemmas.olean",
      "imports": [
        "all",
        "Init.Data.SInt.Basic",
        "all",
        "all",
        "Init.Data.BitVec.Bitblast",
        "all",
        "Init.Data.UInt.Lemmas",
        "Init.Data.Order.Lemmas"
      ]
    },
    "Init.Data.SInt": {
      "path": "Init/Data/SInt.olean",
      "imports": [
        "Init.Data.SInt.Basic",
        "Init.Data.SInt.Float",
        "Init.Data.SInt.Float32",
        "Init.Data.SInt.Lemmas",
        "Init.Data.SInt.Bitwise"
      ]
    },
    "Init.Data.Slice.Array.Basic": {
      "path": "Init/Data/Slice/Array/Basic.olean",
      "imports": [
        "Init.Data.Array.Subarray",
        "Init.Data.Slice.Notation",
        "Init.Data.Range.Polymorphic.Nat"
      ]
    },
    "Init.Data.Slice.Array.Iterator": {
      "path": "Init/Data/Slice/Array/Iterator.olean",
      "imports": [
        "Init.Data.Slice.Array.Basic",
        "Init.Data.Slice.Operations",
        "Init.Data.Iterators.Combinators.Attach",
        "Init.Data.Iterators.Combinators.ULift",
        "all",
        "Init.Data.Range.Polymorphic.Iterators",
        "Init.Data.Slice.Operations",
        "Init.Omega",
        "Init.Data.Iterators.Lemmas.Combinators.Monadic.FilterMap"
      ]
    },
    "Init.Data.Slice.Array.Lemmas": {
      "path": "Init/Data/Slice/Array/Lemmas.olean",
      "imports": [
        "all",
        "all",
        "Init.Data.Slice.Lemmas",
        "Init.Data.Slice.Array.Iterator",
        "all",
        "all",
        "all",
        "Init.Data.Range.Polymorphic.Lemmas",
        "all",
        "Init.Data.Slice.Lemmas",
        "Init.Data.Iterators.Lemmas",
        "Init.Data.Slice.List.Lemmas",
        "Init.Data.Range.Polymorphic.NatLemmas"
      ]
    },
    "Init.Data.Slice.Array": {
      "path": "Init/Data/Slice/Array.olean",
      "imports": [
        "Init.Data.Slice.Array.Basic",
        "Init.Data.Slice.Array.Iterator",
        "Init.Data.Slice.Array.Lemmas"
      ]
    },
    "Init.Data.Slice.Basic": {
      "path": "Init/Data/Slice/Basic.olean",
      "imports": [
        "Init.Core"
      ]
    },
    "Init.Data.Slice.Lemmas": {
      "path": "Init/Data/Slice/Lemmas.olean",
      "imports": [
        "Init.Data.Slice.Operations",
        "all",
        "Init.Data.Iterators.Consumers",
        "Init.Data.Iterators.Lemmas.Consumers",
        "Init.Data.List.Control"
      ]
    },
    "Init.Data.Slice.List.Basic": {
      "path": "Init/Data/Slice/List/Basic.olean",
      "imports": [
        "Init.Data.Slice.Basic",
        "Init.Data.Slice.Notation",
        "Init.Data.Range.Polymorphic.Nat"
      ]
    },
    "Init.Data.Slice.List.Iterator": {
      "path": "Init/Data/Slice/List/Iterator.olean",
      "imports": [
        "Init.Data.Slice.List.Basic",
        "Init.Data.Iterators.Producers.List",
        "Init.Data.Iterators.Combinators.Take",
        "all",
        "Init.Data.Range.Polymorphic.Iterators",
        "Init.Data.Slice.Operations",
        "Init.Omega"
      ]
    },
    "Init.Data.Slice.List.Lemmas": {
      "path": "Init/Data/Slice/List/Lemmas.olean",
      "imports": [
        "all",
        "Init.Data.Slice.List.Iterator",
        "all",
        "all",
        "all",
        "all",
        "Init.Data.Slice.Lemmas",
        "Init.Data.Iterators.Lemmas"
      ]
    },
    "Init.Data.Slice.List": {
      "path": "Init/Data/Slice/List.olean",
      "imports": [
        "Init.Data.Slice.List.Basic",
        "Init.Data.Slice.List.Iterator",
        "Init.Data.Slice.List.Lemmas"
      ]
    },
    "Init.Data.Slice.Notation": {
      "path": "Init/Data/Slice/Notation.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.PRange"
      ]
    },
    "Init.Data.Slice.Operations": {
      "path": "Init/Data/Slice/Operations.olean",
      "imports": [
        "Init.Data.Slice.Basic",
        "Init.Data.Slice.Notation",
        "Init.Data.Iterators.ToIterator"
      ]
    },
    "Init.Data.Slice": {
      "path": "Init/Data/Slice.olean",
      "imports": [
        "Init.Data.Slice.Basic",
        "Init.Data.Slice.Notation",
        "Init.Data.Slice.Operations",
        "Init.Data.Slice.Array",
        "Init.Data.Slice.List",
        "Init.Data.Slice.Lemmas"
      ]
    },
    "Init.Data.Stream": {
      "path": "Init/Data/Stream.olean",
      "imports": [
        "Init.Data.Range",
        "Init.Data.Array.Subarray",
        "Init.Data.Slice.Array.Basic"
      ]
    },
    "Init.Data.String.Basic": {
      "path": "Init/Data/String/Basic.olean",
      "imports": [
        "Init.Data.String.Decode",
        "Init.Data.String.Defs",
        "Init.Data.String.PosRaw",
        "Init.Data.ByteArray.Lemmas",
        "Init.Data.Char.Lemmas"
      ]
    },
    "Init.Data.String.Bootstrap": {
      "path": "Init/Data/String/Bootstrap.olean",
      "imports": [
        "Init.Data.Char.Basic",
        "Init.Data.ByteArray.Bootstrap"
      ]
    },
    "Init.Data.String.Decode": {
      "path": "Init/Data/String/Decode.olean",
      "imports": [
        "Init.Data.UInt.Bitwise",
        "Init.Data.Char.Lemmas",
        "Init.Data.ByteArray.Basic",
        "Init.Data.ByteArray.Lemmas"
      ]
    },
    "Init.Data.String.Defs": {
      "path": "Init/Data/String/Defs.olean",
      "imports": [
        "Init.Data.ByteArray.Basic",
        "Init.Data.String.PosRaw",
        "Init.Data.ByteArray.Lemmas"
      ]
    },
    "Init.Data.String.Extra": {
      "path": "Init/Data/String/Extra.olean",
      "imports": [
        "all",
        "Init.Data.String.Basic",
        "all",
        "Init.Data.String.Substring",
        "Init.Data.String.Modify",
        "Init.Data.String.Search"
      ]
    },
    "Init.Data.String.Grind": {
      "path": "Init/Data/String/Grind.olean",
      "imports": [
        "Init.Data.String.Defs",
        "Init.Grind.ToInt"
      ]
    },
    "Init.Data.String.Iterator": {
      "path": "Init/Data/String/Iterator.olean",
      "imports": [
        "Init.Data.String.Basic",
        "Init.Data.String.Modify"
      ]
    },
    "Init.Data.String.Legacy": {
      "path": "Init/Data/String/Legacy.olean",
      "imports": [
        "Init.Data.String.Basic"
      ]
    },
    "Init.Data.String.Lemmas.Basic": {
      "path": "Init/Data/String/Lemmas/Basic.olean",
      "imports": [
        "Init.Data.String.Basic"
      ]
    },
    "Init.Data.String.Lemmas.Modify": {
      "path": "Init/Data/String/Lemmas/Modify.olean",
      "imports": [
        "Init.Data.String.Modify",
        "all",
        "Init.Data.String.Lemmas.Basic"
      ]
    },
    "Init.Data.String.Lemmas.Search": {
      "path": "Init/Data/String/Lemmas/Search.olean",
      "imports": [
        "Init.Data.String.Search",
        "all"
      ]
    },
    "Init.Data.String.Lemmas.Splits": {
      "path": "Init/Data/String/Lemmas/Splits.olean",
      "imports": [
        "Init.Data.String.Basic",
        "Init.Data.ByteArray.Lemmas",
        "Init.Data.String.Lemmas.Basic"
      ]
    },
    "Init.Data.String.Lemmas": {
      "path": "Init/Data/String/Lemmas.olean",
      "imports": [
        "Init.Data.String.Lemmas.Splits",
        "Init.Data.String.Lemmas.Modify",
        "Init.Data.String.Lemmas.Search",
        "Init.Data.Char.Order",
        "Init.Data.Char.Lemmas",
        "Init.Data.List.Lex",
        "Init.Data.Order.Lemmas",
        "Init.Data.String.Basic"
      ]
    },
    "Init.Data.String.Modify": {
      "path": "Init/Data/String/Modify.olean",
      "imports": [
        "Init.Data.String.Basic",
        "Init.Data.String.Termination",
        "Init.Data.ByteArray.Lemmas",
        "Init.Data.Char.Lemmas"
      ]
    },
    "Init.Data.String.Pattern.Basic": {
      "path": "Init/Data/String/Pattern/Basic.olean",
      "imports": [
        "Init.Data.String.Basic",
        "Init.Data.Iterators.Basic"
      ]
    },
    "Init.Data.String.Pattern.Char": {
      "path": "Init/Data/String/Pattern/Char.olean",
      "imports": [
        "Init.Data.String.Pattern.Basic",
        "Init.Data.Iterators.Internal.Termination",
        "Init.Data.Iterators.Consumers.Monadic.Loop",
        "Init.Data.String.Termination"
      ]
    },
    "Init.Data.String.Pattern.Pred": {
      "path": "Init/Data/String/Pattern/Pred.olean",
      "imports": [
        "Init.Data.String.Pattern.Basic",
        "Init.Data.Iterators.Internal.Termination",
        "Init.Data.Iterators.Consumers.Monadic.Loop",
        "Init.Data.String.Termination"
      ]
    },
    "Init.Data.String.Pattern.String": {
      "path": "Init/Data/String/Pattern/String.olean",
      "imports": [
        "Init.Data.String.Pattern.Basic",
        "Init.Data.Iterators.Internal.Termination",
        "Init.Data.Iterators.Consumers.Monadic.Loop",
        "Init.Data.String.Termination",
        "Init.Data.Vector.Basic"
      ]
    },
    "Init.Data.String.Pattern": {
      "path": "Init/Data/String/Pattern.olean",
      "imports": [
        "Init.Data.String.Pattern.Basic",
        "Init.Data.String.Pattern.Char",
        "Init.Data.String.Pattern.String",
        "Init.Data.String.Pattern.Pred"
      ]
    },
    "Init.Data.String.PosRaw": {
      "path": "Init/Data/String/PosRaw.olean",
      "imports": [
        "Init.Data.String.Bootstrap",
        "Init.Data.ByteArray.Basic"
      ]
    },
    "Init.Data.String.Search": {
      "path": "Init/Data/String/Search.olean",
      "imports": [
        "Init.Data.String.Slice"
      ]
    },
    "Init.Data.String.Slice": {
      "path": "Init/Data/String/Slice.olean",
      "imports": [
        "Init.Data.String.Pattern",
        "Init.Data.Ord.Basic",
        "Init.Data.Iterators.Combinators.FilterMap",
        "Init.Data.String.ToSlice",
        "Init.Data.String.Termination"
      ]
    },
    "Init.Data.String.Stream": {
      "path": "Init/Data/String/Stream.olean",
      "imports": [
        "Init.Data.String.Basic",
        "Init.Data.Stream"
      ]
    },
    "Init.Data.String.Substring": {
      "path": "Init/Data/String/Substring.olean",
      "imports": [
        "Init.Data.String.Slice"
      ]
    },
    "Init.Data.String.TakeDrop": {
      "path": "Init/Data/String/TakeDrop.olean",
      "imports": [
        "Init.Data.String.Slice",
        "Init.Data.String.Substring"
      ]
    },
    "Init.Data.String.Termination": {
      "path": "Init/Data/String/Termination.olean",
      "imports": [
        "Init.Data.String.Basic",
        "Init.Data.String.Lemmas.Splits"
      ]
    },
    "Init.Data.String.ToSlice": {
      "path": "Init/Data/String/ToSlice.olean",
      "imports": [
        "Init.Data.String.Defs"
      ]
    },
    "Init.Data.String": {
      "path": "Init/Data/String.olean",
      "imports": [
        "Init.Data.String.Basic",
        "Init.Data.String.Bootstrap",
        "Init.Data.String.Decode",
        "Init.Data.String.Defs",
        "Init.Data.String.Extra",
        "Init.Data.String.Iterator",
        "Init.Data.String.Lemmas",
        "Init.Data.String.Bootstrap",
        "Init.Data.String.Slice",
        "Init.Data.String.Pattern",
        "Init.Data.String.Stream",
        "Init.Data.String.PosRaw",
        "Init.Data.String.Substring",
        "Init.Data.String.TakeDrop",
        "Init.Data.String.Modify",
        "Init.Data.String.Termination",
        "Init.Data.String.ToSlice",
        "Init.Data.String.Search",
        "Init.Data.String.Legacy",
        "Init.Data.String.Grind"
      ]
    },
    "Init.Data.Subtype.Basic": {
      "path": "Init/Data/Subtype/Basic.olean",
      "imports": [
        "Init.Ext"
      ]
    },
    "Init.Data.Subtype.Order": {
      "path": "Init/Data/Subtype/Order.olean",
      "imports": [
        "Init.Data.Order.Lemmas",
        "Init.Data.Order.Factories",
        "Init.Data.Subtype.Basic"
      ]
    },
    "Init.Data.Subtype.OrderExtra": {
      "path": "Init/Data/Subtype/OrderExtra.olean",
      "imports": [
        "Init.Data.Subtype.Order",
        "Init.Data.Ord.Basic"
      ]
    },
    "Init.Data.Subtype": {
      "path": "Init/Data/Subtype.olean",
      "imports": [
        "Init.Data.Subtype.Basic",
        "Init.Data.Subtype.Order",
        "Init.Data.Subtype.OrderExtra"
      ]
    },
    "Init.Data.Sum.Basic": {
      "path": "Init/Data/Sum/Basic.olean",
      "imports": [
        "Init.PropLemmas"
      ]
    },
    "Init.Data.Sum.Lemmas": {
      "path": "Init/Data/Sum/Lemmas.olean",
      "imports": [
        "Init.Data.Sum.Basic",
        "all",
        "Init.Ext"
      ]
    },
    "Init.Data.Sum": {
      "path": "Init/Data/Sum.olean",
      "imports": [
        "Init.Data.Sum.Basic",
        "Init.Data.Sum.Lemmas"
      ]
    },
    "Init.Data.ToString.Basic": {
      "path": "Init/Data/ToString/Basic.olean",
      "imports": [
        "Init.Data.Repr",
        "Init.Data.Option.Basic"
      ]
    },
    "Init.Data.ToString.Macro": {
      "path": "Init/Data/ToString/Macro.olean",
      "imports": [
        "Init.Meta"
      ]
    },
    "Init.Data.ToString.Name": {
      "path": "Init/Data/ToString/Name.olean",
      "imports": [
        "Init.Data.String.Substring",
        "Init.Data.String.TakeDrop",
        "Init.Data.String.Search"
      ]
    },
    "Init.Data.ToString": {
      "path": "Init/Data/ToString.olean",
      "imports": [
        "Init.Data.ToString.Basic",
        "Init.Data.ToString.Macro",
        "Init.Data.ToString.Name"
      ]
    },
    "Init.Data.UInt.Basic": {
      "path": "Init/Data/UInt/Basic.olean",
      "imports": [
        "Init.Data.BitVec.Basic",
        "Init.Data.Order.Factories"
      ]
    },
    "Init.Data.UInt.BasicAux": {
      "path": "Init/Data/UInt/BasicAux.olean",
      "imports": [
        "Init.Data.BitVec.BasicAux"
      ]
    },
    "Init.Data.UInt.Bitwise": {
      "path": "Init/Data/UInt/Bitwise.olean",
      "imports": [
        "all",
        "all",
        "Init.Data.UInt.Lemmas"
      ]
    },
    "Init.Data.UInt.Lemmas": {
      "path": "Init/Data/UInt/Lemmas.olean",
      "imports": [
        "Init.Data.UInt.Basic",
        "all",
        "all",
        "Init.Data.Fin.Bitwise",
        "all",
        "all",
        "all",
        "Init.Data.BitVec.Lemmas",
        "Init.System.Platform",
        "Init.Data.Order.Lemmas"
      ]
    },
    "Init.Data.UInt.Log2": {
      "path": "Init/Data/UInt/Log2.olean",
      "imports": [
        "Init.Data.Fin.Log2"
      ]
    },
    "Init.Data.UInt": {
      "path": "Init/Data/UInt.olean",
      "imports": [
        "Init.Data.UInt.BasicAux",
        "Init.Data.UInt.Basic",
        "Init.Data.UInt.Log2",
        "Init.Data.UInt.Lemmas",
        "Init.Data.UInt.Bitwise"
      ]
    },
    "Init.Data.ULift": {
      "path": "Init/Data/ULift.olean",
      "imports": [
        "Init.Core"
      ]
    },
    "Init.Data.Vector.Algebra": {
      "path": "Init/Data/Vector/Algebra.olean",
      "imports": [
        "Init.Data.Vector.Lemmas",
        "Init.Grind"
      ]
    },
    "Init.Data.Vector.Attach": {
      "path": "Init/Data/Vector/Attach.olean",
      "imports": [
        "Init.Data.Vector.Lemmas",
        "all"
      ]
    },
    "Init.Data.Vector.Basic": {
      "path": "Init/Data/Vector/Basic.olean",
      "imports": [
        "Init.Data.Array.InsertIdx",
        "Init.Data.Array.Range",
        "Init.Data.Range",
        "Init.Data.Slice.Array.Iterator"
      ]
    },
    "Init.Data.Vector.Count": {
      "path": "Init/Data/Vector/Count.olean",
      "imports": [
        "all",
        "all",
        "Init.Data.Vector.Lemmas"
      ]
    },
    "Init.Data.Vector.DecidableEq": {
      "path": "Init/Data/Vector/DecidableEq.olean",
      "imports": [
        "Init.Data.Vector.Lemmas"
      ]
    },
    "Init.Data.Vector.Erase": {
      "path": "Init/Data/Vector/Erase.olean",
      "imports": [
        "Init.Data.Vector.Lemmas",
        "Init.Data.Array.Erase"
      ]
    },
    "Init.Data.Vector.Extract": {
      "path": "Init/Data/Vector/Extract.olean",
      "imports": [
        "Init.Data.Vector.Lemmas",
        "Init.Data.Array.Extract"
      ]
    },
    "Init.Data.Vector.FinRange": {
      "path": "Init/Data/Vector/FinRange.olean",
      "imports": [
        "Init.Data.Array.FinRange",
        "Init.Data.Vector.OfFn"
      ]
    },
    "Init.Data.Vector.Find": {
      "path": "Init/Data/Vector/Find.olean",
      "imports": [
        "all",
        "all",
        "Init.Data.Vector.Range"
      ]
    },
    "Init.Data.Vector.InsertIdx": {
      "path": "Init/Data/Vector/InsertIdx.olean",
      "imports": [
        "Init.Data.Vector.Lemmas"
      ]
    },
    "Init.Data.Vector.Lemmas": {
      "path": "Init/Data/Vector/Lemmas.olean",
      "imports": [
        "all",
        "Init.Data.Vector.Basic",
        "all",
        "Init.Data.Array.Find"
      ]
    },
    "Init.Data.Vector.Lex": {
      "path": "Init/Data/Vector/Lex.olean",
      "imports": [
        "all",
        "Init.Data.Vector.Lemmas",
        "all",
        "Init.Data.Array.Lex.Lemmas",
        "Init.Data.Range.Polymorphic.Lemmas"
      ]
    },
    "Init.Data.Vector.MapIdx": {
      "path": "Init/Data/Vector/MapIdx.olean",
      "imports": [
        "all",
        "all",
        "Init.Data.Vector.Attach"
      ]
    },
    "Init.Data.Vector.Monadic": {
      "path": "Init/Data/Vector/Monadic.olean",
      "imports": [
        "all",
        "Init.Data.Vector.Attach"
      ]
    },
    "Init.Data.Vector.OfFn": {
      "path": "Init/Data/Vector/OfFn.olean",
      "imports": [
        "all",
        "Init.Data.Vector.Monadic"
      ]
    },
    "Init.Data.Vector.Perm": {
      "path": "Init/Data/Vector/Perm.olean",
      "imports": [
        "all",
        "Init.Data.Array.Perm",
        "all",
        "Init.Data.Vector.Lemmas"
      ]
    },
    "Init.Data.Vector.Range": {
      "path": "Init/Data/Vector/Range.olean",
      "imports": [
        "all",
        "all",
        "Init.Data.Vector.Zip",
        "Init.Data.Vector.MapIdx"
      ]
    },
    "Init.Data.Vector.Stream": {
      "path": "Init/Data/Vector/Stream.olean",
      "imports": [
        "Init.Data.Stream",
        "Init.Data.Vector.Basic"
      ]
    },
    "Init.Data.Vector.Zip": {
      "path": "Init/Data/Vector/Zip.olean",
      "imports": [
        "all",
        "all",
        "Init.Data.Vector.Lemmas"
      ]
    },
    "Init.Data.Vector": {
      "path": "Init/Data/Vector.olean",
      "imports": [
        "Init.Data.Vector.Basic",
        "Init.Data.Vector.Lemmas",
        "Init.Data.Vector.Lex",
        "Init.Data.Vector.MapIdx",
        "Init.Data.Vector.Count",
        "Init.Data.Vector.DecidableEq",
        "Init.Data.Vector.Zip",
        "Init.Data.Vector.OfFn",
        "Init.Data.Vector.Range",
        "Init.Data.Vector.Erase",
        "Init.Data.Vector.Monadic",
        "Init.Data.Vector.InsertIdx",
        "Init.Data.Vector.FinRange",
        "Init.Data.Vector.Extract",
        "Init.Data.Vector.Perm",
        "Init.Data.Vector.Find",
        "Init.Data.Vector.Algebra",
        "Init.Data.Vector.Stream"
      ]
    },
    "Init.Data.Zero": {
      "path": "Init/Data/Zero.olean",
      "imports": [
        "Init.Core"
      ]
    },
    "Init.Data": {
      "path": "Init/Data.olean",
      "imports": [
        "Init.Data.Nat",
        "Init.Data.Bool",
        "Init.Data.BitVec",
        "Init.Data.Cast",
        "Init.Data.Char",
        "Init.Data.String",
        "Init.Data.List",
        "Init.Data.Int",
        "Init.Data.Array",
        "Init.Data.Array.Subarray.Split",
        "Init.Data.ByteArray",
        "Init.Data.FloatArray",
        "Init.Data.Fin",
        "Init.Data.UInt",
        "Init.Data.SInt",
        "Init.Data.Float",
        "Init.Data.Float32",
        "Init.Data.Option",
        "Init.Data.Ord",
        "Init.Data.Random",
        "Init.Data.ToString",
        "Init.Data.Range",
        "Init.Data.Hashable",
        "Init.Data.LawfulHashable",
        "Init.Data.OfScientific",
        "Init.Data.Format",
        "Init.Data.Stream",
        "Init.Data.Prod",
        "Init.Data.AC",
        "Init.Data.Queue",
        "Init.Data.Sum",
        "Init.Data.BEq",
        "Init.Data.Subtype",
        "Init.Data.ULift",
        "Init.Data.PLift",
        "Init.Data.Zero",
        "Init.Data.NeZero",
        "Init.Data.Function",
        "Init.Data.RArray",
        "Init.Data.Vector",
        "Init.Data.Iterators",
        "Init.Data.Range.Polymorphic",
        "Init.Data.Slice",
        "Init.Data.Order",
        "Init.Data.Rat",
        "Init.Data.Dyadic"
      ]
    },
    "Init.Dynamic": {
      "path": "Init/Dynamic.olean",
      "imports": [
        "Init.Core"
      ]
    },
    "Init.Ext": {
      "path": "Init/Ext.olean",
      "imports": [
        "Init.Data.ToString.Macro",
        "Init.TacticsExtra",
        "Init.RCases"
      ]
    },
    "Init.GetElem": {
      "path": "Init/GetElem.olean",
      "imports": [
        "Init.Util"
      ]
    },
    "Init.Grind.AC": {
      "path": "Init/Grind/AC.olean",
      "imports": [
        "Init.Data.Nat.Lemmas",
        "Init.Data.Bool",
        "Init.LawfulBEqTactics"
      ]
    },
    "Init.Grind.Annotated": {
      "path": "Init/Grind/Annotated.olean",
      "imports": [
        "Init.Tactics"
      ]
    },
    "Init.Grind.Attr": {
      "path": "Init/Grind/Attr.olean",
      "imports": [
        "Init.Tactics"
      ]
    },
    "Init.Grind.Cases": {
      "path": "Init/Grind/Cases.olean",
      "imports": [
        "Init.Grind.Tactics"
      ]
    },
    "Init.Grind.Config": {
      "path": "Init/Grind/Config.olean",
      "imports": [
        "Init.Core"
      ]
    },
    "Init.Grind.Ext": {
      "path": "Init/Grind/Ext.olean",
      "imports": [
        "Init.Ext"
      ]
    },
    "Init.Grind.FieldNormNum": {
      "path": "Init/Grind/FieldNormNum.olean",
      "imports": [
        "Init.Grind.Ring.Field",
        "Init.Data.Rat.Basic",
        "Init.Data.Rat.Lemmas"
      ]
    },
    "Init.Grind.Injective": {
      "path": "Init/Grind/Injective.olean",
      "imports": [
        "Init.Data.Function",
        "Init.Classical"
      ]
    },
    "Init.Grind.Interactive": {
      "path": "Init/Grind/Interactive.olean",
      "imports": [
        "Init.Grind.Attr"
      ]
    },
    "Init.Grind.Lemmas": {
      "path": "Init/Grind/Lemmas.olean",
      "imports": [
        "Init.ByCases",
        "Init.Grind.Util",
        "Init.Grind.Ring.Basic"
      ]
    },
    "Init.Grind.Lint": {
      "path": "Init/Grind/Lint.olean",
      "imports": [
        "Init.Grind.Interactive",
        "Init.Grind.Config"
      ]
    },
    "Init.Grind.Module.Basic": {
      "path": "Init/Grind/Module/Basic.olean",
      "imports": [
        "Init.Grind.ToInt",
        "all"
      ]
    },
    "Init.Grind.Module.Envelope": {
      "path": "Init/Grind/Module/Envelope.olean",
      "imports": [
        "Init.Grind.Ordered.Module",
        "Init.Data.AC",
        "all"
      ]
    },
    "Init.Grind.Module.NatModuleNorm": {
      "path": "Init/Grind/Module/NatModuleNorm.olean",
      "imports": [
        "Init.Grind.Module.Envelope",
        "Init.Grind.Ordered.Linarith"
      ]
    },
    "Init.Grind.Module.OfNatModule": {
      "path": "Init/Grind/Module/OfNatModule.olean",
      "imports": [
        "Init.Grind.Module.Envelope"
      ]
    },
    "Init.Grind.Module": {
      "path": "Init/Grind/Module.olean",
      "imports": [
        "Init.Grind.Module.Basic",
        "Init.Grind.Module.Envelope",
        "Init.Grind.Module.OfNatModule",
        "Init.Grind.Module.NatModuleNorm"
      ]
    },
    "Init.Grind.Norm": {
      "path": "Init/Grind/Norm.olean",
      "imports": [
        "Init.Data.Int.Linear",
        "Init.Grind.Ring.Field",
        "Init.Data.Rat.Lemmas",
        "Init.Grind.Ring.OfScientific"
      ]
    },
    "Init.Grind.Offset": {
      "path": "Init/Grind/Offset.olean",
      "imports": [
        "Init.Omega"
      ]
    },
    "Init.Grind.Order": {
      "path": "Init/Grind/Order.olean",
      "imports": [
        "Init.Grind.Ordered.Ring",
        "Init.Grind.Ring"
      ]
    },
    "Init.Grind.Ordered.Field": {
      "path": "Init/Grind/Ordered/Field.olean",
      "imports": [
        "Init.Grind.Ring.Field",
        "Init.Grind.Ordered.Ring"
      ]
    },
    "Init.Grind.Ordered.Int": {
      "path": "Init/Grind/Ordered/Int.olean",
      "imports": [
        "Init.Grind.Ordered.Ring",
        "Init.GrindInstances.Ring.Int"
      ]
    },
    "Init.Grind.Ordered.Linarith": {
      "path": "Init/Grind/Ordered/Linarith.olean",
      "imports": [
        "Init.Grind.Ordered.Ring",
        "Init.Grind.Ring.Field",
        "Init.Data.Ord.Basic",
        "all",
        "Init.Data.AC",
        "all",
        "Init.LawfulBEqTactics"
      ]
    },
    "Init.Grind.Ordered.Module": {
      "path": "Init/Grind/Ordered/Module.olean",
      "imports": [
        "Init.Grind.Module.Basic",
        "Init.Grind.Ordered.Order"
      ]
    },
    "Init.Grind.Ordered.Order": {
      "path": "Init/Grind/Ordered/Order.olean",
      "imports": [
        "Init.Data.Int.Order",
        "Init.Data.Order.Lemmas"
      ]
    },
    "Init.Grind.Ordered.Rat": {
      "path": "Init/Grind/Ordered/Rat.olean",
      "imports": [
        "Init.Grind.Ordered.Ring",
        "Init.GrindInstances.Ring.Rat"
      ]
    },
    "Init.Grind.Ordered.Ring": {
      "path": "Init/Grind/Ordered/Ring.olean",
      "imports": [
        "Init.Grind.Ring.Basic",
        "Init.Grind.Ordered.Module"
      ]
    },
    "Init.Grind.Ordered": {
      "path": "Init/Grind/Ordered.olean",
      "imports": [
        "Init.Grind.Ordered.Order",
        "Init.Grind.Ordered.Module",
        "Init.Grind.Ordered.Ring",
        "Init.Grind.Ordered.Field",
        "Init.Grind.Ordered.Int",
        "Init.Grind.Ordered.Rat",
        "Init.Grind.Ordered.Linarith"
      ]
    },
    "Init.Grind.PP": {
      "path": "Init/Grind/PP.olean",
      "imports": [
        "Init.NotationExtra",
        "Init.Data.String.Basic"
      ]
    },
    "Init.Grind.Propagator": {
      "path": "Init/Grind/Propagator.olean",
      "imports": [
        "Init.NotationExtra"
      ]
    },
    "Init.Grind.Ring.Basic": {
      "path": "Init/Grind/Ring/Basic.olean",
      "imports": [
        "Init.Data.Int.LemmasAux",
        "Init.TacticsExtra",
        "Init.Grind.Module.Basic"
      ]
    },
    "Init.Grind.Ring.CommSemiringAdapter": {
      "path": "Init/Grind/Ring/CommSemiringAdapter.olean",
      "imports": [
        "Init.Grind.Ring.Envelope",
        "Init.Grind.Ring.CommSolver"
      ]
    },
    "Init.Grind.Ring.CommSolver": {
      "path": "Init/Grind/Ring/CommSolver.olean",
      "imports": [
        "Init.Data.Hashable",
        "Init.Data.Ord.Basic",
        "Init.Grind.Ring.Field",
        "Init.Grind.Ordered.Ring",
        "Init.GrindInstances.Ring.Int",
        "all",
        "Init.LawfulBEqTactics"
      ]
    },
    "Init.Grind.Ring.Envelope": {
      "path": "Init/Grind/Ring/Envelope.olean",
      "imports": [
        "Init.Grind.Ordered.Ring",
        "Init.Data.AC",
        "all"
      ]
    },
    "Init.Grind.Ring.Field": {
      "path": "Init/Grind/Ring/Field.olean",
      "imports": [
        "Init.Grind.Ring.Basic"
      ]
    },
    "Init.Grind.Ring.OfScientific": {
      "path": "Init/Grind/Ring/OfScientific.olean",
      "imports": [
        "Init.Grind.Ring.Field",
        "Init.Data.OfScientific"
      ]
    },
    "Init.Grind.Ring.ToInt": {
      "path": "Init/Grind/Ring/ToInt.olean",
      "imports": [
        "Init.Grind.Ring.Basic"
      ]
    },
    "Init.Grind.Ring": {
      "path": "Init/Grind/Ring.olean",
      "imports": [
        "Init.Grind.Ring.Basic",
        "Init.Grind.Ring.Field",
        "Init.Grind.Ring.OfScientific",
        "Init.Grind.Ring.Envelope",
        "Init.Grind.Ring.CommSolver",
        "Init.Grind.Ring.CommSemiringAdapter",
        "Init.Grind.Ring.ToInt"
      ]
    },
    "Init.Grind.Tactics": {
      "path": "Init/Grind/Tactics.olean",
      "imports": [
        "Init.Core",
        "Init.Grind.Interactive",
        "Init.Grind.Config"
      ]
    },
    "Init.Grind.ToInt": {
      "path": "Init/Grind/ToInt.olean",
      "imports": [
        "Init.Data.Int.DivMod.Lemmas",
        "Init.LawfulBEqTactics"
      ]
    },
    "Init.Grind.ToIntLemmas": {
      "path": "Init/Grind/ToIntLemmas.olean",
      "imports": [
        "Init.Grind.ToInt",
        "all"
      ]
    },
    "Init.Grind.Util": {
      "path": "Init/Grind/Util.olean",
      "imports": [
        "Init.Classical"
      ]
    },
    "Init.Grind": {
      "path": "Init/Grind.olean",
      "imports": [
        "Init.Grind.Norm",
        "Init.Grind.Tactics",
        "Init.Grind.Lemmas",
        "Init.Grind.Cases",
        "Init.Grind.Propagator",
        "Init.Grind.Util",
        "Init.Grind.Offset",
        "Init.Grind.PP",
        "Init.Grind.Ring",
        "Init.Grind.Module",
        "Init.Grind.Ordered",
        "Init.Grind.Ext",
        "Init.Grind.ToInt",
        "Init.Grind.ToIntLemmas",
        "Init.Grind.Attr",
        "Init.Data.Int.OfNat",
        "Init.Grind.AC",
        "Init.Grind.Injective",
        "Init.Grind.Order",
        "Init.Grind.Interactive",
        "Init.Grind.Lint",
        "Init.Grind.Annotated",
        "Init.Grind.FieldNormNum"
      ]
    },
    "Init.GrindInstances.Nat": {
      "path": "Init/GrindInstances/Nat.olean",
      "imports": [
        "Init.Grind.Ordered.Module",
        "Init.Grind.Ring.Basic"
      ]
    },
    "Init.GrindInstances.Ring.BitVec": {
      "path": "Init/GrindInstances/Ring/BitVec.olean",
      "imports": [
        "Init.Grind.Ordered.Order",
        "Init.GrindInstances.ToInt",
        "all",
        "all"
      ]
    },
    "Init.GrindInstances.Ring.Fin": {
      "path": "Init/GrindInstances/Ring/Fin.olean",
      "imports": [
        "all",
        "Init.GrindInstances.ToInt",
        "all"
      ]
    },
    "Init.GrindInstances.Ring.Int": {
      "path": "Init/GrindInstances/Ring/Int.olean",
      "imports": [
        "Init.Grind.Ring.Basic"
      ]
    },
    "Init.GrindInstances.Ring.Nat": {
      "path": "Init/GrindInstances/Ring/Nat.olean",
      "imports": [
        "Init.Grind.Ordered.Ring"
      ]
    },
    "Init.GrindInstances.Ring.Rat": {
      "path": "Init/GrindInstances/Ring/Rat.olean",
      "imports": [
        "Init.Grind.Ring.OfScientific",
        "Init.Data.Rat.Lemmas"
      ]
    },
    "Init.GrindInstances.Ring.SInt": {
      "path": "Init/GrindInstances/Ring/SInt.olean",
      "imports": [
        "all",
        "Init.GrindInstances.ToInt",
        "all",
        "all"
      ]
    },
    "Init.GrindInstances.Ring.UInt": {
      "path": "Init/GrindInstances/Ring/UInt.olean",
      "imports": [
        "Init.GrindInstances.ToInt",
        "all",
        "all"
      ]
    },
    "Init.GrindInstances.Ring": {
      "path": "Init/GrindInstances/Ring.olean",
      "imports": [
        "Init.GrindInstances.Ring.Nat",
        "Init.GrindInstances.Ring.Int",
        "Init.GrindInstances.Ring.UInt",
        "Init.GrindInstances.Ring.SInt",
        "Init.GrindInstances.Ring.Fin",
        "Init.GrindInstances.Ring.BitVec",
        "Init.GrindInstances.Ring.Rat"
      ]
    },
    "Init.GrindInstances.ToInt": {
      "path": "Init/GrindInstances/ToInt.olean",
      "imports": [
        "all",
        "Init.Grind.Ring.ToInt",
        "Init.Data.SInt.Lemmas"
      ]
    },
    "Init.GrindInstances": {
      "path": "Init/GrindInstances.olean",
      "imports": [
        "Init.GrindInstances.ToInt",
        "Init.GrindInstances.Ring",
        "Init.GrindInstances.Nat"
      ]
    },
    "Init.Guard": {
      "path": "Init/Guard.olean",
      "imports": [
        "Init.NotationExtra"
      ]
    },
    "Init.Hints": {
      "path": "Init/Hints.olean",
      "imports": [
        "Init.NotationExtra"
      ]
    },
    "Init.Internal.Order.Basic": {
      "path": "Init/Internal/Order/Basic.olean",
      "imports": [
        "Init.System.IO",
        "all",
        "all",
        "all",
        "all"
      ]
    },
    "Init.Internal.Order.Lemmas": {
      "path": "Init/Internal/Order/Lemmas.olean",
      "imports": [
        "all",
        "all",
        "all",
        "Init.Internal.Order.Basic"
      ]
    },
    "Init.Internal.Order.Tactic": {
      "path": "Init/Internal/Order/Tactic.olean",
      "imports": [
        "Init.Notation"
      ]
    },
    "Init.Internal.Order": {
      "path": "Init/Internal/Order.olean",
      "imports": [
        "Init.Internal.Order.Basic",
        "Init.Internal.Order.Lemmas",
        "Init.Internal.Order.Tactic"
      ]
    },
    "Init.Internal": {
      "path": "Init/Internal.olean",
      "imports": [
        "Init.Internal.Order"
      ]
    },
    "Init.LawfulBEqTactics": {
      "path": "Init/LawfulBEqTactics.olean",
      "imports": [
        "Init.Core",
        "Init.Data.Bool",
        "Init.ByCases"
      ]
    },
    "Init.MacroTrace": {
      "path": "Init/MacroTrace.olean",
      "imports": [
        "Init.Data.ToString.Macro",
        "Init.Meta"
      ]
    },
    "Init.Meta.Defs": {
      "path": "Init/Meta/Defs.olean",
      "imports": [
        "all",
        "Init.Syntax",
        "Init.Data.Array.GetLit",
        "Init.Data.Option.BasicAux",
        "Init.Data.Array.Basic",
        "Init.Syntax"
      ]
    },
    "Init.Meta": {
      "path": "Init/Meta.olean",
      "imports": [
        "Init.Meta.Defs",
        "Init.Meta.Defs"
      ]
    },
    "Init.MetaTypes": {
      "path": "Init/MetaTypes.olean",
      "imports": [
        "Init.Core"
      ]
    },
    "Init.MethodSpecsSimp": {
      "path": "Init/MethodSpecsSimp.olean",
      "imports": [
        "Init.Prelude"
      ]
    },
    "Init.Notation": {
      "path": "Init/Notation.olean",
      "imports": [
        "Init.Coe"
      ]
    },
    "Init.NotationExtra": {
      "path": "Init/NotationExtra.olean",
      "imports": [
        "Init.Conv",
        "Init.Meta",
        "Init.While"
      ]
    },
    "Init.Omega.Coeffs": {
      "path": "Init/Omega/Coeffs.olean",
      "imports": [
        "Init.Omega.IntList",
        "all"
      ]
    },
    "Init.Omega.Constraint": {
      "path": "Init/Omega/Constraint.olean",
      "imports": [
        "Init.Omega.LinearCombo",
        "Init.Omega.Int"
      ]
    },
    "Init.Omega.Int": {
      "path": "Init/Omega/Int.olean",
      "imports": [
        "Init.Data.Int.DivMod.Bootstrap"
      ]
    },
    "Init.Omega.IntList": {
      "path": "Init/Omega/IntList.olean",
      "imports": [
        "Init.Data.Int.DivMod.Bootstrap",
        "Init.Data.Nat.Gcd"
      ]
    },
    "Init.Omega.LinearCombo": {
      "path": "Init/Omega/LinearCombo.olean",
      "imports": [
        "Init.Omega.Coeffs",
        "Init.Data.ToString.Macro"
      ]
    },
    "Init.Omega.Logic": {
      "path": "Init/Omega/Logic.olean",
      "imports": [
        "Init.PropLemmas"
      ]
    },
    "Init.Omega": {
      "path": "Init/Omega.olean",
      "imports": [
        "Init.Omega.Int",
        "Init.Omega.IntList",
        "Init.Omega.LinearCombo",
        "Init.Omega.Constraint",
        "Init.Omega.Logic"
      ]
    },
    "Init.Prelude": {
      "path": "Init/Prelude.olean",
      "imports": []
    },
    "Init.PropLemmas": {
      "path": "Init/PropLemmas.olean",
      "imports": [
        "Init.NotationExtra"
      ]
    },
    "Init.RCases": {
      "path": "Init/RCases.olean",
      "imports": [
        "Init.Meta"
      ]
    },
    "Init.ShareCommon": {
      "path": "Init/ShareCommon.olean",
      "imports": [
        "Init.Data.UInt.Basic"
      ]
    },
    "Init.SimpLemmas": {
      "path": "Init/SimpLemmas.olean",
      "imports": [
        "Init.Core"
      ]
    },
    "Init.Simproc": {
      "path": "Init/Simproc.olean",
      "imports": [
        "Init.NotationExtra",
        "Init.Data.ToString.Name"
      ]
    },
    "Init.SizeOf": {
      "path": "Init/SizeOf.olean",
      "imports": [
        "Init.Tactics"
      ]
    },
    "Init.SizeOfLemmas": {
      "path": "Init/SizeOfLemmas.olean",
      "imports": [
        "all",
        "all",
        "Init.Data.Nat.Linear"
      ]
    },
    "Init.Syntax": {
      "path": "Init/Syntax.olean",
      "imports": [
        "Init.Data.Array.Set"
      ]
    },
    "Init.System.FilePath": {
      "path": "Init/System/FilePath.olean",
      "imports": [
        "Init.Data.String.Basic",
        "Init.Data.String.Modify",
        "Init.Data.String.Search"
      ]
    },
    "Init.System.IO": {
      "path": "Init/System/IO.olean",
      "imports": [
        "Init.System.IOError",
        "Init.System.FilePath",
        "Init.Data.Ord.UInt",
        "Init.Data.String.TakeDrop",
        "Init.Data.String.Search"
      ]
    },
    "Init.System.IOError": {
      "path": "Init/System/IOError.olean",
      "imports": [
        "Init.Data.ToString.Basic",
        "Init.Data.String.Modify"
      ]
    },
    "Init.System.Platform": {
      "path": "Init/System/Platform.olean",
      "imports": [
        "Init.Data.String.Bootstrap"
      ]
    },
    "Init.System.Promise": {
      "path": "Init/System/Promise.olean",
      "imports": [
        "Init.System.IO"
      ]
    },
    "Init.System.ST": {
      "path": "Init/System/ST.olean",
      "imports": [
        "Init.Classical",
        "Init.Control.EState",
        "Init.Control.Reader"
      ]
    },
    "Init.System.Uri": {
      "path": "Init/System/Uri.olean",
      "imports": [
        "Init.System.FilePath",
        "Init.Data.String.TakeDrop",
        "Init.Data.String.Modify",
        "Init.Data.String.Search"
      ]
    },
    "Init.System": {
      "path": "Init/System.olean",
      "imports": [
        "Init.System.IO",
        "Init.System.Platform",
        "Init.System.Uri",
        "Init.System.Promise"
      ]
    },
    "Init.Tactics": {
      "path": "Init/Tactics.olean",
      "imports": [
        "Init.Notation"
      ]
    },
    "Init.TacticsExtra": {
      "path": "Init/TacticsExtra.olean",
      "imports": [
        "Init.NotationExtra"
      ]
    },
    "Init.Task": {
      "path": "Init/Task.olean",
      "imports": [
        "Init.System.Promise"
      ]
    },
    "Init.Try": {
      "path": "Init/Try.olean",
      "imports": [
        "Init.Tactics"
      ]
    },
    "Init.Util": {
      "path": "Init/Util.olean",
      "imports": [
        "Init.Data.ToString.Basic"
      ]
    },
    "Init.WF": {
      "path": "Init/WF.olean",
      "imports": [
        "Init.BinderNameHint",
        "Init.Data.Nat.Basic"
      ]
    },
    "Init.WFComputable": {
      "path": "Init/WFComputable.olean",
      "imports": [
        "Init.WF",
        "Init.NotationExtra"
      ]
    },
    "Init.WFExtrinsicFix": {
      "path": "Init/WFExtrinsicFix.olean",
      "imports": [
        "Init.WF",
        "Init.Classical",
        "Init.Ext",
        "Init.NotationExtra"
      ]
    },
    "Init.WFTactics": {
      "path": "Init/WFTactics.olean",
      "imports": [
        "Init.MetaTypes",
        "Init.WF"
      ]
    },
    "Init.While": {
      "path": "Init/While.olean",
      "imports": [
        "Init.Core"
      ]
    },
    "Init": {
      "path": "Init.olean",
      "imports": [
        "Init.Prelude",
        "Init.Notation",
        "Init.Tactics",
        "Init.TacticsExtra",
        "Init.ByCases",
        "Init.RCases",
        "Init.Core",
        "Init.Control",
        "Init.WF",
        "Init.WFComputable",
        "Init.WFTactics",
        "Init.Data",
        "Init.System",
        "Init.Util",
        "Init.Dynamic",
        "Init.ShareCommon",
        "Init.MetaTypes",
        "Init.Meta",
        "Init.NotationExtra",
        "Init.SimpLemmas",
        "Init.PropLemmas",
        "Init.Hints",
        "Init.Conv",
        "Init.Guard",
        "Init.Simproc",
        "Init.SizeOfLemmas",
        "Init.BinderPredicates",
        "Init.Ext",
        "Init.Omega",
        "Init.MacroTrace",
        "Init.Grind",
        "Init.GrindInstances",
        "Init.While",
        "Init.Syntax",
        "Init.Internal",
        "Init.Try",
        "Init.Try",
        "Init.BinderNameHint",
        "Init.Task",
        "Init.MethodSpecsSimp",
        "Init.LawfulBEqTactics"
      ]
    },
    "Lean.AddDecl": {
      "path": "Lean/AddDecl.olean",
      "imports": [
        "Lean.Meta.Sorry",
        "Lean.Util.CollectAxioms"
      ]
    },
    "Lean.Attributes": {
      "path": "Lean/Attributes.olean",
      "imports": [
        "Lean.CoreM",
        "Lean.Compiler.MetaAttr"
      ]
    },
    "Lean.AuxRecursor": {
      "path": "Lean/AuxRecursor.olean",
      "imports": [
        "Lean.EnvExtension",
        "Init.Data.String.TakeDrop"
      ]
    },
    "Lean.BuiltinDocAttr": {
      "path": "Lean/BuiltinDocAttr.olean",
      "imports": [
        "Lean.Compiler.InitAttr"
      ]
    },
    "Lean.Class": {
      "path": "Lean/Class.olean",
      "imports": [
        "Lean.Attributes"
      ]
    },
    "Lean.Compiler.BorrowedAnnotation": {
      "path": "Lean/Compiler/BorrowedAnnotation.olean",
      "imports": [
        "Lean.Expr"
      ]
    },
    "Lean.Compiler.CSimpAttr": {
      "path": "Lean/Compiler/CSimpAttr.olean",
      "imports": [
        "Lean.ScopedEnvExtension",
        "Lean.Util.Recognizers"
      ]
    },
    "Lean.Compiler.ClosedTermCache": {
      "path": "Lean/Compiler/ClosedTermCache.olean",
      "imports": [
        "Lean.Environment"
      ]
    },
    "Lean.Compiler.ExportAttr": {
      "path": "Lean/Compiler/ExportAttr.olean",
      "imports": [
        "Lean.Attributes"
      ]
    },
    "Lean.Compiler.ExternAttr": {
      "path": "Lean/Compiler/ExternAttr.olean",
      "imports": [
        "Lean.ProjFns",
        "Lean.Attributes"
      ]
    },
    "Lean.Compiler.FFI": {
      "path": "Lean/Compiler/FFI.olean",
      "imports": [
        "Init.System.FilePath",
        "Init.Data.String.Search"
      ]
    },
    "Lean.Compiler.IR.AddExtern": {
      "path": "Lean/Compiler/IR/AddExtern.olean",
      "imports": [
        "Lean.Compiler.IR.Boxing",
        "Lean.Compiler.IR.RC"
      ]
    },
    "Lean.Compiler.IR.Basic": {
      "path": "Lean/Compiler/IR/Basic.olean",
      "imports": [
        "Lean.Compiler.ExternAttr"
      ]
    },
    "Lean.Compiler.IR.Borrow": {
      "path": "Lean/Compiler/IR/Borrow.olean",
      "imports": [
        "Lean.Compiler.IR.CompilerM",
        "Lean.Compiler.IR.NormIds"
      ]
    },
    "Lean.Compiler.IR.Boxing": {
      "path": "Lean/Compiler/IR/Boxing.olean",
      "imports": [
        "Lean.Runtime",
        "Lean.Compiler.ClosedTermCache",
        "Lean.Compiler.IR.CompilerM",
        "Lean.Compiler.IR.ElimDeadVars",
        "Lean.Compiler.IR.ToIRType",
        "Lean.Data.AssocList"
      ]
    },
    "Lean.Compiler.IR.Checker": {
      "path": "Lean/Compiler/IR/Checker.olean",
      "imports": [
        "Lean.Compiler.IR.CompilerM"
      ]
    },
    "Lean.Compiler.IR.CompilerM": {
      "path": "Lean/Compiler/IR/CompilerM.olean",
      "imports": [
        "Lean.Compiler.IR.Format",
        "Lean.Compiler.ExportAttr",
        "Lean.Compiler.LCNF.PhaseExt",
        "Lean.Compiler.InitAttr"
      ]
    },
    "Lean.Compiler.IR.ElimDeadVars": {
      "path": "Lean/Compiler/IR/ElimDeadVars.olean",
      "imports": [
        "Lean.Compiler.IR.FreeVars"
      ]
    },
    "Lean.Compiler.IR.EmitC": {
      "path": "Lean/Compiler/IR/EmitC.olean",
      "imports": [
        "Lean.Compiler.NameMangling",
        "Lean.Compiler.IR.EmitUtil",
        "Lean.Compiler.IR.NormIds",
        "Lean.Compiler.IR.SimpCase",
        "Lean.Compiler.IR.Boxing",
        "Lean.Compiler.ModPkgExt"
      ]
    },
    "Lean.Compiler.IR.EmitLLVM": {
      "path": "Lean/Compiler/IR/EmitLLVM.olean",
      "imports": [
        "Lean.Compiler.NameMangling",
        "Lean.Compiler.IR.EmitUtil",
        "Lean.Compiler.IR.NormIds",
        "Lean.Compiler.IR.SimpCase",
        "Lean.Compiler.IR.Boxing",
        "Lean.Compiler.IR.ResetReuse",
        "Lean.Compiler.IR.LLVMBindings",
        "Lean.Compiler.ModPkgExt"
      ]
    },
    "Lean.Compiler.IR.EmitUtil": {
      "path": "Lean/Compiler/IR/EmitUtil.olean",
      "imports": [
        "Lean.Compiler.InitAttr",
        "Lean.Compiler.IR.CompilerM"
      ]
    },
    "Lean.Compiler.IR.ExpandResetReuse": {
      "path": "Lean/Compiler/IR/ExpandResetReuse.olean",
      "imports": [
        "Lean.Compiler.IR.CompilerM",
        "Lean.Compiler.IR.NormIds",
        "Lean.Compiler.IR.FreeVars"
      ]
    },
    "Lean.Compiler.IR.Format": {
      "path": "Lean/Compiler/IR/Format.olean",
      "imports": [
        "Lean.Compiler.IR.Basic"
      ]
    },
    "Lean.Compiler.IR.FreeVars": {
      "path": "Lean/Compiler/IR/FreeVars.olean",
      "imports": [
        "Lean.Compiler.IR.Basic"
      ]
    },
    "Lean.Compiler.IR.LLVMBindings": {
      "path": "Lean/Compiler/IR/LLVMBindings.olean",
      "imports": [
        "Init.System.IO"
      ]
    },
    "Lean.Compiler.IR.LiveVars": {
      "path": "Lean/Compiler/IR/LiveVars.olean",
      "imports": [
        "Lean.Compiler.IR.FreeVars"
      ]
    },
    "Lean.Compiler.IR.Meta": {
      "path": "Lean/Compiler/IR/Meta.olean",
      "imports": [
        "Lean.Compiler.IR.CompilerM"
      ]
    },
    "Lean.Compiler.IR.NormIds": {
      "path": "Lean/Compiler/IR/NormIds.olean",
      "imports": [
        "Lean.Compiler.IR.Basic"
      ]
    },
    "Lean.Compiler.IR.PushProj": {
      "path": "Lean/Compiler/IR/PushProj.olean",
      "imports": [
        "Lean.Compiler.IR.FreeVars",
        "Lean.Compiler.IR.NormIds"
      ]
    },
    "Lean.Compiler.IR.RC": {
      "path": "Lean/Compiler/IR/RC.olean",
      "imports": [
        "Lean.Runtime",
        "Lean.Compiler.IR.CompilerM"
      ]
    },
    "Lean.Compiler.IR.ResetReuse": {
      "path": "Lean/Compiler/IR/ResetReuse.olean",
      "imports": [
        "Lean.Compiler.IR.CompilerM",
        "Lean.Compiler.IR.LiveVars"
      ]
    },
    "Lean.Compiler.IR.SimpCase": {
      "path": "Lean/Compiler/IR/SimpCase.olean",
      "imports": [
        "Lean.Compiler.IR.Format"
      ]
    },
    "Lean.Compiler.IR.Sorry": {
      "path": "Lean/Compiler/IR/Sorry.olean",
      "imports": [
        "Lean.Compiler.IR.CompilerM"
      ]
    },
    "Lean.Compiler.IR.ToIR": {
      "path": "Lean/Compiler/IR/ToIR.olean",
      "imports": [
        "Lean.Compiler.IR.CompilerM",
        "Lean.Compiler.IR.ToIRType"
      ]
    },
    "Lean.Compiler.IR.ToIRType": {
      "path": "Lean/Compiler/IR/ToIRType.olean",
      "imports": [
        "Lean.Compiler.IR.Format",
        "Lean.Compiler.LCNF.MonoTypes"
      ]
    },
    "Lean.Compiler.IR.Toposort": {
      "path": "Lean/Compiler/IR/Toposort.olean",
      "imports": [
        "Lean.Compiler.IR.CompilerM"
      ]
    },
    "Lean.Compiler.IR.UnboxResult": {
      "path": "Lean/Compiler/IR/UnboxResult.olean",
      "imports": [
        "Lean.Compiler.IR.Basic"
      ]
    },
    "Lean.Compiler.IR": {
      "path": "Lean/Compiler/IR.olean",
      "imports": [
        "Lean.Compiler.IR.AddExtern",
        "Lean.Compiler.IR.Basic",
        "Lean.Compiler.IR.Format",
        "Lean.Compiler.IR.CompilerM",
        "Lean.Compiler.IR.PushProj",
        "Lean.Compiler.IR.ElimDeadVars",
        "Lean.Compiler.IR.SimpCase",
        "Lean.Compiler.IR.ResetReuse",
        "Lean.Compiler.IR.NormIds",
        "Lean.Compiler.IR.Checker",
        "Lean.Compiler.IR.Borrow",
        "Lean.Compiler.IR.Boxing",
        "Lean.Compiler.IR.RC",
        "Lean.Compiler.IR.ExpandResetReuse",
        "Lean.Compiler.IR.UnboxResult",
        "Lean.Compiler.IR.EmitC",
        "Lean.Compiler.IR.Sorry",
        "Lean.Compiler.IR.ToIR",
        "Lean.Compiler.IR.ToIRType",
        "Lean.Compiler.IR.Meta",
        "Lean.Compiler.IR.Toposort",
        "Lean.Compiler.IR.LLVMBindings",
        "Lean.Compiler.IR.EmitLLVM"
      ]
    },
    "Lean.Compiler.ImplementedByAttr": {
      "path": "Lean/Compiler/ImplementedByAttr.olean",
      "imports": [
        "Lean.Elab.InfoTree",
        "Lean.Compiler.LCNF.PhaseExt"
      ]
    },
    "Lean.Compiler.InitAttr": {
      "path": "Lean/Compiler/InitAttr.olean",
      "imports": [
        "Lean.AddDecl",
        "Lean.Elab.InfoTree.Main",
        "Init.Data.Range.Polymorphic.Stream",
        "Lean.Compiler.NameMangling",
        "Lean.Compiler.ModPkgExt"
      ]
    },
    "Lean.Compiler.InlineAttrs": {
      "path": "Lean/Compiler/InlineAttrs.olean",
      "imports": [
        "Lean.Attributes"
      ]
    },
    "Lean.Compiler.LCNF.AlphaEqv": {
      "path": "Lean/Compiler/LCNF/AlphaEqv.olean",
      "imports": [
        "Lean.Compiler.LCNF.Basic"
      ]
    },
    "Lean.Compiler.LCNF.AuxDeclCache": {
      "path": "Lean/Compiler/LCNF/AuxDeclCache.olean",
      "imports": [
        "Lean.Compiler.LCNF.DeclHash",
        "Lean.Compiler.LCNF.Internalize"
      ]
    },
    "Lean.Compiler.LCNF.BaseTypes": {
      "path": "Lean/Compiler/LCNF/BaseTypes.olean",
      "imports": [
        "Lean.Compiler.LCNF.CompilerM"
      ]
    },
    "Lean.Compiler.LCNF.Basic": {
      "path": "Lean/Compiler/LCNF/Basic.olean",
      "imports": [
        "Lean.Meta.Instances",
        "Lean.Compiler.ExternAttr",
        "Lean.Compiler.Specialize",
        "Lean.Compiler.LCNF.Types"
      ]
    },
    "Lean.Compiler.LCNF.Bind": {
      "path": "Lean/Compiler/LCNF/Bind.olean",
      "imports": [
        "Lean.Compiler.LCNF.InferType"
      ]
    },
    "Lean.Compiler.LCNF.CSE": {
      "path": "Lean/Compiler/LCNF/CSE.olean",
      "imports": [
        "Lean.Compiler.LCNF.ToExpr",
        "Lean.Compiler.LCNF.PassManager",
        "Lean.Compiler.NeverExtractAttr"
      ]
    },
    "Lean.Compiler.LCNF.Check": {
      "path": "Lean/Compiler/LCNF/Check.olean",
      "imports": [
        "Lean.Compiler.LCNF.PrettyPrinter",
        "Lean.Compiler.LCNF.CompatibleTypes"
      ]
    },
    "Lean.Compiler.LCNF.Closure": {
      "path": "Lean/Compiler/LCNF/Closure.olean",
      "imports": [
        "Lean.Util.ForEachExprWhere",
        "Lean.Compiler.LCNF.CompilerM"
      ]
    },
    "Lean.Compiler.LCNF.CompatibleTypes": {
      "path": "Lean/Compiler/LCNF/CompatibleTypes.olean",
      "imports": [
        "Lean.Compiler.LCNF.InferType"
      ]
    },
    "Lean.Compiler.LCNF.CompilerM": {
      "path": "Lean/Compiler/LCNF/CompilerM.olean",
      "imports": [
        "Lean.Compiler.LCNF.LCtx",
        "Lean.Compiler.LCNF.ConfigOptions"
      ]
    },
    "Lean.Compiler.LCNF.ConfigOptions": {
      "path": "Lean/Compiler/LCNF/ConfigOptions.olean",
      "imports": [
        "Lean.Data.Options"
      ]
    },
    "Lean.Compiler.LCNF.DeclHash": {
      "path": "Lean/Compiler/LCNF/DeclHash.olean",
      "imports": [
        "Lean.Compiler.LCNF.Basic"
      ]
    },
    "Lean.Compiler.LCNF.DependsOn": {
      "path": "Lean/Compiler/LCNF/DependsOn.olean",
      "imports": [
        "Lean.Compiler.LCNF.Basic"
      ]
    },
    "Lean.Compiler.LCNF.ElimDead": {
      "path": "Lean/Compiler/LCNF/ElimDead.olean",
      "imports": [
        "Lean.Compiler.LCNF.CompilerM"
      ]
    },
    "Lean.Compiler.LCNF.ElimDeadBranches": {
      "path": "Lean/Compiler/LCNF/ElimDeadBranches.olean",
      "imports": [
        "Lean.Compiler.LCNF.InferType"
      ]
    },
    "Lean.Compiler.LCNF.ExtractClosed": {
      "path": "Lean/Compiler/LCNF/ExtractClosed.olean",
      "imports": [
        "Lean.Compiler.ClosedTermCache",
        "Lean.Compiler.NeverExtractAttr",
        "Lean.Compiler.LCNF.Internalize",
        "Lean.Compiler.LCNF.ToExpr"
      ]
    },
    "Lean.Compiler.LCNF.FVarUtil": {
      "path": "Lean/Compiler/LCNF/FVarUtil.olean",
      "imports": [
        "Lean.Compiler.LCNF.CompilerM"
      ]
    },
    "Lean.Compiler.LCNF.FixedParams": {
      "path": "Lean/Compiler/LCNF/FixedParams.olean",
      "imports": [
        "Lean.Compiler.LCNF.Basic"
      ]
    },
    "Lean.Compiler.LCNF.FloatLetIn": {
      "path": "Lean/Compiler/LCNF/FloatLetIn.olean",
      "imports": [
        "Lean.Compiler.LCNF.FVarUtil",
        "Lean.Compiler.LCNF.PassManager"
      ]
    },
    "Lean.Compiler.LCNF.InferType": {
      "path": "Lean/Compiler/LCNF/InferType.olean",
      "imports": [
        "Lean.Compiler.LCNF.PhaseExt",
        "Lean.Compiler.LCNF.OtherDecl"
      ]
    },
    "Lean.Compiler.LCNF.Internalize": {
      "path": "Lean/Compiler/LCNF/Internalize.olean",
      "imports": [
        "Lean.Compiler.LCNF.Bind"
      ]
    },
    "Lean.Compiler.LCNF.Irrelevant": {
      "path": "Lean/Compiler/LCNF/Irrelevant.olean",
      "imports": [
        "Lean.Compiler.LCNF.CompilerM",
        "Lean.Compiler.LCNF.BaseTypes",
        "Lean.Compiler.LCNF.Util"
      ]
    },
    "Lean.Compiler.LCNF.JoinPoints": {
      "path": "Lean/Compiler/LCNF/JoinPoints.olean",
      "imports": [
        "Lean.Compiler.LCNF.PullFunDecls",
        "Lean.Compiler.LCNF.FVarUtil",
        "Lean.Compiler.LCNF.ScopeM",
        "Lean.Compiler.LCNF.InferType"
      ]
    },
    "Lean.Compiler.LCNF.LCtx": {
      "path": "Lean/Compiler/LCNF/LCtx.olean",
      "imports": [
        "Lean.Compiler.LCNF.Basic"
      ]
    },
    "Lean.Compiler.LCNF.LambdaLifting": {
      "path": "Lean/Compiler/LCNF/LambdaLifting.olean",
      "imports": [
        "Lean.Compiler.LCNF.Closure",
        "Lean.Compiler.LCNF.MonadScope",
        "Lean.Compiler.LCNF.Level",
        "Lean.Compiler.LCNF.AuxDeclCache"
      ]
    },
    "Lean.Compiler.LCNF.Level": {
      "path": "Lean/Compiler/LCNF/Level.olean",
      "imports": [
        "Lean.Util.CollectLevelParams",
        "Lean.Compiler.LCNF.Basic"
      ]
    },
    "Lean.Compiler.LCNF.Main": {
      "path": "Lean/Compiler/LCNF/Main.olean",
      "imports": [
        "Lean.Compiler.Options",
        "Lean.Compiler.IR",
        "Lean.Compiler.LCNF.Passes",
        "Lean.Compiler.LCNF.ToDecl",
        "Lean.Compiler.LCNF.Check"
      ]
    },
    "Lean.Compiler.LCNF.MonadScope": {
      "path": "Lean/Compiler/LCNF/MonadScope.olean",
      "imports": [
        "Lean.Compiler.LCNF.Basic"
      ]
    },
    "Lean.Compiler.LCNF.MonoTypes": {
      "path": "Lean/Compiler/LCNF/MonoTypes.olean",
      "imports": [
        "Lean.Compiler.LCNF.Util",
        "Lean.Compiler.LCNF.BaseTypes",
        "Lean.Compiler.LCNF.CompilerM",
        "Lean.Compiler.LCNF.Irrelevant"
      ]
    },
    "Lean.Compiler.LCNF.OtherDecl": {
      "path": "Lean/Compiler/LCNF/OtherDecl.olean",
      "imports": [
        "Lean.Compiler.LCNF.MonoTypes"
      ]
    },
    "Lean.Compiler.LCNF.PassManager": {
      "path": "Lean/Compiler/LCNF/PassManager.olean",
      "imports": [
        "Lean.Compiler.LCNF.CompilerM"
      ]
    },
    "Lean.Compiler.LCNF.Passes": {
      "path": "Lean/Compiler/LCNF/Passes.olean",
      "imports": [
        "Lean.Compiler.LCNF.PullLetDecls",
        "Lean.Compiler.LCNF.CSE",
        "Lean.Compiler.LCNF.JoinPoints",
        "Lean.Compiler.LCNF.Specialize",
        "Lean.Compiler.LCNF.ToMono",
        "Lean.Compiler.LCNF.LambdaLifting",
        "Lean.Compiler.LCNF.FloatLetIn",
        "Lean.Compiler.LCNF.ReduceArity",
        "Lean.Compiler.LCNF.ElimDeadBranches",
        "Lean.Compiler.LCNF.StructProjCases",
        "Lean.Compiler.LCNF.ExtractClosed",
        "Lean.Compiler.LCNF.Visibility",
        "Lean.Compiler.LCNF.Simp"
      ]
    },
    "Lean.Compiler.LCNF.PhaseExt": {
      "path": "Lean/Compiler/LCNF/PhaseExt.olean",
      "imports": [
        "Lean.Compiler.LCNF.PassManager"
      ]
    },
    "Lean.Compiler.LCNF.PrettyPrinter": {
      "path": "Lean/Compiler/LCNF/PrettyPrinter.olean",
      "imports": [
        "Lean.PrettyPrinter.Delaborator.Options",
        "Lean.Compiler.LCNF.Internalize"
      ]
    },
    "Lean.Compiler.LCNF.Probing": {
      "path": "Lean/Compiler/LCNF/Probing.olean",
      "imports": [
        "Lean.Compiler.LCNF.PhaseExt"
      ]
    },
    "Lean.Compiler.LCNF.PullFunDecls": {
      "path": "Lean/Compiler/LCNF/PullFunDecls.olean",
      "imports": [
        "Lean.Compiler.LCNF.DependsOn",
        "Lean.Compiler.LCNF.PassManager"
      ]
    },
    "Lean.Compiler.LCNF.PullLetDecls": {
      "path": "Lean/Compiler/LCNF/PullLetDecls.olean",
      "imports": [
        "Lean.Compiler.LCNF.DependsOn",
        "Lean.Compiler.LCNF.PassManager"
      ]
    },
    "Lean.Compiler.LCNF.ReduceArity": {
      "path": "Lean/Compiler/LCNF/ReduceArity.olean",
      "imports": [
        "Lean.Compiler.LCNF.Internalize"
      ]
    },
    "Lean.Compiler.LCNF.ReduceJpArity": {
      "path": "Lean/Compiler/LCNF/ReduceJpArity.olean",
      "imports": [
        "Lean.Compiler.LCNF.InferType"
      ]
    },
    "Lean.Compiler.LCNF.Renaming": {
      "path": "Lean/Compiler/LCNF/Renaming.olean",
      "imports": [
        "Lean.Compiler.LCNF.CompilerM"
      ]
    },
    "Lean.Compiler.LCNF.ScopeM": {
      "path": "Lean/Compiler/LCNF/ScopeM.olean",
      "imports": [
        "Lean.Compiler.LCNF.CompilerM"
      ]
    },
    "Lean.Compiler.LCNF.Simp.Basic": {
      "path": "Lean/Compiler/LCNF/Simp/Basic.olean",
      "imports": [
        "Lean.Compiler.LCNF.CompilerM"
      ]
    },
    "Lean.Compiler.LCNF.Simp.Config": {
      "path": "Lean/Compiler/LCNF/Simp/Config.olean",
      "imports": [
        "Init.Core"
      ]
    },
    "Lean.Compiler.LCNF.Simp.ConstantFold": {
      "path": "Lean/Compiler/LCNF/Simp/ConstantFold.olean",
      "imports": [
        "Init.Data.UInt.Log2",
        "Lean.Compiler.LCNF.InferType"
      ]
    },
    "Lean.Compiler.LCNF.Simp.DefaultAlt": {
      "path": "Lean/Compiler/LCNF/Simp/DefaultAlt.olean",
      "imports": [
        "Lean.Compiler.LCNF.Simp.SimpM"
      ]
    },
    "Lean.Compiler.LCNF.Simp.DiscrM": {
      "path": "Lean/Compiler/LCNF/Simp/DiscrM.olean",
      "imports": [
        "Lean.Compiler.LCNF.InferType",
        "Lean.Compiler.LCNF.Simp.Basic"
      ]
    },
    "Lean.Compiler.LCNF.Simp.FunDeclInfo": {
      "path": "Lean/Compiler/LCNF/Simp/FunDeclInfo.olean",
      "imports": [
        "Lean.Compiler.LCNF.Simp.Basic"
      ]
    },
    "Lean.Compiler.LCNF.Simp.InlineCandidate": {
      "path": "Lean/Compiler/LCNF/Simp/InlineCandidate.olean",
      "imports": [
        "Lean.Compiler.LCNF.Simp.SimpM"
      ]
    },
    "Lean.Compiler.LCNF.Simp.InlineProj": {
      "path": "Lean/Compiler/LCNF/Simp/InlineProj.olean",
      "imports": [
        "Lean.Compiler.LCNF.Simp.SimpM"
      ]
    },
    "Lean.Compiler.LCNF.Simp.JpCases": {
      "path": "Lean/Compiler/LCNF/Simp/JpCases.olean",
      "imports": [
        "Lean.Compiler.LCNF.DependsOn",
        "Lean.Compiler.LCNF.Internalize",
        "Lean.Compiler.LCNF.Simp.DiscrM"
      ]
    },
    "Lean.Compiler.LCNF.Simp.Main": {
      "path": "Lean/Compiler/LCNF/Simp/Main.olean",
      "imports": [
        "Lean.Compiler.LCNF.Simp.InlineCandidate",
        "Lean.Compiler.LCNF.Simp.InlineProj",
        "Lean.Compiler.LCNF.Simp.Used",
        "Lean.Compiler.LCNF.Simp.DefaultAlt",
        "Lean.Compiler.LCNF.Simp.SimpValue",
        "Lean.Compiler.LCNF.Simp.ConstantFold"
      ]
    },
    "Lean.Compiler.LCNF.Simp.SimpM": {
      "path": "Lean/Compiler/LCNF/Simp/SimpM.olean",
      "imports": [
        "Lean.Compiler.ImplementedByAttr",
        "Lean.Compiler.LCNF.Renaming",
        "Lean.Compiler.LCNF.ElimDead",
        "Lean.Compiler.LCNF.AlphaEqv",
        "Lean.Compiler.LCNF.PrettyPrinter",
        "Lean.Compiler.LCNF.Simp.JpCases",
        "Lean.Compiler.LCNF.Simp.FunDeclInfo",
        "Lean.Compiler.LCNF.Simp.Config"
      ]
    },
    "Lean.Compiler.LCNF.Simp.SimpValue": {
      "path": "Lean/Compiler/LCNF/Simp/SimpValue.olean",
      "imports": [
        "Lean.Compiler.LCNF.Simp.SimpM"
      ]
    },
    "Lean.Compiler.LCNF.Simp.Used": {
      "path": "Lean/Compiler/LCNF/Simp/Used.olean",
      "imports": [
        "Lean.Compiler.LCNF.Simp.SimpM"
      ]
    },
    "Lean.Compiler.LCNF.Simp": {
      "path": "Lean/Compiler/LCNF/Simp.olean",
      "imports": [
        "Lean.Compiler.LCNF.ReduceJpArity",
        "Lean.Compiler.LCNF.Simp.Basic",
        "Lean.Compiler.LCNF.Simp.FunDeclInfo",
        "Lean.Compiler.LCNF.Simp.JpCases",
        "Lean.Compiler.LCNF.Simp.Config",
        "Lean.Compiler.LCNF.Simp.InlineCandidate",
        "Lean.Compiler.LCNF.Simp.SimpM",
        "Lean.Compiler.LCNF.Simp.Main",
        "Lean.Compiler.LCNF.Simp.InlineProj",
        "Lean.Compiler.LCNF.Simp.DefaultAlt",
        "Lean.Compiler.LCNF.Simp.SimpValue",
        "Lean.Compiler.LCNF.Simp.Used"
      ]
    },
    "Lean.Compiler.LCNF.SpecInfo": {
      "path": "Lean/Compiler/LCNF/SpecInfo.olean",
      "imports": [
        "Lean.Compiler.LCNF.FixedParams",
        "Lean.Compiler.LCNF.InferType"
      ]
    },
    "Lean.Compiler.LCNF.Specialize": {
      "path": "Lean/Compiler/LCNF/Specialize.olean",
      "imports": [
        "Lean.Compiler.LCNF.SpecInfo",
        "Lean.Compiler.LCNF.MonadScope",
        "Lean.Compiler.LCNF.FVarUtil",
        "Lean.Compiler.LCNF.Simp",
        "Lean.Compiler.LCNF.ToExpr",
        "Lean.Compiler.LCNF.Level",
        "Lean.Compiler.LCNF.Closure"
      ]
    },
    "Lean.Compiler.LCNF.StructProjCases": {
      "path": "Lean/Compiler/LCNF/StructProjCases.olean",
      "imports": [
        "Lean.Compiler.LCNF.PrettyPrinter"
      ]
    },
    "Lean.Compiler.LCNF.Testing": {
      "path": "Lean/Compiler/LCNF/Testing.olean",
      "imports": [
        "Lean.Compiler.LCNF.PrettyPrinter"
      ]
    },
    "Lean.Compiler.LCNF.ToDecl": {
      "path": "Lean/Compiler/LCNF/ToDecl.olean",
      "imports": [
        "Lean.Compiler.InitAttr",
        "Lean.Compiler.LCNF.ToLCNF"
      ]
    },
    "Lean.Compiler.LCNF.ToExpr": {
      "path": "Lean/Compiler/LCNF/ToExpr.olean",
      "imports": [
        "Lean.Compiler.LCNF.Basic"
      ]
    },
    "Lean.Compiler.LCNF.ToLCNF": {
      "path": "Lean/Compiler/LCNF/ToLCNF.olean",
      "imports": [
        "Lean.Meta.AppBuilder",
        "Lean.Compiler.CSimpAttr",
        "Lean.Compiler.ImplementedByAttr",
        "Lean.Compiler.LCNF.Bind",
        "Lean.Compiler.NeverExtractAttr",
        "Lean.Meta.CasesInfo"
      ]
    },
    "Lean.Compiler.LCNF.ToMono": {
      "path": "Lean/Compiler/LCNF/ToMono.olean",
      "imports": [
        "Lean.Compiler.ImplementedByAttr",
        "Lean.Compiler.LCNF.InferType",
        "Lean.Compiler.NoncomputableAttr"
      ]
    },
    "Lean.Compiler.LCNF.Types": {
      "path": "Lean/Compiler/LCNF/Types.olean",
      "imports": [
        "Lean.Compiler.BorrowedAnnotation",
        "Lean.Meta.InferType",
        "Lean.AddDecl"
      ]
    },
    "Lean.Compiler.LCNF.Util": {
      "path": "Lean/Compiler/LCNF/Util.olean",
      "imports": [
        "Init.Data.FloatArray.Basic",
        "Lean.CoreM",
        "Lean.Util.Recognizers",
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Compiler.LCNF.Visibility": {
      "path": "Lean/Compiler/LCNF/Visibility.olean",
      "imports": [
        "Lean.Compiler.ImplementedByAttr",
        "Lean.ExtraModUses",
        "Lean.Compiler.Options"
      ]
    },
    "Lean.Compiler.LCNF": {
      "path": "Lean/Compiler/LCNF.olean",
      "imports": [
        "Lean.Compiler.LCNF.AlphaEqv",
        "Lean.Compiler.LCNF.Basic",
        "Lean.Compiler.LCNF.Bind",
        "Lean.Compiler.LCNF.Check",
        "Lean.Compiler.LCNF.CompilerM",
        "Lean.Compiler.LCNF.CSE",
        "Lean.Compiler.LCNF.DependsOn",
        "Lean.Compiler.LCNF.ElimDead",
        "Lean.Compiler.LCNF.FixedParams",
        "Lean.Compiler.LCNF.InferType",
        "Lean.Compiler.LCNF.JoinPoints",
        "Lean.Compiler.LCNF.LCtx",
        "Lean.Compiler.LCNF.Level",
        "Lean.Compiler.LCNF.Main",
        "Lean.Compiler.LCNF.Passes",
        "Lean.Compiler.LCNF.PassManager",
        "Lean.Compiler.LCNF.PhaseExt",
        "Lean.Compiler.LCNF.PrettyPrinter",
        "Lean.Compiler.LCNF.PullFunDecls",
        "Lean.Compiler.LCNF.PullLetDecls",
        "Lean.Compiler.LCNF.ReduceJpArity",
        "Lean.Compiler.LCNF.Simp",
        "Lean.Compiler.LCNF.Specialize",
        "Lean.Compiler.LCNF.SpecInfo",
        "Lean.Compiler.LCNF.Testing",
        "Lean.Compiler.LCNF.ToDecl",
        "Lean.Compiler.LCNF.ToExpr",
        "Lean.Compiler.LCNF.ToLCNF",
        "Lean.Compiler.LCNF.Types",
        "Lean.Compiler.LCNF.Util",
        "Lean.Compiler.LCNF.ConfigOptions",
        "Lean.Compiler.LCNF.MonoTypes",
        "Lean.Compiler.LCNF.ToMono",
        "Lean.Compiler.LCNF.MonadScope",
        "Lean.Compiler.LCNF.Closure",
        "Lean.Compiler.LCNF.LambdaLifting",
        "Lean.Compiler.LCNF.ReduceArity",
        "Lean.Compiler.LCNF.Probing",
        "Lean.Compiler.LCNF.Irrelevant"
      ]
    },
    "Lean.Compiler.Main": {
      "path": "Lean/Compiler/Main.olean",
      "imports": [
        "Lean.Compiler.LCNF"
      ]
    },
    "Lean.Compiler.MetaAttr": {
      "path": "Lean/Compiler/MetaAttr.olean",
      "imports": [
        "Lean.EnvExtension"
      ]
    },
    "Lean.Compiler.ModPkgExt": {
      "path": "Lean/Compiler/ModPkgExt.olean",
      "imports": [
        "Lean.Environment",
        "Lean.Compiler.NameMangling"
      ]
    },
    "Lean.Compiler.NameMangling": {
      "path": "Lean/Compiler/NameMangling.olean",
      "imports": [
        "Lean.Setup",
        "Init.Data.String.Termination"
      ]
    },
    "Lean.Compiler.NeverExtractAttr": {
      "path": "Lean/Compiler/NeverExtractAttr.olean",
      "imports": [
        "Lean.Attributes"
      ]
    },
    "Lean.Compiler.NoncomputableAttr": {
      "path": "Lean/Compiler/NoncomputableAttr.olean",
      "imports": [
        "Lean.EnvExtension"
      ]
    },
    "Lean.Compiler.Old": {
      "path": "Lean/Compiler/Old.olean",
      "imports": [
        "Lean.Environment",
        "Init.Data.String.TakeDrop"
      ]
    },
    "Lean.Compiler.Options": {
      "path": "Lean/Compiler/Options.olean",
      "imports": [
        "Lean.Util.Trace"
      ]
    },
    "Lean.Compiler.Specialize": {
      "path": "Lean/Compiler/Specialize.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Compiler": {
      "path": "Lean/Compiler.olean",
      "imports": [
        "Lean.Compiler.InlineAttrs",
        "Lean.Compiler.Specialize",
        "Lean.Compiler.ClosedTermCache",
        "Lean.Compiler.ExternAttr",
        "Lean.Compiler.ImplementedByAttr",
        "Lean.Compiler.NeverExtractAttr",
        "Lean.Compiler.IR",
        "Lean.Compiler.CSimpAttr",
        "Lean.Compiler.FFI",
        "Lean.Compiler.MetaAttr",
        "Lean.Compiler.NoncomputableAttr",
        "Lean.Compiler.Main",
        "Lean.Compiler.Old"
      ]
    },
    "Lean.CoreM": {
      "path": "Lean/CoreM.olean",
      "imports": [
        "Lean.Util.RecDepth",
        "Lean.ResolveName",
        "Lean.Language.Basic"
      ]
    },
    "Lean.Data.Array": {
      "path": "Lean/Data/Array.olean",
      "imports": [
        "Init.Data.Stream",
        "Init.Data.Range.Polymorphic.Nat",
        "Init.Data.Range.Polymorphic.Iterators"
      ]
    },
    "Lean.Data.AssocList": {
      "path": "Lean/Data/AssocList.olean",
      "imports": [
        "Init.Data.List.Impl"
      ]
    },
    "Lean.Data.DeclarationRange": {
      "path": "Lean/Data/DeclarationRange.olean",
      "imports": [
        "Lean.Data.Position"
      ]
    },
    "Lean.Data.EditDistance": {
      "path": "Lean/Data/EditDistance.olean",
      "imports": [
        "Init.Data.String.Basic",
        "Init.Data.Vector.Basic"
      ]
    },
    "Lean.Data.Format": {
      "path": "Lean/Data/Format.olean",
      "imports": [
        "Lean.Data.Options"
      ]
    },
    "Lean.Data.FuzzyMatching": {
      "path": "Lean/Data/FuzzyMatching.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.Iterators",
        "Init.Data.Range.Polymorphic.Nat",
        "Init.Data.OfScientific",
        "Init.Data.Option.Coe",
        "Init.Data.Range",
        "Init.Data.SInt.Basic",
        "Init.Data.String.Basic",
        "Lean.Server.Completion.CompletionUtils"
      ]
    },
    "Lean.Data.Json.Basic": {
      "path": "Lean/Data/Json/Basic.olean",
      "imports": [
        "Init.Data.Range",
        "Init.Data.OfScientific",
        "Init.Data.Hashable",
        "Std.Data.TreeMap.Raw.Basic",
        "Init.Data.Ord.String",
        "Init.Data.Range.Polymorphic.Iterators",
        "Init.Data.Range.Polymorphic.Nat",
        "Init.Data.String.TakeDrop"
      ]
    },
    "Lean.Data.Json.Elab": {
      "path": "Lean/Data/Json/Elab.olean",
      "imports": [
        "Lean.Data.Json.FromToJson",
        "Lean.Syntax"
      ]
    },
    "Lean.Data.Json.FromToJson.Basic": {
      "path": "Lean/Data/Json/FromToJson/Basic.olean",
      "imports": [
        "Lean.Data.Json.Printer"
      ]
    },
    "Lean.Data.Json.FromToJson.Extra": {
      "path": "Lean/Data/Json/FromToJson/Extra.olean",
      "imports": [
        "Lean.Data.Json.FromToJson.Basic",
        "Std.Data.TreeMap.AdditionalOperations"
      ]
    },
    "Lean.Data.Json.FromToJson": {
      "path": "Lean/Data/Json/FromToJson.olean",
      "imports": [
        "Lean.Data.Json.FromToJson.Basic",
        "Lean.Data.Json.FromToJson.Extra"
      ]
    },
    "Lean.Data.Json.Parser": {
      "path": "Lean/Data/Json/Parser.olean",
      "imports": [
        "Lean.Data.Json.Basic",
        "Std.Internal.Parsec"
      ]
    },
    "Lean.Data.Json.Printer": {
      "path": "Lean/Data/Json/Printer.olean",
      "imports": [
        "Lean.Data.Format",
        "Lean.Data.Json.Basic",
        "Init.Data.String.Search"
      ]
    },
    "Lean.Data.Json.Stream": {
      "path": "Lean/Data/Json/Stream.olean",
      "imports": [
        "Lean.Data.Json.Parser",
        "Lean.Data.Json.Printer"
      ]
    },
    "Lean.Data.Json": {
      "path": "Lean/Data/Json.olean",
      "imports": [
        "Lean.Data.Json.Stream",
        "Lean.Data.Json.Printer",
        "Lean.Data.Json.Parser",
        "Lean.Data.Json.FromToJson",
        "Lean.Data.Json.Elab"
      ]
    },
    "Lean.Data.JsonRpc": {
      "path": "Lean/Data/JsonRpc.olean",
      "imports": [
        "Lean.Data.Json.Stream",
        "Lean.Data.Json.FromToJson.Basic"
      ]
    },
    "Lean.Data.KVMap": {
      "path": "Lean/Data/KVMap.olean",
      "imports": [
        "Init.Data.Format.Syntax",
        "Init.Data.ToString.Name"
      ]
    },
    "Lean.Data.LBool": {
      "path": "Lean/Data/LBool.olean",
      "imports": [
        "Init.Data.ToString.Basic"
      ]
    },
    "Lean.Data.LOption": {
      "path": "Lean/Data/LOption.olean",
      "imports": [
        "Init.Data.String.Basic"
      ]
    },
    "Lean.Data.Lsp.Basic": {
      "path": "Lean/Data/Lsp/Basic.olean",
      "imports": [
        "Lean.Data.Json",
        "Lean.Data.Lsp.BasicAux"
      ]
    },
    "Lean.Data.Lsp.BasicAux": {
      "path": "Lean/Data/Lsp/BasicAux.olean",
      "imports": [
        "Lean.Data.Json.FromToJson.Basic"
      ]
    },
    "Lean.Data.Lsp.CancelParams": {
      "path": "Lean/Data/Lsp/CancelParams.olean",
      "imports": [
        "Lean.Data.JsonRpc"
      ]
    },
    "Lean.Data.Lsp.Capabilities": {
      "path": "Lean/Data/Lsp/Capabilities.olean",
      "imports": [
        "Lean.Data.JsonRpc",
        "Lean.Data.Lsp.LanguageFeatures",
        "Lean.Data.Lsp.CodeActions",
        "Lean.Data.Lsp.Extra"
      ]
    },
    "Lean.Data.Lsp.Client": {
      "path": "Lean/Data/Lsp/Client.olean",
      "imports": [
        "Lean.Data.Lsp.Basic"
      ]
    },
    "Lean.Data.Lsp.CodeActions": {
      "path": "Lean/Data/Lsp/CodeActions.olean",
      "imports": [
        "Lean.Data.Lsp.Diagnostics"
      ]
    },
    "Lean.Data.Lsp.Communication": {
      "path": "Lean/Data/Lsp/Communication.olean",
      "imports": [
        "Lean.Data.JsonRpc",
        "Init.Data.String.TakeDrop",
        "Init.Data.String.Search"
      ]
    },
    "Lean.Data.Lsp.Diagnostics": {
      "path": "Lean/Data/Lsp/Diagnostics.olean",
      "imports": [
        "Lean.Data.Lsp.Basic",
        "Lean.Data.Lsp.Utf16"
      ]
    },
    "Lean.Data.Lsp.Extra": {
      "path": "Lean/Data/Lsp/Extra.olean",
      "imports": [
        "Lean.Data.Lsp.TextSync",
        "Lean.Server.Rpc.Basic"
      ]
    },
    "Lean.Data.Lsp.InitShutdown": {
      "path": "Lean/Data/Lsp/InitShutdown.olean",
      "imports": [
        "Lean.Data.Lsp.Capabilities",
        "Lean.Data.Lsp.Workspace"
      ]
    },
    "Lean.Data.Lsp.Internal": {
      "path": "Lean/Data/Lsp/Internal.olean",
      "imports": [
        "Lean.Expr",
        "Lean.Data.Lsp.Basic",
        "Lean.Data.JsonRpc",
        "Lean.Data.DeclarationRange"
      ]
    },
    "Lean.Data.Lsp.Ipc": {
      "path": "Lean/Data/Lsp/Ipc.olean",
      "imports": [
        "Lean.Data.Lsp.Communication",
        "Lean.Data.Lsp.Diagnostics",
        "Lean.Data.Lsp.Extra",
        "Init.Data.List.Sort.Basic",
        "Lean.Data.Lsp.LanguageFeatures"
      ]
    },
    "Lean.Data.Lsp.LanguageFeatures": {
      "path": "Lean/Data/Lsp/LanguageFeatures.olean",
      "imports": [
        "Lean.Data.Lsp.Basic",
        "Lean.Data.Json",
        "Lean.Expr",
        "Init.Data.String.Search"
      ]
    },
    "Lean.Data.Lsp.TextSync": {
      "path": "Lean/Data/Lsp/TextSync.olean",
      "imports": [
        "Lean.Data.Lsp.Basic"
      ]
    },
    "Lean.Data.Lsp.Utf16": {
      "path": "Lean/Data/Lsp/Utf16.olean",
      "imports": [
        "Lean.Data.Lsp.BasicAux",
        "Lean.DeclarationRange",
        "Init.Data.String.Search"
      ]
    },
    "Lean.Data.Lsp.Window": {
      "path": "Lean/Data/Lsp/Window.olean",
      "imports": [
        "Lean.Data.Json.FromToJson.Basic"
      ]
    },
    "Lean.Data.Lsp.Workspace": {
      "path": "Lean/Data/Lsp/Workspace.olean",
      "imports": [
        "Lean.Data.Lsp.Basic"
      ]
    },
    "Lean.Data.Lsp": {
      "path": "Lean/Data/Lsp.olean",
      "imports": [
        "Lean.Data.Lsp.Basic",
        "Lean.Data.Lsp.CancelParams",
        "Lean.Data.Lsp.Capabilities",
        "Lean.Data.Lsp.Client",
        "Lean.Data.Lsp.Communication",
        "Lean.Data.Lsp.Diagnostics",
        "Lean.Data.Lsp.Extra",
        "Lean.Data.Lsp.InitShutdown",
        "Lean.Data.Lsp.Internal",
        "Lean.Data.Lsp.LanguageFeatures",
        "Lean.Data.Lsp.TextSync",
        "Lean.Data.Lsp.Utf16",
        "Lean.Data.Lsp.Workspace",
        "Lean.Data.Lsp.Ipc",
        "Lean.Data.Lsp.CodeActions",
        "Lean.Data.Lsp.Window"
      ]
    },
    "Lean.Data.Name": {
      "path": "Lean/Data/Name.olean",
      "imports": [
        "Init.Data.Ord.Basic",
        "Init.Data.String.TakeDrop",
        "Init.Data.Ord.String",
        "Init.Data.Ord.UInt",
        "Init.Data.String.Search"
      ]
    },
    "Lean.Data.NameMap.AdditionalOperations": {
      "path": "Lean/Data/NameMap/AdditionalOperations.olean",
      "imports": [
        "Lean.Data.NameMap.Basic",
        "Std.Data.TreeSet.AdditionalOperations"
      ]
    },
    "Lean.Data.NameMap.Basic": {
      "path": "Lean/Data/NameMap/Basic.olean",
      "imports": [
        "Std.Data.HashSet.Basic",
        "Std.Data.TreeSet.Basic",
        "Lean.Data.SSet",
        "Lean.Data.Name"
      ]
    },
    "Lean.Data.NameMap": {
      "path": "Lean/Data/NameMap.olean",
      "imports": [
        "Lean.Data.NameMap.Basic",
        "Lean.Data.NameMap.AdditionalOperations"
      ]
    },
    "Lean.Data.NameTrie": {
      "path": "Lean/Data/NameTrie.olean",
      "imports": [
        "Lean.Data.PrefixTree",
        "Init.Data.Ord.String"
      ]
    },
    "Lean.Data.OpenDecl": {
      "path": "Lean/Data/OpenDecl.olean",
      "imports": [
        "Init.Data.ToString.Name"
      ]
    },
    "Lean.Data.Options": {
      "path": "Lean/Data/Options.olean",
      "imports": [
        "Lean.ImportingFlag",
        "Lean.Data.KVMap",
        "Lean.Data.NameMap.Basic"
      ]
    },
    "Lean.Data.PersistentArray": {
      "path": "Lean/Data/PersistentArray.olean",
      "imports": [
        "Init.Data.Nat.Fold",
        "Init.Data.UInt.Basic",
        "Init.Data.String.Basic"
      ]
    },
    "Lean.Data.PersistentHashMap": {
      "path": "Lean/Data/PersistentHashMap.olean",
      "imports": [
        "Init.Data.Array.BasicAux",
        "Init.Data.UInt.Basic",
        "Init.Data.String.Basic"
      ]
    },
    "Lean.Data.PersistentHashSet": {
      "path": "Lean/Data/PersistentHashSet.olean",
      "imports": [
        "Lean.Data.PersistentHashMap"
      ]
    },
    "Lean.Data.Position": {
      "path": "Lean/Data/Position.olean",
      "imports": [
        "Lean.Data.Json.FromToJson.Basic",
        "Lean.ToExpr"
      ]
    },
    "Lean.Data.PrefixTree": {
      "path": "Lean/Data/PrefixTree.olean",
      "imports": [
        "Std.Data.TreeMap.Raw.Basic"
      ]
    },
    "Lean.Data.RArray": {
      "path": "Lean/Data/RArray.olean",
      "imports": [
        "Lean.Meta.DecLevel"
      ]
    },
    "Lean.Data.RBMap": {
      "path": "Lean/Data/RBMap.olean",
      "imports": [
        "Init.Data.Ord.Basic",
        "Init.Data.Nat.Linear"
      ]
    },
    "Lean.Data.RBTree": {
      "path": "Lean/Data/RBTree.olean",
      "imports": [
        "Lean.Data.RBMap"
      ]
    },
    "Lean.Data.SMap": {
      "path": "Lean/Data/SMap.olean",
      "imports": [
        "Std.Data.HashMap.Basic",
        "Lean.Data.PersistentHashMap"
      ]
    },
    "Lean.Data.SSet": {
      "path": "Lean/Data/SSet.olean",
      "imports": [
        "Lean.Data.SMap"
      ]
    },
    "Lean.Data.Trie": {
      "path": "Lean/Data/Trie.olean",
      "imports": [
        "Lean.Data.Format",
        "Init.Data.Option.Coe"
      ]
    },
    "Lean.Data.Xml.Basic": {
      "path": "Lean/Data/Xml/Basic.olean",
      "imports": [
        "Std.Data.TreeMap.Basic",
        "Init.Data.Ord.String"
      ]
    },
    "Lean.Data.Xml.Parser": {
      "path": "Lean/Data/Xml/Parser.olean",
      "imports": [
        "Std.Internal.Parsec",
        "Lean.Data.Xml.Basic",
        "Init.Data.String.Search"
      ]
    },
    "Lean.Data.Xml": {
      "path": "Lean/Data/Xml.olean",
      "imports": [
        "Lean.Data.Xml.Basic",
        "Lean.Data.Xml.Parser"
      ]
    },
    "Lean.Data": {
      "path": "Lean/Data.olean",
      "imports": [
        "Lean.Data.AssocList",
        "Lean.Data.Format",
        "Lean.Data.Json",
        "Lean.Data.JsonRpc",
        "Lean.Data.KVMap",
        "Lean.Data.LBool",
        "Lean.Data.LOption",
        "Lean.Data.Lsp",
        "Lean.Data.Name",
        "Lean.Data.NameMap",
        "Lean.Data.OpenDecl",
        "Lean.Data.Options",
        "Lean.Data.PersistentArray",
        "Lean.Data.PersistentHashMap",
        "Lean.Data.PersistentHashSet",
        "Lean.Data.Position",
        "Lean.Data.PrefixTree",
        "Lean.Data.SMap",
        "Lean.Data.Trie",
        "Lean.Data.Xml",
        "Lean.Data.NameTrie",
        "Lean.Data.RBTree",
        "Lean.Data.RBMap",
        "Lean.Data.RArray"
      ]
    },
    "Lean.Declaration": {
      "path": "Lean/Declaration.olean",
      "imports": [
        "Lean.Expr"
      ]
    },
    "Lean.DeclarationRange": {
      "path": "Lean/DeclarationRange.olean",
      "imports": [
        "Lean.MonadEnv"
      ]
    },
    "Lean.DefEqAttrib": {
      "path": "Lean/DefEqAttrib.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.Check",
        "Lean.Meta.WHNF"
      ]
    },
    "Lean.DocString.Add": {
      "path": "Lean/DocString/Add.olean",
      "imports": [
        "Lean.Elab.DocString",
        "Lean.DocString.Parser",
        "Lean.Elab.Term.TermElabM",
        "Std.Data.HashMap"
      ]
    },
    "Lean.DocString.Extension": {
      "path": "Lean/DocString/Extension.olean",
      "imports": [
        "Lean.DeclarationRange",
        "Lean.DocString.Markdown",
        "Init.Data.String.Extra"
      ]
    },
    "Lean.DocString.Formatter": {
      "path": "Lean/DocString/Formatter.olean",
      "imports": [
        "Lean.PrettyPrinter.Formatter",
        "Lean.DocString.Parser"
      ]
    },
    "Lean.DocString.Links": {
      "path": "Lean/DocString/Links.olean",
      "imports": [
        "Lean.Syntax",
        "Init.Data.String.TakeDrop",
        "Init.Data.String.Search"
      ]
    },
    "Lean.DocString.Markdown": {
      "path": "Lean/DocString/Markdown.olean",
      "imports": [
        "Init.Data.Ord",
        "Lean.DocString.Types",
        "Init.Data.String.TakeDrop",
        "Init.Data.String.Search"
      ]
    },
    "Lean.DocString.Parser": {
      "path": "Lean/DocString/Parser.olean",
      "imports": [
        "Lean.DocString.Syntax",
        "Lean.Parser.Term.Basic"
      ]
    },
    "Lean.DocString.Syntax": {
      "path": "Lean/DocString/Syntax.olean",
      "imports": [
        "Lean.Parser.Term.Basic",
        "Lean.Parser.Term.Basic"
      ]
    },
    "Lean.DocString.Types": {
      "path": "Lean/DocString/Types.olean",
      "imports": [
        "Init.Data.Ord",
        "Init.Data.Nat.Compare"
      ]
    },
    "Lean.DocString": {
      "path": "Lean/DocString.olean",
      "imports": [
        "Lean.DocString.Extension",
        "Lean.DocString.Links",
        "Lean.Parser.Tactic.Doc",
        "Lean.Parser.Term.Doc"
      ]
    },
    "Lean.Elab.App": {
      "path": "Lean/Elab/App.olean",
      "imports": [
        "Lean.Meta.Tactic.ElimInfo",
        "Lean.Elab.Binders",
        "Lean.Elab.RecAppSyntax",
        "Lean.IdentifierSuggestion",
        "all"
      ]
    },
    "Lean.Elab.Arg": {
      "path": "Lean/Elab/Arg.olean",
      "imports": [
        "Lean.Elab.Term"
      ]
    },
    "Lean.Elab.AssertExists": {
      "path": "Lean/Elab/AssertExists.olean",
      "imports": [
        "Lean.Elab.Command",
        "is"
      ]
    },
    "Lean.Elab.Attributes": {
      "path": "Lean/Elab/Attributes.olean",
      "imports": [
        "Lean.Elab.Util",
        "Lean.Compiler.InitAttr",
        "Lean.Parser.Term"
      ]
    },
    "Lean.Elab.AutoBound": {
      "path": "Lean/Elab/AutoBound.olean",
      "imports": [
        "Lean.Data.Options",
        "Lean.Message",
        "Lean.Meta.Hint"
      ]
    },
    "Lean.Elab.AuxDef": {
      "path": "Lean/Elab/AuxDef.olean",
      "imports": [
        "Lean.Elab.Command",
        "Lean.Parser.Term"
      ]
    },
    "Lean.Elab.BinderPredicates": {
      "path": "Lean/Elab/BinderPredicates.olean",
      "imports": [
        "Lean.Elab.MacroArgUtil",
        "Lean.Linter.MissingDocs",
        "Lean.Parser.Syntax"
      ]
    },
    "Lean.Elab.Binders": {
      "path": "Lean/Elab/Binders.olean",
      "imports": [
        "Lean.Elab.Match",
        "Lean.Parser.Tactic",
        "Lean.Linter.Basic"
      ]
    },
    "Lean.Elab.BindersUtil": {
      "path": "Lean/Elab/BindersUtil.olean",
      "imports": [
        "Lean.Parser.Term",
        "Lean.Parser.Term"
      ]
    },
    "Lean.Elab.BuiltinCommand": {
      "path": "Lean/Elab/BuiltinCommand.olean",
      "imports": [
        "Lean.Meta.Reduce",
        "Lean.Elab.Eval",
        "Lean.Elab.Command",
        "Lean.Elab.Open"
      ]
    },
    "Lean.Elab.BuiltinEvalCommand": {
      "path": "Lean/Elab/BuiltinEvalCommand.olean",
      "imports": [
        "Lean.Elab.MutualDef",
        "Lean.Compiler.Options",
        "Lean.Meta.Reduce"
      ]
    },
    "Lean.Elab.BuiltinNotation": {
      "path": "Lean/Elab/BuiltinNotation.olean",
      "imports": [
        "Lean.Compiler.ImplementedByAttr",
        "Lean.Elab.Eval",
        "Lean.Elab.Binders",
        "Lean.IdentifierSuggestion",
        "Lean.Parser.Do"
      ]
    },
    "Lean.Elab.BuiltinTerm": {
      "path": "Lean/Elab/BuiltinTerm.olean",
      "imports": [
        "Lean.Meta.Diagnostics",
        "Lean.Elab.Open",
        "Lean.Elab.SetOption",
        "Lean.Elab.Eval",
        "Lean.Parser.Command",
        "Lean.ExtraModUses",
        "Lean.Compiler.NoncomputableAttr"
      ]
    },
    "Lean.Elab.Calc": {
      "path": "Lean/Elab/Calc.olean",
      "imports": [
        "Lean.Elab.App"
      ]
    },
    "Lean.Elab.CheckTactic": {
      "path": "Lean/Elab/CheckTactic.olean",
      "imports": [
        "Lean.Elab.Tactic.ElabTerm",
        "Lean.Elab.Command",
        "Lean.Elab.Tactic.Meta",
        "Lean.Meta.CheckTactic"
      ]
    },
    "Lean.Elab.Coinductive": {
      "path": "Lean/Elab/Coinductive.olean",
      "imports": [
        "Lean.Elab.PreDefinition.PartialFixpoint",
        "Lean.Elab.Tactic.Rewrite",
        "Lean.Meta.Tactic.Simp",
        "Lean.Linter.UnusedVariables"
      ]
    },
    "Lean.Elab.Command.Scope": {
      "path": "Lean/Elab/Command/Scope.olean",
      "imports": [
        "Lean.Parser.Term"
      ]
    },
    "Lean.Elab.Command.WithWeakNamespace": {
      "path": "Lean/Elab/Command/WithWeakNamespace.olean",
      "imports": [
        "Lean.Elab.Command",
        "Lean.Data.OpenDecl"
      ]
    },
    "Lean.Elab.Command": {
      "path": "Lean/Elab/Command.olean",
      "imports": [
        "Lean.Meta.Diagnostics",
        "Lean.Elab.Binders",
        "Lean.Elab.Command.Scope",
        "Lean.Elab.SetOption",
        "Lean.Parser.Command",
        "Lean.ExtraModUses",
        "Lean",
        "Lean"
      ]
    },
    "Lean.Elab.ComputedFields": {
      "path": "Lean/Elab/ComputedFields.olean",
      "imports": [
        "Lean.Meta.Constructions.CasesOn",
        "Lean.Compiler.ImplementedByAttr",
        "Lean.Elab.PreDefinition.WF.Eqns"
      ]
    },
    "Lean.Elab.Config": {
      "path": "Lean/Elab/Config.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Elab.DeclModifiers": {
      "path": "Lean/Elab/DeclModifiers.olean",
      "imports": [
        "Lean.DocString.Add",
        "Lean.Parser.Command"
      ]
    },
    "Lean.Elab.DeclNameGen": {
      "path": "Lean/Elab/DeclNameGen.olean",
      "imports": [
        "Lean.Elab.Command"
      ]
    },
    "Lean.Elab.DeclUtil": {
      "path": "Lean/Elab/DeclUtil.olean",
      "imports": [
        "Lean.Meta.Check",
        "Lean.Parser.Command",
        "Lean.Parser.Command"
      ]
    },
    "Lean.Elab.Declaration": {
      "path": "Lean/Elab/Declaration.olean",
      "imports": [
        "Lean.Elab.MutualDef",
        "Lean.Elab.MutualInductive",
        "Lean.Parser.Command"
      ]
    },
    "Lean.Elab.DeclarationRange": {
      "path": "Lean/Elab/DeclarationRange.olean",
      "imports": [
        "Lean.Parser.Command"
      ]
    },
    "Lean.Elab.DefView": {
      "path": "Lean/Elab/DefView.olean",
      "imports": [
        "Lean.Elab.DeclNameGen",
        "Lean.Elab.DeclUtil"
      ]
    },
    "Lean.Elab.Deriving.BEq": {
      "path": "Lean/Elab/Deriving/BEq.olean",
      "imports": [
        "Lean.Data.Options",
        "Lean.Elab.Deriving.Basic",
        "Lean.Elab.Deriving.Util",
        "Lean.Meta.Constructions.CtorIdx",
        "Lean.Meta.Constructions.CasesOnSameCtor",
        "Lean.Meta.SameCtorUtils"
      ]
    },
    "Lean.Elab.Deriving.Basic": {
      "path": "Lean/Elab/Deriving/Basic.olean",
      "imports": [
        "Lean.Elab.App",
        "Lean.Elab.DeclNameGen"
      ]
    },
    "Lean.Elab.Deriving.DecEq": {
      "path": "Lean/Elab/Deriving/DecEq.olean",
      "imports": [
        "Lean.Data.Options",
        "Lean.Meta.Inductive",
        "Lean.Elab.Deriving.Basic",
        "Lean.Elab.Deriving.Util",
        "Lean.Meta.NatTable",
        "Lean.Meta.Constructions.CtorIdx",
        "Lean.Meta.Constructions.CasesOnSameCtor",
        "Lean.Meta.SameCtorUtils"
      ]
    },
    "Lean.Elab.Deriving.FromToJson": {
      "path": "Lean/Elab/Deriving/FromToJson.olean",
      "imports": [
        "Lean.Elab.Deriving.Basic",
        "Lean.Elab.Deriving.Util",
        "Lean.Parser.Do"
      ]
    },
    "Lean.Elab.Deriving.Hashable": {
      "path": "Lean/Elab/Deriving/Hashable.olean",
      "imports": [
        "Lean.Meta.Inductive",
        "Lean.Elab.Deriving.Basic",
        "Lean.Elab.Deriving.Util"
      ]
    },
    "Lean.Elab.Deriving.Inhabited": {
      "path": "Lean/Elab/Deriving/Inhabited.olean",
      "imports": [
        "Lean.Elab.Deriving.Basic",
        "Lean.Elab.Deriving.Util"
      ]
    },
    "Lean.Elab.Deriving.LawfulBEq": {
      "path": "Lean/Elab/Deriving/LawfulBEq.olean",
      "imports": [
        "Lean.Elab.Deriving.Basic",
        "Lean.Elab.Deriving.Util",
        "Init.LawfulBEqTactics"
      ]
    },
    "Lean.Elab.Deriving.Nonempty": {
      "path": "Lean/Elab/Deriving/Nonempty.olean",
      "imports": [
        "Lean.Elab.Deriving.Basic",
        "Lean.Elab.Deriving.Util"
      ]
    },
    "Lean.Elab.Deriving.Ord": {
      "path": "Lean/Elab/Deriving/Ord.olean",
      "imports": [
        "Lean.Data.Options",
        "Lean.Elab.Deriving.Basic",
        "Lean.Elab.Deriving.Util",
        "Lean.Meta.Constructions.CtorIdx",
        "Lean.Meta.Constructions.CasesOnSameCtor",
        "Lean.Meta.SameCtorUtils"
      ]
    },
    "Lean.Elab.Deriving.ReflBEq": {
      "path": "Lean/Elab/Deriving/ReflBEq.olean",
      "imports": [
        "Lean.Elab.Deriving.Basic",
        "Lean.Elab.Deriving.Util",
        "Init.LawfulBEqTactics"
      ]
    },
    "Lean.Elab.Deriving.Repr": {
      "path": "Lean/Elab/Deriving/Repr.olean",
      "imports": [
        "Lean.Meta.Inductive",
        "Lean.Elab.Deriving.Basic",
        "Lean.Elab.Deriving.Util"
      ]
    },
    "Lean.Elab.Deriving.SizeOf": {
      "path": "Lean/Elab/Deriving/SizeOf.olean",
      "imports": [
        "Lean.Meta.SizeOf",
        "Lean.Elab.Deriving.Basic",
        "Lean.Elab.Deriving.Util"
      ]
    },
    "Lean.Elab.Deriving.ToExpr": {
      "path": "Lean/Elab/Deriving/ToExpr.olean",
      "imports": [
        "Lean.Elab.Deriving.Basic",
        "Lean.Elab.Deriving.Util"
      ]
    },
    "Lean.Elab.Deriving.TypeName": {
      "path": "Lean/Elab/Deriving/TypeName.olean",
      "imports": [
        "Lean.Elab.Deriving.Basic"
      ]
    },
    "Lean.Elab.Deriving.Util": {
      "path": "Lean/Elab/Deriving/Util.olean",
      "imports": [
        "Lean.Elab.Command",
        "Lean.Elab.DeclNameGen"
      ]
    },
    "Lean.Elab.Deriving": {
      "path": "Lean/Elab/Deriving.olean",
      "imports": [
        "Lean.Elab.Deriving.Basic",
        "Lean.Elab.Deriving.Util",
        "Lean.Elab.Deriving.Inhabited",
        "Lean.Elab.Deriving.Nonempty",
        "Lean.Elab.Deriving.TypeName",
        "Lean.Elab.Deriving.BEq",
        "Lean.Elab.Deriving.DecEq",
        "Lean.Elab.Deriving.Repr",
        "Lean.Elab.Deriving.FromToJson",
        "Lean.Elab.Deriving.SizeOf",
        "Lean.Elab.Deriving.Hashable",
        "Lean.Elab.Deriving.Ord",
        "Lean.Elab.Deriving.ToExpr",
        "Lean.Elab.Deriving.ReflBEq",
        "Lean.Elab.Deriving.LawfulBEq"
      ]
    },
    "Lean.Elab.Do.Basic": {
      "path": "Lean/Elab/Do/Basic.olean",
      "imports": [
        "Lean.Elab.Term.TermElabM",
        "Lean.Elab.Binders",
        "Lean.Meta.ProdN",
        "Lean.Parser.Do"
      ]
    },
    "Lean.Elab.Do.Legacy": {
      "path": "Lean/Elab/Do/Legacy.olean",
      "imports": [
        "Lean.Elab.BindersUtil",
        "Lean.Elab.PatternVar",
        "Lean.Elab.Quotation.Util",
        "Lean.Parser.Do"
      ]
    },
    "Lean.Elab.Do.Switch": {
      "path": "Lean/Elab/Do/Switch.olean",
      "imports": [
        "Init.System.IO",
        "Lean.Data.Options",
        "Lean.Elab.Term.TermElabM",
        "Lean.Elab.Do.Basic",
        "Lean.Elab.Do.Legacy",
        "Lean.Parser.Do"
      ]
    },
    "Lean.Elab.Do": {
      "path": "Lean/Elab/Do.olean",
      "imports": [
        "Lean.Elab.Do.Basic",
        "Lean.Elab.Do.Switch",
        "Lean.Elab.Do.Legacy"
      ]
    },
    "Lean.Elab.DocString.Builtin.Keywords": {
      "path": "Lean/Elab/DocString/Builtin/Keywords.olean",
      "imports": [
        "Lean.Elab.DocString.Builtin.Scopes",
        "Lean.Elab.DocString.Builtin.Postponed",
        "Lean.Elab.DocString.Builtin.Postponed",
        "Lean.DocString.Syntax",
        "Lean.Elab.InfoTree",
        "Lean.Elab.Open",
        "Lean.Parser",
        "Lean.Meta.Reduce",
        "Lean.Elab.Tactic.Doc",
        "Lean.Data.EditDistance"
      ]
    },
    "Lean.Elab.DocString.Builtin.Parsing": {
      "path": "Lean/Elab/DocString/Builtin/Parsing.olean",
      "imports": [
        "Lean.Elab.DocString",
        "Lean.Parser.Extension"
      ]
    },
    "Lean.Elab.DocString.Builtin.Postponed": {
      "path": "Lean/Elab/DocString/Builtin/Postponed.olean",
      "imports": [
        "Lean.Elab.Term.TermElabM",
        "Lean.Elab.DocString"
      ]
    },
    "Lean.Elab.DocString.Builtin.Scopes": {
      "path": "Lean/Elab/DocString/Builtin/Scopes.olean",
      "imports": [
        "Lean.Elab.DocString",
        "Lean.Elab.DocString.Builtin.Parsing"
      ]
    },
    "Lean.Elab.DocString.Builtin": {
      "path": "Lean/Elab/DocString/Builtin.olean",
      "imports": [
        "Lean.Elab.DocString.Builtin.Parsing",
        "Lean.Elab.DocString.Builtin.Scopes",
        "Lean.Elab.DocString.Builtin.Postponed",
        "Lean.Elab.Open",
        "Lean.Meta.Reduce",
        "Lean.Elab.Tactic.Doc",
        "Lean.Data.EditDistance",
        "Lean.Elab.DocString.Builtin.Keywords",
        "Lean.Server.InfoUtils"
      ]
    },
    "Lean.Elab.DocString": {
      "path": "Lean/Elab/DocString.olean",
      "imports": [
        "Std.Data.HashMap",
        "Lean.Elab.Term.TermElabM",
        "Lean.Elab.Command.Scope",
        "Lean.DocString.Syntax",
        "Lean.Meta.Hint",
        "Lean.BuiltinDocAttr"
      ]
    },
    "Lean.Elab.ElabRules": {
      "path": "Lean/Elab/ElabRules.olean",
      "imports": [
        "Lean.Elab.MacroArgUtil",
        "Lean.Elab.AuxDef",
        "Lean.Elab.Do.Basic",
        "Lean.Parser.Syntax"
      ]
    },
    "Lean.Elab.ErrorExplanation": {
      "path": "Lean/Elab/ErrorExplanation.olean",
      "imports": [
        "Lean.ErrorExplanation",
        "Lean.Widget.UserWidget"
      ]
    },
    "Lean.Elab.ErrorUtils": {
      "path": "Lean/Elab/ErrorUtils.olean",
      "imports": [
        "Lean.Message"
      ]
    },
    "Lean.Elab.Eval": {
      "path": "Lean/Elab/Eval.olean",
      "imports": [
        "Lean.Meta.Eval",
        "Lean.Elab.SyntheticMVars"
      ]
    },
    "Lean.Elab.Exception": {
      "path": "Lean/Elab/Exception.olean",
      "imports": [
        "Lean.Exception"
      ]
    },
    "Lean.Elab.Extra": {
      "path": "Lean/Elab/Extra.olean",
      "imports": [
        "Lean.Elab.App",
        "Lean.Elab.BuiltinNotation"
      ]
    },
    "Lean.Elab.Frontend": {
      "path": "Lean/Elab/Frontend.olean",
      "imports": [
        "Lean.Language.Lean",
        "Lean.Server.References",
        "Lean.Util.Profiler"
      ]
    },
    "Lean.Elab.GenInjective": {
      "path": "Lean/Elab/GenInjective.olean",
      "imports": [
        "Lean.Elab.Command",
        "Lean.Meta.Injective",
        "Lean.Meta.Constructions.CtorIdx"
      ]
    },
    "Lean.Elab.GuardMsgs": {
      "path": "Lean/Elab/GuardMsgs.olean",
      "imports": [
        "Lean.Elab.Notation",
        "Lean.Server.CodeActions.Attr"
      ]
    },
    "Lean.Elab.Import": {
      "path": "Lean/Elab/Import.olean",
      "imports": [
        "Lean.Parser.Module",
        "Lean.Parser.Module",
        "Lean.Compiler.ModPkgExt"
      ]
    },
    "Lean.Elab.Inductive": {
      "path": "Lean/Elab/Inductive.olean",
      "imports": [
        "Lean.Elab.MutualInductive",
        "Lean.Linter.Basic"
      ]
    },
    "Lean.Elab.InfoTree.InlayHints": {
      "path": "Lean/Elab/InfoTree/InlayHints.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Elab.InfoTree.Main": {
      "path": "Lean/Elab/InfoTree/Main.olean",
      "imports": [
        "Init.Task",
        "Lean.Meta.PPGoal",
        "Lean.ReservedNameAction"
      ]
    },
    "Lean.Elab.InfoTree.Types": {
      "path": "Lean/Elab/InfoTree/Types.olean",
      "imports": [
        "Lean.Data.DeclarationRange",
        "Lean.Data.OpenDecl",
        "Lean.MetavarContext",
        "Lean.Environment",
        "Lean.Widget.Types"
      ]
    },
    "Lean.Elab.InfoTree": {
      "path": "Lean/Elab/InfoTree.olean",
      "imports": [
        "Lean.Elab.InfoTree.Types",
        "Lean.Elab.InfoTree.Main"
      ]
    },
    "Lean.Elab.InfoTrees": {
      "path": "Lean/Elab/InfoTrees.olean",
      "imports": [
        "Lean.Elab.Command"
      ]
    },
    "Lean.Elab.InheritDoc": {
      "path": "Lean/Elab/InheritDoc.olean",
      "imports": [
        "Lean.DocString.Add"
      ]
    },
    "Lean.Elab.LetRec": {
      "path": "Lean/Elab/LetRec.olean",
      "imports": [
        "Lean.Elab.MutualDef"
      ]
    },
    "Lean.Elab.Level": {
      "path": "Lean/Elab/Level.olean",
      "imports": [
        "Lean.Parser.Level",
        "Lean.Elab.AutoBound"
      ]
    },
    "Lean.Elab.Macro": {
      "path": "Lean/Elab/Macro.olean",
      "imports": [
        "Lean.Elab.MacroArgUtil",
        "Lean.Parser.Syntax"
      ]
    },
    "Lean.Elab.MacroArgUtil": {
      "path": "Lean/Elab/MacroArgUtil.olean",
      "imports": [
        "Lean.Elab.Syntax"
      ]
    },
    "Lean.Elab.MacroRules": {
      "path": "Lean/Elab/MacroRules.olean",
      "imports": [
        "Lean.Elab.Syntax",
        "Lean.Elab.AuxDef"
      ]
    },
    "Lean.Elab.Match": {
      "path": "Lean/Elab/Match.olean",
      "imports": [
        "Lean.Meta.Match.Match",
        "Lean.Meta.GeneralizeVars",
        "Lean.Elab.BindersUtil",
        "Lean.Elab.PatternVar",
        "Lean.Elab.Quotation.Precheck",
        "Lean.Elab.SyntheticMVars",
        "Lean.Meta.Match.Value",
        "Lean.Meta.Match.NamedPatterns"
      ]
    },
    "Lean.Elab.MatchAltView": {
      "path": "Lean/Elab/MatchAltView.olean",
      "imports": [
        "Lean.Elab.Term"
      ]
    },
    "Lean.Elab.MatchExpr": {
      "path": "Lean/Elab/MatchExpr.olean",
      "imports": [
        "Lean.Elab.Term"
      ]
    },
    "Lean.Elab.Mixfix": {
      "path": "Lean/Elab/Mixfix.olean",
      "imports": [
        "Lean.Elab.Attributes"
      ]
    },
    "Lean.Elab.MutualDef": {
      "path": "Lean/Elab/MutualDef.olean",
      "imports": [
        "Lean.Elab.Deriving.Basic",
        "Lean.Elab.PreDefinition.Main",
        "all"
      ]
    },
    "Lean.Elab.MutualInductive": {
      "path": "Lean/Elab/MutualInductive.olean",
      "imports": [
        "Lean.Meta.Constructions",
        "Lean.Meta.SizeOf",
        "Lean.Meta.MkIffOfInductiveProp",
        "Lean.Elab.Coinductive",
        "Lean.Elab.Deriving.Basic",
        "Lean.Elab.ComputedFields",
        "Lean.Meta.Constructions.CtorIdx",
        "Lean.Meta.Constructions.CtorElim",
        "Lean.Meta.IndPredBelow",
        "Lean.Meta.Injective"
      ]
    },
    "Lean.Elab.Notation": {
      "path": "Lean/Elab/Notation.olean",
      "imports": [
        "Lean.Elab.Syntax",
        "Lean.Elab.AuxDef",
        "Lean.Elab.BuiltinNotation"
      ]
    },
    "Lean.Elab.Open": {
      "path": "Lean/Elab/Open.olean",
      "imports": [
        "Lean.Elab.Util",
        "Lean.Parser.Command",
        "Lean.Parser.Command"
      ]
    },
    "Lean.Elab.Parallel": {
      "path": "Lean/Elab/Parallel.olean",
      "imports": [
        "Lean.Elab.Task",
        "Init.System.IO"
      ]
    },
    "Lean.Elab.ParseImportsFast": {
      "path": "Lean/Elab/ParseImportsFast.olean",
      "imports": [
        "Lean.Parser.Module"
      ]
    },
    "Lean.Elab.PatternVar": {
      "path": "Lean/Elab/PatternVar.olean",
      "imports": [
        "Lean.Meta.Hint",
        "Lean.Elab.Arg",
        "Lean.Elab.MatchAltView"
      ]
    },
    "Lean.Elab.PreDefinition.Basic": {
      "path": "Lean/Elab/PreDefinition/Basic.olean",
      "imports": [
        "Lean.Compiler.NoncomputableAttr",
        "Lean.Util.NumApps",
        "Lean.Meta.Eqns",
        "Lean.Elab.RecAppSyntax",
        "Lean.Elab.DefView"
      ]
    },
    "Lean.Elab.PreDefinition.EqUnfold": {
      "path": "Lean/Elab/PreDefinition/EqUnfold.olean",
      "imports": [
        "Lean.Meta.Eqns",
        "Lean.Meta.Tactic.Rfl",
        "Lean.Meta.Tactic.Intro"
      ]
    },
    "Lean.Elab.PreDefinition.Eqns": {
      "path": "Lean/Elab/PreDefinition/Eqns.olean",
      "imports": [
        "Lean.Elab.PreDefinition.EqnsUtils",
        "Lean.Meta.Match.MatchEqsExt",
        "Lean.Meta.Match.NamedPatterns",
        "Lean.Meta.Tactic.Simp.Main",
        "Lean.Meta.Tactic.Split",
        "Lean.Meta.Tactic.CasesOnStuckLHS"
      ]
    },
    "Lean.Elab.PreDefinition.EqnsUtils": {
      "path": "Lean/Elab/PreDefinition/EqnsUtils.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.Tactic.Split",
        "Lean.Meta.Match.Match",
        "Lean.Meta.Tactic.Refl",
        "Lean.Meta.Tactic.Delta",
        "Lean.Meta.Tactic.SplitIf"
      ]
    },
    "Lean.Elab.PreDefinition.FixedParams": {
      "path": "Lean/Elab/PreDefinition/FixedParams.olean",
      "imports": [
        "Lean.Elab.PreDefinition.Basic"
      ]
    },
    "Lean.Elab.PreDefinition.Main": {
      "path": "Lean/Elab/PreDefinition/Main.olean",
      "imports": [
        "Lean.Util.SCC",
        "Lean.Elab.PreDefinition.Structural",
        "Lean.Elab.PreDefinition.WF.Main",
        "Lean.Elab.PreDefinition.PartialFixpoint"
      ]
    },
    "Lean.Elab.PreDefinition.MkInhabitant": {
      "path": "Lean/Elab/PreDefinition/MkInhabitant.olean",
      "imports": [
        "Lean.Meta.AppBuilder",
        "Lean.PrettyPrinter"
      ]
    },
    "Lean.Elab.PreDefinition.Mutual": {
      "path": "Lean/Elab/PreDefinition/Mutual.olean",
      "imports": [
        "Lean.Elab.PreDefinition.Basic"
      ]
    },
    "Lean.Elab.PreDefinition.PartialFixpoint.Eqns": {
      "path": "Lean/Elab/PreDefinition/PartialFixpoint/Eqns.olean",
      "imports": [
        "Lean.Elab.PreDefinition.FixedParams",
        "Lean.Elab.PreDefinition.EqnsUtils",
        "Lean.Meta.ArgsPacker.Basic",
        "Init.Internal.Order.Basic",
        "Lean.Elab.Tactic.Conv"
      ]
    },
    "Lean.Elab.PreDefinition.PartialFixpoint.Induction": {
      "path": "Lean/Elab/PreDefinition/PartialFixpoint/Induction.olean",
      "imports": [
        "Lean.Meta.Match.MatcherApp.Transform",
        "Lean.Meta.Injective",
        "Lean.Meta.ArgsPacker",
        "Lean.Elab.PreDefinition.PartialFixpoint.Eqns",
        "Lean.Meta.Tactic.ElimInfo",
        "Init.Internal.Order.Basic"
      ]
    },
    "Lean.Elab.PreDefinition.PartialFixpoint.Main": {
      "path": "Lean/Elab/PreDefinition/PartialFixpoint/Main.olean",
      "imports": [
        "Lean.Elab.PreDefinition.MkInhabitant",
        "Lean.Elab.PreDefinition.Mutual",
        "Lean.Elab.PreDefinition.PartialFixpoint.Eqns",
        "Lean.Elab.Tactic.Monotonicity",
        "Lean.Meta.Order"
      ]
    },
    "Lean.Elab.PreDefinition.PartialFixpoint": {
      "path": "Lean/Elab/PreDefinition/PartialFixpoint.olean",
      "imports": [
        "Lean.Elab.PreDefinition.PartialFixpoint.Eqns",
        "Lean.Elab.PreDefinition.PartialFixpoint.Main",
        "Lean.Elab.PreDefinition.PartialFixpoint.Induction"
      ]
    },
    "Lean.Elab.PreDefinition.Structural.BRecOn": {
      "path": "Lean/Elab/PreDefinition/Structural/BRecOn.olean",
      "imports": [
        "Lean.Util.HasConstCache",
        "Lean.Meta.PProdN",
        "Lean.Meta.Match.MatcherApp.Transform",
        "Lean.Elab.PreDefinition.Structural.Basic",
        "Lean.Elab.PreDefinition.Structural.RecArgInfo"
      ]
    },
    "Lean.Elab.PreDefinition.Structural.Basic": {
      "path": "Lean/Elab/PreDefinition/Structural/Basic.olean",
      "imports": [
        "Lean.Meta.ForEachExpr"
      ]
    },
    "Lean.Elab.PreDefinition.Structural.Eqns": {
      "path": "Lean/Elab/PreDefinition/Structural/Eqns.olean",
      "imports": [
        "Lean.Elab.PreDefinition.FixedParams",
        "Lean.Elab.PreDefinition.EqnsUtils",
        "Lean.Meta.Tactic.CasesOnStuckLHS",
        "Lean.Meta.Tactic.Delta",
        "Lean.Meta.Tactic.Simp.Main",
        "Lean.Meta.Tactic.Delta",
        "Lean.Meta.Tactic.CasesOnStuckLHS",
        "Lean.Meta.Tactic.Split"
      ]
    },
    "Lean.Elab.PreDefinition.Structural.FindRecArg": {
      "path": "Lean/Elab/PreDefinition/Structural/FindRecArg.olean",
      "imports": [
        "Lean.Elab.PreDefinition.TerminationMeasure",
        "Lean.Elab.PreDefinition.Structural.Basic",
        "Lean.Elab.PreDefinition.Structural.RecArgInfo"
      ]
    },
    "Lean.Elab.PreDefinition.Structural.IndGroupInfo": {
      "path": "Lean/Elab/PreDefinition/Structural/IndGroupInfo.olean",
      "imports": [
        "Lean.Meta.InferType"
      ]
    },
    "Lean.Elab.PreDefinition.Structural.IndPred": {
      "path": "Lean/Elab/PreDefinition/Structural/IndPred.olean",
      "imports": [
        "Lean.Elab.PreDefinition.Structural.Basic",
        "Lean.Elab.PreDefinition.Structural.RecArgInfo",
        "Lean.Util.HasConstCache",
        "Lean.Meta.IndPredBelow"
      ]
    },
    "Lean.Elab.PreDefinition.Structural.Main": {
      "path": "Lean/Elab/PreDefinition/Structural/Main.olean",
      "imports": [
        "Lean.Elab.PreDefinition.Mutual",
        "Lean.Elab.PreDefinition.Structural.FindRecArg",
        "Lean.Elab.PreDefinition.Structural.Preprocess",
        "Lean.Elab.PreDefinition.Structural.BRecOn",
        "Lean.Elab.PreDefinition.Structural.IndPred",
        "Lean.Elab.PreDefinition.Structural.Eqns",
        "Lean.Elab.PreDefinition.Structural.SmartUnfolding",
        "Lean.Meta.Tactic.TryThis"
      ]
    },
    "Lean.Elab.PreDefinition.Structural.Preprocess": {
      "path": "Lean/Elab/PreDefinition/Structural/Preprocess.olean",
      "imports": [
        "Lean.Elab.RecAppSyntax",
        "Lean.Meta.WHNF"
      ]
    },
    "Lean.Elab.PreDefinition.Structural.RecArgInfo": {
      "path": "Lean/Elab/PreDefinition/Structural/RecArgInfo.olean",
      "imports": [
        "Lean.Elab.PreDefinition.FixedParams",
        "Lean.Elab.PreDefinition.Structural.IndGroupInfo"
      ]
    },
    "Lean.Elab.PreDefinition.Structural.SmartUnfolding": {
      "path": "Lean/Elab/PreDefinition/Structural/SmartUnfolding.olean",
      "imports": [
        "Lean.Elab.PreDefinition.Basic",
        "Lean.Elab.PreDefinition.Structural.Basic"
      ]
    },
    "Lean.Elab.PreDefinition.Structural": {
      "path": "Lean/Elab/PreDefinition/Structural.olean",
      "imports": [
        "Lean.Elab.PreDefinition.Structural.Main"
      ]
    },
    "Lean.Elab.PreDefinition.TerminationHint": {
      "path": "Lean/Elab/PreDefinition/TerminationHint.olean",
      "imports": [
        "Lean.Parser.Term",
        "Lean.Parser.Term"
      ]
    },
    "Lean.Elab.PreDefinition.TerminationMeasure": {
      "path": "Lean/Elab/PreDefinition/TerminationMeasure.olean",
      "imports": [
        "Lean.Elab.Binders"
      ]
    },
    "Lean.Elab.PreDefinition.WF.Basic": {
      "path": "Lean/Elab/PreDefinition/WF/Basic.olean",
      "imports": [
        "Lean.Elab.Tactic.Basic"
      ]
    },
    "Lean.Elab.PreDefinition.WF.Eqns": {
      "path": "Lean/Elab/PreDefinition/WF/Eqns.olean",
      "imports": [
        "Lean.Elab.PreDefinition.FixedParams",
        "Lean.Meta.ArgsPacker.Basic",
        "Lean.Elab.PreDefinition.EqnsUtils",
        "Lean.Meta.Tactic.Rewrite",
        "Lean.Meta.Tactic.Split",
        "Lean.Elab.PreDefinition.Basic"
      ]
    },
    "Lean.Elab.PreDefinition.WF.Fix": {
      "path": "Lean/Elab/PreDefinition/WF/Fix.olean",
      "imports": [
        "Lean.Data.Array",
        "Lean.Elab.PreDefinition.Basic",
        "Lean.Elab.PreDefinition.WF.Basic",
        "Lean.Meta.ArgsPacker",
        "Lean.Meta.Match.MatcherApp.Transform",
        "Lean.Meta.Tactic.Cleanup",
        "Lean.Util.HasConstCache"
      ]
    },
    "Lean.Elab.PreDefinition.WF.FloatRecApp": {
      "path": "Lean/Elab/PreDefinition/WF/FloatRecApp.olean",
      "imports": [
        "Lean.Meta.Transform",
        "Lean.Elab.RecAppSyntax"
      ]
    },
    "Lean.Elab.PreDefinition.WF.GuessLex": {
      "path": "Lean/Elab/PreDefinition/WF/GuessLex.olean",
      "imports": [
        "Lean.Util.HasConstCache",
        "Lean.Meta.Match.MatcherApp.Transform",
        "Lean.Meta.Tactic.Cleanup",
        "Lean.Meta.Tactic.TryThis",
        "Lean.Meta.ArgsPacker",
        "Lean.Elab.PreDefinition.Mutual",
        "Lean.Elab.PreDefinition.Structural.Basic",
        "Lean.Elab.PreDefinition.TerminationMeasure",
        "Lean.Elab.PreDefinition.FixedParams",
        "Lean.Elab.PreDefinition.WF.Basic",
        "Lean.Data.Array",
        "Lean.Meta.Tactic.Refl"
      ]
    },
    "Lean.Elab.PreDefinition.WF.Main": {
      "path": "Lean/Elab/PreDefinition/WF/Main.olean",
      "imports": [
        "Lean.Elab.PreDefinition.WF.PackMutual",
        "Lean.Elab.PreDefinition.WF.FloatRecApp",
        "Lean.Elab.PreDefinition.WF.Rel",
        "Lean.Elab.PreDefinition.WF.Fix",
        "Lean.Elab.PreDefinition.WF.Unfold",
        "Lean.Elab.PreDefinition.WF.Preprocess",
        "Lean.Elab.PreDefinition.WF.GuessLex",
        "Lean.ExtraModUses"
      ]
    },
    "Lean.Elab.PreDefinition.WF.PackMutual": {
      "path": "Lean/Elab/PreDefinition/WF/PackMutual.olean",
      "imports": [
        "Lean.Meta.ArgsPacker",
        "Lean.Elab.PreDefinition.WF.Eqns"
      ]
    },
    "Lean.Elab.PreDefinition.WF.Preprocess": {
      "path": "Lean/Elab/PreDefinition/WF/Preprocess.olean",
      "imports": [
        "Lean.Elab.Tactic.Simp"
      ]
    },
    "Lean.Elab.PreDefinition.WF.Rel": {
      "path": "Lean/Elab/PreDefinition/WF/Rel.olean",
      "imports": [
        "Lean.Meta.Tactic.Rename",
        "Lean.Elab.PreDefinition.TerminationMeasure",
        "Lean.Elab.PreDefinition.FixedParams",
        "Lean.Meta.ArgsPacker"
      ]
    },
    "Lean.Elab.PreDefinition.WF.Unfold": {
      "path": "Lean/Elab/PreDefinition/WF/Unfold.olean",
      "imports": [
        "Lean.Elab.PreDefinition.Basic",
        "Lean.Meta.Tactic.Simp.Types",
        "Lean.Elab.PreDefinition.EqnsUtils",
        "Lean.Meta.Tactic.Split",
        "Lean.Meta.Tactic.Simp.Main",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs",
        "Lean.Meta.Tactic.Delta",
        "Lean.Meta.Tactic.Refl"
      ]
    },
    "Lean.Elab.PreDefinition.WF": {
      "path": "Lean/Elab/PreDefinition/WF.olean",
      "imports": [
        "Lean.Elab.PreDefinition.WF.Main",
        "Lean.Elab.PreDefinition.WF.Eqns"
      ]
    },
    "Lean.Elab.PreDefinition": {
      "path": "Lean/Elab/PreDefinition.olean",
      "imports": [
        "Lean.Elab.PreDefinition.Basic",
        "Lean.Elab.PreDefinition.Structural",
        "Lean.Elab.PreDefinition.Main",
        "Lean.Elab.PreDefinition.MkInhabitant",
        "Lean.Elab.PreDefinition.WF",
        "Lean.Elab.PreDefinition.EqnsUtils",
        "Lean.Elab.PreDefinition.Eqns",
        "Lean.Elab.PreDefinition.EqUnfold"
      ]
    },
    "Lean.Elab.Print": {
      "path": "Lean/Elab/Print.olean",
      "imports": [
        "Lean.Meta.Eqns",
        "Lean.Elab.Command",
        "Lean.PrettyPrinter.Delaborator.Builtins"
      ]
    },
    "Lean.Elab.Quotation.Precheck": {
      "path": "Lean/Elab/Quotation/Precheck.olean",
      "imports": [
        "Lean.Elab.Quotation.Util"
      ]
    },
    "Lean.Elab.Quotation.Util": {
      "path": "Lean/Elab/Quotation/Util.olean",
      "imports": [
        "Lean.Elab.Term"
      ]
    },
    "Lean.Elab.Quotation": {
      "path": "Lean/Elab/Quotation.olean",
      "imports": [
        "Lean.Elab.Quotation.Util",
        "Lean.Elab.Quotation.Precheck",
        "Lean.Elab.Syntax"
      ]
    },
    "Lean.Elab.RecAppSyntax": {
      "path": "Lean/Elab/RecAppSyntax.olean",
      "imports": [
        "Lean.Expr"
      ]
    },
    "Lean.Elab.RecommendedSpelling": {
      "path": "Lean/Elab/RecommendedSpelling.olean",
      "imports": [
        "Lean.Elab.Command",
        "Lean.ExtraModUses"
      ]
    },
    "Lean.Elab.SetOption": {
      "path": "Lean/Elab/SetOption.olean",
      "imports": [
        "Lean.Elab.InfoTree"
      ]
    },
    "Lean.Elab.StructInst": {
      "path": "Lean/Elab/StructInst.olean",
      "imports": [
        "Lean.Meta.Structure",
        "Lean.Elab.App",
        "Lean.Elab.StructInstHint"
      ]
    },
    "Lean.Elab.StructInstHint": {
      "path": "Lean/Elab/StructInstHint.olean",
      "imports": [
        "Lean.Meta.Hint"
      ]
    },
    "Lean.Elab.Structure": {
      "path": "Lean/Elab/Structure.olean",
      "imports": [
        "Lean.Meta.Structure",
        "Lean.Elab.MutualInductive",
        "Lean.Linter.Basic",
        "Lean.DocString",
        "Lean.DocString.Extension"
      ]
    },
    "Lean.Elab.Syntax": {
      "path": "Lean/Elab/Syntax.olean",
      "imports": [
        "Lean.Elab.Command",
        "Lean.Parser.Syntax",
        "Lean.Parser.Syntax",
        "Lean.ExtraModUses"
      ]
    },
    "Lean.Elab.SyntheticMVars": {
      "path": "Lean/Elab/SyntheticMVars.olean",
      "imports": [
        "Lean.Util.NumObjs",
        "Lean.Util.ForEachExpr",
        "Lean.Util.OccursCheck",
        "Lean.Elab.Tactic.Basic",
        "Lean.Meta.AbstractNestedProofs",
        "Init.Data.List.Sort.Basic",
        "all"
      ]
    },
    "Lean.Elab.Tactic.AsAuxLemma": {
      "path": "Lean/Elab/Tactic/AsAuxLemma.olean",
      "imports": [
        "Lean.Elab.Tactic.Meta"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.External": {
      "path": "Lean/Elab/Tactic/BVDecide/External.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Parser",
        "Lean.CoreM"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.Attr": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/Attr.olean",
      "imports": [
        "Lean.Elab.Tactic.Simp",
        "Std.Tactic.BVDecide.Syntax"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.BVCheck": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/BVCheck.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide",
        "Lean.Meta.Tactic.TryThis"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide.Reflect": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/BVDecide/Reflect.olean",
      "imports": [
        "Std.Data.HashMap",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic",
        "Lean.Meta.AppBuilder",
        "Lean.Data.RArray"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide.ReifiedBVExpr": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/BVDecide/ReifiedBVExpr.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide.Reflect",
        "Std.Tactic.BVDecide.Reflect"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide.ReifiedBVLogical": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/BVDecide/ReifiedBVLogical.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide.ReifiedBVPred"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide.ReifiedBVPred": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/BVDecide/ReifiedBVPred.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide.ReifiedBVExpr"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide.ReifiedLemmas": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/BVDecide/ReifiedLemmas.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide.ReifiedBVLogical"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide.Reify": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/BVDecide/Reify.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide.ReifiedLemmas"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide.SatAtBVLogical": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/BVDecide/SatAtBVLogical.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide.Reify"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/BVDecide.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide.SatAtBVLogical",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize",
        "Lean.Elab.Tactic.BVDecide.Frontend.LRAT"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.BVTrace": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/BVTrace.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.BVCheck"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.LRAT": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/LRAT.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.Attr",
        "Lean.Elab.Tactic.BVDecide.LRAT.Trim",
        "Lean.Elab.Tactic.BVDecide.External",
        "Std.Tactic.BVDecide.LRAT.Checker"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.AC": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/Normalize/AC.olean",
      "imports": [
        "Lean.Meta.Tactic.AC.Main",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Basic"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.AndFlatten": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/Normalize/AndFlatten.olean",
      "imports": [
        "Std.Tactic.BVDecide.Normalize.Bool",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Basic"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.ApplyControlFlow": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/Normalize/ApplyControlFlow.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Basic": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/Normalize/Basic.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.Attr"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.EmbeddedConstraint": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/Normalize/EmbeddedConstraint.olean",
      "imports": [
        "Std.Tactic.BVDecide.Normalize.Bool",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Basic"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Enums": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/Normalize/Enums.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Structures"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.IntToBitVec": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/Normalize/IntToBitVec.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Basic"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Rewrite": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/Normalize/Rewrite.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Basic"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.ShortCircuit": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/Normalize/ShortCircuit.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Basic",
        "Std.Tactic.BVDecide.Normalize.BitVec"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Simproc": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/Normalize/Simproc.olean",
      "imports": [
        "Std.Tactic.BVDecide.Normalize",
        "Lean.Elab.Tactic.BVDecide.Frontend.Attr"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Structures": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/Normalize/Structures.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.ApplyControlFlow",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.TypeAnalysis",
        "Lean.Meta.Injective"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.TypeAnalysis": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/Normalize/TypeAnalysis.olean",
      "imports": [
        "Std.Tactic.BVDecide.Normalize.BitVec",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Basic"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend.Normalize": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend/Normalize.olean",
      "imports": [
        "Lean.Elab.Tactic.FalseOrByContra",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Basic",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.ApplyControlFlow",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Simproc",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Rewrite",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.AndFlatten",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.EmbeddedConstraint",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.AC",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Structures",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.IntToBitVec",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.Enums",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.TypeAnalysis",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize.ShortCircuit"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.Frontend": {
      "path": "Lean/Elab/Tactic/BVDecide/Frontend.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.Frontend.Attr",
        "Lean.Elab.Tactic.BVDecide.Frontend.BVCheck",
        "Lean.Elab.Tactic.BVDecide.Frontend.BVDecide",
        "Lean.Elab.Tactic.BVDecide.Frontend.BVTrace",
        "Lean.Elab.Tactic.BVDecide.Frontend.LRAT",
        "Lean.Elab.Tactic.BVDecide.Frontend.Normalize"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.LRAT.Trim": {
      "path": "Lean/Elab/Tactic/BVDecide/LRAT/Trim.olean",
      "imports": [
        "Init.Data.Nat.Fold",
        "Std.Tactic.BVDecide.LRAT.Actions",
        "Std.Data.HashMap",
        "Init.Data.Range.Polymorphic"
      ]
    },
    "Lean.Elab.Tactic.BVDecide.LRAT": {
      "path": "Lean/Elab/Tactic/BVDecide/LRAT.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.LRAT.Trim"
      ]
    },
    "Lean.Elab.Tactic.BVDecide": {
      "path": "Lean/Elab/Tactic/BVDecide.olean",
      "imports": [
        "Lean.Elab.Tactic.BVDecide.LRAT",
        "Lean.Elab.Tactic.BVDecide.External",
        "Lean.Elab.Tactic.BVDecide.Frontend"
      ]
    },
    "Lean.Elab.Tactic.Basic": {
      "path": "Lean/Elab/Tactic/Basic.olean",
      "imports": [
        "Lean.Meta.Tactic.Util",
        "Lean.Elab.Term",
        "Lean.ExtraModUses"
      ]
    },
    "Lean.Elab.Tactic.BoolToPropSimps": {
      "path": "Lean/Elab/Tactic/BoolToPropSimps.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Attr"
      ]
    },
    "Lean.Elab.Tactic.BuiltinTactic": {
      "path": "Lean/Elab/Tactic/BuiltinTactic.olean",
      "imports": [
        "Lean.Meta.Diagnostics",
        "Lean.Meta.Tactic.Refl",
        "Lean.Elab.Binders",
        "Lean.Elab.Open",
        "Lean.Elab.Eval",
        "Lean.Elab.SetOption",
        "Lean.Elab.Tactic.ElabTerm",
        "Lean.Elab.Do",
        "Lean.Meta.Tactic.Replace",
        "Lean.Elab.Tactic.RenameInaccessibles",
        "Lean.Parser.Command"
      ]
    },
    "Lean.Elab.Tactic.Calc": {
      "path": "Lean/Elab/Tactic/Calc.olean",
      "imports": [
        "Lean.Elab.Calc",
        "Lean.Elab.Tactic.ElabTerm"
      ]
    },
    "Lean.Elab.Tactic.Change": {
      "path": "Lean/Elab/Tactic/Change.olean",
      "imports": [
        "Lean.Meta.Tactic.Replace",
        "Lean.Elab.Tactic.Location"
      ]
    },
    "Lean.Elab.Tactic.Classical": {
      "path": "Lean/Elab/Tactic/Classical.olean",
      "imports": [
        "Lean.Elab.Tactic.Basic"
      ]
    },
    "Lean.Elab.Tactic.Config": {
      "path": "Lean/Elab/Tactic/Config.olean",
      "imports": [
        "Lean.Meta.Eval",
        "Lean.Elab.SyntheticMVars",
        "Lean.Linter.MissingDocs",
        "Lean.Parser.Tactic"
      ]
    },
    "Lean.Elab.Tactic.ConfigSetter": {
      "path": "Lean/Elab/Tactic/ConfigSetter.olean",
      "imports": [
        "Lean.Elab.Command",
        "Lean.Elab.Term",
        "Lean.Elab.Command",
        "Lean.Data.KVMap"
      ]
    },
    "Lean.Elab.Tactic.Congr": {
      "path": "Lean/Elab/Tactic/Congr.olean",
      "imports": [
        "Lean.Meta.Tactic.Congr",
        "Lean.Elab.Tactic.Basic"
      ]
    },
    "Lean.Elab.Tactic.Conv.Basic": {
      "path": "Lean/Elab/Tactic/Conv/Basic.olean",
      "imports": [
        "Lean.Meta.Tactic.Replace",
        "Lean.Elab.Tactic.BuiltinTactic"
      ]
    },
    "Lean.Elab.Tactic.Conv.Change": {
      "path": "Lean/Elab/Tactic/Conv/Change.olean",
      "imports": [
        "Lean.Elab.Tactic.Change",
        "Lean.Elab.Tactic.Conv.Basic"
      ]
    },
    "Lean.Elab.Tactic.Conv.Congr": {
      "path": "Lean/Elab/Tactic/Conv/Congr.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Main",
        "Lean.Meta.Tactic.Congr",
        "Lean.Elab.Tactic.Conv.Basic"
      ]
    },
    "Lean.Elab.Tactic.Conv.Delta": {
      "path": "Lean/Elab/Tactic/Conv/Delta.olean",
      "imports": [
        "Lean.Elab.Tactic.Delta",
        "Lean.Elab.Tactic.Conv.Basic"
      ]
    },
    "Lean.Elab.Tactic.Conv.Lets": {
      "path": "Lean/Elab/Tactic/Conv/Lets.olean",
      "imports": [
        "Lean.Elab.Tactic.Lets",
        "Lean.Elab.Tactic.Conv.Basic"
      ]
    },
    "Lean.Elab.Tactic.Conv.Pattern": {
      "path": "Lean/Elab/Tactic/Conv/Pattern.olean",
      "imports": [
        "Lean.Elab.Tactic.Simp",
        "Lean.Elab.Tactic.Conv.Basic"
      ]
    },
    "Lean.Elab.Tactic.Conv.Rewrite": {
      "path": "Lean/Elab/Tactic/Conv/Rewrite.olean",
      "imports": [
        "Lean.Elab.Tactic.Rewrite",
        "Lean.Elab.Tactic.Conv.Basic"
      ]
    },
    "Lean.Elab.Tactic.Conv.Simp": {
      "path": "Lean/Elab/Tactic/Conv/Simp.olean",
      "imports": [
        "Lean.Elab.Tactic.Split",
        "Lean.Elab.Tactic.Conv.Basic",
        "Lean.Elab.Tactic.SimpTrace"
      ]
    },
    "Lean.Elab.Tactic.Conv.Unfold": {
      "path": "Lean/Elab/Tactic/Conv/Unfold.olean",
      "imports": [
        "Lean.Elab.Tactic.Unfold",
        "Lean.Elab.Tactic.Conv.Simp"
      ]
    },
    "Lean.Elab.Tactic.Conv": {
      "path": "Lean/Elab/Tactic/Conv.olean",
      "imports": [
        "Lean.Elab.Tactic.Conv.Basic",
        "Lean.Elab.Tactic.Conv.Congr",
        "Lean.Elab.Tactic.Conv.Rewrite",
        "Lean.Elab.Tactic.Conv.Change",
        "Lean.Elab.Tactic.Conv.Lets",
        "Lean.Elab.Tactic.Conv.Simp",
        "Lean.Elab.Tactic.Conv.Pattern",
        "Lean.Elab.Tactic.Conv.Delta",
        "Lean.Elab.Tactic.Conv.Unfold"
      ]
    },
    "Lean.Elab.Tactic.Delta": {
      "path": "Lean/Elab/Tactic/Delta.olean",
      "imports": [
        "Lean.Meta.Tactic.Delta",
        "Lean.Elab.Tactic.Location"
      ]
    },
    "Lean.Elab.Tactic.DiscrTreeKey": {
      "path": "Lean/Elab/Tactic/DiscrTreeKey.olean",
      "imports": [
        "Lean.Elab.Command",
        "Lean.Meta.Tactic.Simp.SimpTheorems"
      ]
    },
    "Lean.Elab.Tactic.Do.Attr": {
      "path": "Lean/Elab/Tactic/Do/Attr.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp",
        "Std.Tactic.Do.Syntax"
      ]
    },
    "Lean.Elab.Tactic.Do.LetElim": {
      "path": "Lean/Elab/Tactic/Do/LetElim.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.Assumption": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/Assumption.olean",
      "imports": [
        "Lean.Elab.Tactic.Do.ProofMode.Exact",
        "Lean.Meta.Tactic.Assumption"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.Basic": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/Basic.olean",
      "imports": [
        "Std.Tactic.Do.Syntax",
        "Lean.Elab.Tactic.Do.ProofMode.MGoal"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.Cases": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/Cases.olean",
      "imports": [
        "Lean.Elab.Tactic.Do.ProofMode.MGoal",
        "Std.Tactic.Do.Syntax",
        "Lean.Elab.Tactic.Do.ProofMode.Pure",
        "Lean.Elab.Tactic.Do.ProofMode.Intro",
        "Lean.Elab.Tactic.Do.ProofMode.Focus"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.Clear": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/Clear.olean",
      "imports": [
        "Std.Tactic.Do.Syntax",
        "Lean.Elab.Tactic.Do.ProofMode.Focus"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.Constructor": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/Constructor.olean",
      "imports": [
        "Std.Tactic.Do.Syntax",
        "Lean.Elab.Tactic.Do.ProofMode.MGoal"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.Delab": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/Delab.olean",
      "imports": [
        "Lean.Elab.Tactic.Do.ProofMode.MGoal",
        "Lean.PrettyPrinter.Delaborator.Basic",
        "Std.Do.SPred.Notation.Basic"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.Exact": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/Exact.olean",
      "imports": [
        "Lean.Elab.Tactic.Do.ProofMode.Basic",
        "Lean.Elab.Tactic.Do.ProofMode.Focus",
        "Lean.Elab.Tactic.ElabTerm"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.Exfalso": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/Exfalso.olean",
      "imports": [
        "Lean.Elab.Tactic.Do.ProofMode.Basic"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.Focus": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/Focus.olean",
      "imports": [
        "Lean.Elab.Tactic.Do.ProofMode.MGoal"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.Frame": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/Frame.olean",
      "imports": [
        "Std.Tactic.Do.Syntax",
        "Lean.Elab.Tactic.Do.ProofMode.Focus"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.Have": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/Have.olean",
      "imports": [
        "Std.Tactic.Do.Syntax",
        "Lean.Elab.Tactic.Basic",
        "Lean.Elab.Tactic.Do.ProofMode.Focus",
        "Lean.Elab.Tactic.Do.ProofMode.Cases",
        "Lean.Elab.Tactic.Do.ProofMode.Specialize"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.Intro": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/Intro.olean",
      "imports": [
        "Lean.Elab.Tactic.Do.ProofMode.Basic"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.LeftRight": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/LeftRight.olean",
      "imports": [
        "Std.Tactic.Do.Syntax",
        "Lean.Elab.Tactic.Do.ProofMode.MGoal"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.MGoal": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/MGoal.olean",
      "imports": [
        "Std.Do.SPred.DerivedLaws",
        "Std.Tactic.Do.ProofMode",
        "Lean.SubExpr",
        "Lean.Elab.Tactic.Basic"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.Pure": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/Pure.olean",
      "imports": [
        "Lean.Elab.Tactic.Basic",
        "Lean.Elab.Tactic.Do.ProofMode.MGoal",
        "Std.Tactic.Do.Syntax",
        "Lean.Elab.Tactic.Meta",
        "Lean.Elab.Tactic.Do.ProofMode.Basic",
        "Lean.Elab.Tactic.Do.ProofMode.Focus",
        "Lean.Meta.Tactic.Rfl"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.Refine": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/Refine.olean",
      "imports": [
        "Lean.Elab.Tactic.Do.ProofMode.Assumption"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.RenameI": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/RenameI.olean",
      "imports": [
        "Lean.Elab.Tactic.Do.ProofMode.Basic"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.Revert": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/Revert.olean",
      "imports": [
        "Lean.Elab.Tactic.Do.ProofMode.Focus",
        "Lean.Elab.Tactic.Do.ProofMode.Basic"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode.Specialize": {
      "path": "Lean/Elab/Tactic/Do/ProofMode/Specialize.olean",
      "imports": [
        "Lean.Elab.Tactic.ElabTerm",
        "Lean.Elab.Tactic.Do.ProofMode.MGoal",
        "Lean.Elab.Tactic.Do.ProofMode.Basic",
        "Lean.Elab.Tactic.Do.ProofMode.Focus",
        "Lean.Elab.Tactic.Do.ProofMode.Pure"
      ]
    },
    "Lean.Elab.Tactic.Do.ProofMode": {
      "path": "Lean/Elab/Tactic/Do/ProofMode.olean",
      "imports": [
        "Lean.Elab.Tactic.Do.ProofMode.MGoal",
        "Lean.Elab.Tactic.Do.ProofMode.Delab",
        "Lean.Elab.Tactic.Do.ProofMode.Basic",
        "Lean.Elab.Tactic.Do.ProofMode.Clear",
        "Lean.Elab.Tactic.Do.ProofMode.Intro",
        "Lean.Elab.Tactic.Do.ProofMode.Revert",
        "Lean.Elab.Tactic.Do.ProofMode.Exact",
        "Lean.Elab.Tactic.Do.ProofMode.Assumption",
        "Lean.Elab.Tactic.Do.ProofMode.Pure",
        "Lean.Elab.Tactic.Do.ProofMode.Frame",
        "Lean.Elab.Tactic.Do.ProofMode.LeftRight",
        "Lean.Elab.Tactic.Do.ProofMode.Constructor",
        "Lean.Elab.Tactic.Do.ProofMode.RenameI",
        "Lean.Elab.Tactic.Do.ProofMode.Specialize",
        "Lean.Elab.Tactic.Do.ProofMode.Cases",
        "Lean.Elab.Tactic.Do.ProofMode.Exfalso",
        "Lean.Elab.Tactic.Do.ProofMode.Have",
        "Lean.Elab.Tactic.Do.ProofMode.Refine"
      ]
    },
    "Lean.Elab.Tactic.Do.Spec": {
      "path": "Lean/Elab/Tactic/Do/Spec.olean",
      "imports": [
        "Lean.Elab.Tactic.Do.Attr",
        "Lean.Elab.Tactic.Do.ProofMode.MGoal",
        "Std.Tactic.Do.Syntax",
        "Lean.Elab.Tactic.Do.ProofMode.Intro",
        "Lean.Elab.Tactic.Do.ProofMode.Pure",
        "Lean.Elab.Tactic.Do.ProofMode.Frame",
        "Lean.Elab.Tactic.Do.ProofMode.Assumption"
      ]
    },
    "Lean.Elab.Tactic.Do.Syntax": {
      "path": "Lean/Elab/Tactic/Do/Syntax.olean",
      "imports": [
        "Lean.Elab.BuiltinNotation",
        "Std.Do.Triple.Basic",
        "Std.Do.SPred.Notation.Basic"
      ]
    },
    "Lean.Elab.Tactic.Do.VCGen.Basic": {
      "path": "Lean/Elab/Tactic/Do/VCGen/Basic.olean",
      "imports": [
        "Lean.Elab.Tactic.Simp",
        "Lean.Elab.Tactic.Do.Attr"
      ]
    },
    "Lean.Elab.Tactic.Do.VCGen.Split": {
      "path": "Lean/Elab/Tactic/Do/VCGen/Split.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Types",
        "Lean.Meta.Match.MatcherApp.Transform",
        "Lean.Data.Array",
        "Lean.Meta.Match.Rewrite",
        "Lean.Meta.Tactic.Simp.Rewrite",
        "Lean.Meta.Tactic.Assumption"
      ]
    },
    "Lean.Elab.Tactic.Do.VCGen.SuggestInvariant": {
      "path": "Lean/Elab/Tactic/Do/VCGen/SuggestInvariant.olean",
      "imports": [
        "Lean.Elab.Tactic.Basic",
        "Lean.Meta.Tactic.Simp.Types",
        "Lean.Meta.Tactic.Simp.Main",
        "Lean.Util.OccursCheck",
        "Lean.PrettyPrinter.Delaborator",
        "Lean.Elab.Tactic.Do.ProofMode.MGoal",
        "Std.Tactic.Do"
      ]
    },
    "Lean.Elab.Tactic.Do.VCGen": {
      "path": "Lean/Elab/Tactic/Do/VCGen.olean",
      "imports": [
        "Lean.Elab.Tactic.Do.VCGen.Split",
        "Lean.Elab.Tactic.Simp",
        "Lean.Elab.Tactic.Do.ProofMode.Revert",
        "Lean.Elab.Tactic.Do.ProofMode.Cases",
        "Lean.Elab.Tactic.Do.ProofMode.Specialize",
        "Lean.Elab.Tactic.Do.LetElim",
        "Lean.Elab.Tactic.Do.Spec",
        "Lean.Elab.Tactic.Do.Syntax",
        "Lean.Elab.Tactic.Induction",
        "Lean.Meta.Tactic.TryThis",
        "Lean.Elab.Tactic.Do.VCGen.Basic",
        "Lean.Elab.Tactic.Do.VCGen.SuggestInvariant"
      ]
    },
    "Lean.Elab.Tactic.Do": {
      "path": "Lean/Elab/Tactic/Do.olean",
      "imports": [
        "Lean.Elab.Tactic.Do.ProofMode",
        "Lean.Elab.Tactic.Do.Syntax",
        "Lean.Elab.Tactic.Do.Attr",
        "Lean.Elab.Tactic.Do.LetElim",
        "Lean.Elab.Tactic.Do.Spec",
        "Lean.Elab.Tactic.Do.VCGen"
      ]
    },
    "Lean.Elab.Tactic.Doc": {
      "path": "Lean/Elab/Tactic/Doc.olean",
      "imports": [
        "Lean.DocString",
        "Lean.Elab.Command"
      ]
    },
    "Lean.Elab.Tactic.ElabTerm": {
      "path": "Lean/Elab/Tactic/ElabTerm.olean",
      "imports": [
        "Lean.Meta.Tactic.Constructor",
        "Lean.Meta.Tactic.Assert",
        "Lean.Meta.Tactic.Cleanup",
        "Lean.Meta.Tactic.Rename",
        "Lean.Elab.Tactic.Config"
      ]
    },
    "Lean.Elab.Tactic.ExposeNames": {
      "path": "Lean/Elab/Tactic/ExposeNames.olean",
      "imports": [
        "Lean.Meta.Tactic.ExposeNames",
        "Lean.Elab.Tactic.Basic"
      ]
    },
    "Lean.Elab.Tactic.Ext": {
      "path": "Lean/Elab/Tactic/Ext.olean",
      "imports": [
        "Lean.Meta.Tactic.Ext",
        "Lean.Elab.Tactic.RCases",
        "Lean.Elab.Tactic.Repeat",
        "Lean.Elab.Tactic.BuiltinTactic",
        "Lean.Elab.Command",
        "Lean.Linter.Basic",
        "Lean.Expr",
        "Lean.Elab.Term.TermElabM"
      ]
    },
    "Lean.Elab.Tactic.FalseOrByContra": {
      "path": "Lean/Elab/Tactic/FalseOrByContra.olean",
      "imports": [
        "Lean.Elab.Tactic.Basic",
        "Lean.Meta.Tactic.Apply",
        "Lean.Meta.Tactic.Intro"
      ]
    },
    "Lean.Elab.Tactic.Generalize": {
      "path": "Lean/Elab/Tactic/Generalize.olean",
      "imports": [
        "Lean.Meta.Tactic.Generalize",
        "Lean.Elab.Binders",
        "Lean.Elab.Tactic.Location"
      ]
    },
    "Lean.Elab.Tactic.Grind.Anchor": {
      "path": "Lean/Elab/Tactic/Grind/Anchor.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types"
      ]
    },
    "Lean.Elab.Tactic.Grind.Annotated": {
      "path": "Lean/Elab/Tactic/Grind/Annotated.olean",
      "imports": [
        "Lean.Elab.Command",
        "Init.Grind.Annotated",
        "Std.Time.Format"
      ]
    },
    "Lean.Elab.Tactic.Grind.Basic": {
      "path": "Lean/Elab/Tactic/Grind/Basic.olean",
      "imports": [
        "Lean.Elab.Tactic.Basic",
        "Lean.Meta.Tactic.Grind.Main",
        "Lean.CoreM",
        "Lean.Meta.Tactic.Grind.Intro",
        "Lean.Meta.Tactic.Grind.PP"
      ]
    },
    "Lean.Elab.Tactic.Grind.BuiltinTactic": {
      "path": "Lean/Elab/Tactic/Grind/BuiltinTactic.olean",
      "imports": [
        "Lean.Elab.Tactic.Grind.Basic",
        "Lean.Meta.Tactic.TryThis",
        "Lean.Meta.Tactic.Grind.Solve",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Search",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Search",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.EqCnstr",
        "Lean.Meta.Tactic.Grind.AC.Eq",
        "Lean.Meta.Tactic.Grind.EMatch",
        "Lean.Meta.Tactic.Grind.EMatchTheorem",
        "Lean.Meta.Tactic.Grind.PP",
        "Lean.Meta.Tactic.Grind.Internalize",
        "Lean.Meta.Tactic.Grind.Intro",
        "Lean.Meta.Tactic.Grind.Split",
        "Lean.Meta.Tactic.Grind.Anchor",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.PP",
        "Lean.Meta.Tactic.Grind.Arith.Linear.PP",
        "Lean.Meta.Tactic.Grind.AC.PP",
        "Lean.Meta.Tactic.ExposeNames",
        "Lean.Elab.Tactic.Basic",
        "Lean.Elab.Tactic.RenameInaccessibles",
        "Lean.Elab.Tactic.Grind.Filter",
        "Lean.Elab.Tactic.Grind.Anchor",
        "Lean.Elab.Tactic.Grind.ShowState",
        "Lean.Elab.Tactic.Grind.Config",
        "Lean.Elab.Tactic.Grind.Param",
        "Lean.Elab.SetOption"
      ]
    },
    "Lean.Elab.Tactic.Grind.Config": {
      "path": "Lean/Elab/Tactic/Grind/Config.olean",
      "imports": [
        "Lean.Elab.Tactic.Grind.Basic",
        "Lean.Elab.Tactic.ConfigSetter"
      ]
    },
    "Lean.Elab.Tactic.Grind.Filter": {
      "path": "Lean/Elab/Tactic/Grind/Filter.olean",
      "imports": [
        "Lean.Elab.Tactic.Grind.Basic",
        "Lean.Meta.Tactic.Grind.Filter",
        "Init.Grind.Interactive"
      ]
    },
    "Lean.Elab.Tactic.Grind.Have": {
      "path": "Lean/Elab/Tactic/Grind/Have.olean",
      "imports": [
        "Lean.Elab.Tactic.Grind.Basic",
        "Lean.Meta.Tactic.Grind.Intro",
        "Lean.Meta.Tactic.Grind.RevertAll",
        "Lean.Elab.SyntheticMVars",
        "Lean.Meta.Tactic.Grind.Solve"
      ]
    },
    "Lean.Elab.Tactic.Grind.Lint": {
      "path": "Lean/Elab/Tactic/Grind/Lint.olean",
      "imports": [
        "Lean.Elab.Command",
        "Init.Grind.Lint",
        "Lean.Data.Name",
        "Lean.Meta.Tactic.Grind.EMatchTheorem",
        "Lean.EnvExtension",
        "Lean.Elab.Tactic.Grind.Config",
        "Lean.Meta.Tactic.TryThis",
        "Lean.PrettyPrinter"
      ]
    },
    "Lean.Elab.Tactic.Grind.LintExceptions": {
      "path": "Lean/Elab/Tactic/Grind/LintExceptions.olean",
      "imports": [
        "Init.Grind.Lint",
        "Lean.Elab.Tactic.Grind.Lint"
      ]
    },
    "Lean.Elab.Tactic.Grind.Main": {
      "path": "Lean/Elab/Tactic/Grind/Main.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Main",
        "Lean.Meta.Tactic.TryThis",
        "Lean.Elab.Command",
        "Lean.Elab.Tactic.Config",
        "Lean.LibrarySuggestions.Basic",
        "Lean.Meta.Tactic.Grind.SimpUtil",
        "Lean.Meta.Tactic.Grind.Util",
        "Lean.Meta.Tactic.Grind.EMatchTheoremParam",
        "Lean.Elab.Tactic.Grind.Basic",
        "Lean.Elab.Tactic.Grind.Param",
        "Lean.Meta.Tactic.Grind.Action",
        "Lean.Elab.Tactic.Grind.Trace",
        "Lean.Meta.Tactic.Grind.Finish",
        "Lean.Meta.Tactic.Grind.Attr",
        "Lean.Meta.Tactic.Grind.CollectParams",
        "Lean.Elab.MutualDef",
        "Lean.Meta.Tactic.Grind.Parser"
      ]
    },
    "Lean.Elab.Tactic.Grind.Param": {
      "path": "Lean/Elab/Tactic/Grind/Param.olean",
      "imports": [
        "Lean.Elab.Tactic.Grind.Basic",
        "Lean.Meta.Tactic.Grind.Main",
        "Lean.Meta.Tactic.Grind.Internalize",
        "Lean.Meta.Tactic.Grind.ForallProp",
        "Lean.Meta.Tactic.Grind.Main",
        "Lean.Elab.Tactic.Grind.Basic",
        "Lean.Elab.Tactic.Grind.Anchor",
        "Lean.Elab.SyntheticMVars"
      ]
    },
    "Lean.Elab.Tactic.Grind.ShowState": {
      "path": "Lean/Elab/Tactic/Grind/ShowState.olean",
      "imports": [
        "Lean.Elab.Tactic.Grind.Basic",
        "Lean.Elab.Tactic.Grind.Filter",
        "Lean.Meta.Tactic.Grind.PP",
        "Lean.Meta.Tactic.Grind.EMatchTheoremParam",
        "Lean.Meta.Tactic.Grind.Anchor",
        "Lean.Meta.Tactic.Grind.Split"
      ]
    },
    "Lean.Elab.Tactic.Grind.Trace": {
      "path": "Lean/Elab/Tactic/Grind/Trace.olean",
      "imports": [
        "Lean.Elab.Tactic.Grind.Basic",
        "Lean.Elab.Tactic.Grind.Config",
        "Lean.Elab.Tactic.Grind.Param",
        "Init.Grind.Interactive",
        "Lean.Meta.Tactic.TryThis",
        "Lean.Meta.Tactic.Grind.Finish",
        "Lean.Meta.Tactic.Grind.Split",
        "Lean.Meta.Tactic.Grind.CollectParams"
      ]
    },
    "Lean.Elab.Tactic.Grind": {
      "path": "Lean/Elab/Tactic/Grind.olean",
      "imports": [
        "Lean.Elab.Tactic.Grind.Main",
        "Lean.Elab.Tactic.Grind.Basic",
        "Lean.Elab.Tactic.Grind.BuiltinTactic",
        "Lean.Elab.Tactic.Grind.ShowState",
        "Lean.Elab.Tactic.Grind.Have",
        "Lean.Elab.Tactic.Grind.Trace",
        "Lean.Elab.Tactic.Grind.Config",
        "Lean.Elab.Tactic.Grind.Lint",
        "Lean.Elab.Tactic.Grind.LintExceptions",
        "Lean.Elab.Tactic.Grind.Annotated"
      ]
    },
    "Lean.Elab.Tactic.Guard": {
      "path": "Lean/Elab/Tactic/Guard.olean",
      "imports": [
        "Init.Guard",
        "Lean.Elab.Command",
        "Lean.Elab.Tactic.Conv.Basic"
      ]
    },
    "Lean.Elab.Tactic.Induction": {
      "path": "Lean/Elab/Tactic/Induction.olean",
      "imports": [
        "Lean.Parser.Tactic",
        "Lean.Meta.Tactic.ElimInfo",
        "Lean.Elab.Tactic.ElabTerm",
        "Lean.Meta.Tactic.FunIndCollect",
        "Lean.Elab.App",
        "Lean.Elab.Tactic.Generalize",
        "Lean.ErrorExplanations.InductionWithNoAlts"
      ]
    },
    "Lean.Elab.Tactic.Injection": {
      "path": "Lean/Elab/Tactic/Injection.olean",
      "imports": [
        "Lean.Meta.Tactic.Injection",
        "Lean.Meta.Tactic.Assumption",
        "Lean.Elab.Tactic.ElabTerm"
      ]
    },
    "Lean.Elab.Tactic.Lets": {
      "path": "Lean/Elab/Tactic/Lets.olean",
      "imports": [
        "Lean.Meta.Tactic.Lets",
        "Lean.Elab.Tactic.Location",
        "Lean.Elab.Binders",
        "Lean.Linter.Basic"
      ]
    },
    "Lean.Elab.Tactic.LibrarySearch": {
      "path": "Lean/Elab/Tactic/LibrarySearch.olean",
      "imports": [
        "Lean.Meta.Tactic.LibrarySearch",
        "Lean.Meta.Tactic.TryThis",
        "Lean.Elab.Tactic.ElabTerm",
        "Lean.Elab.Tactic.Config"
      ]
    },
    "Lean.Elab.Tactic.Location": {
      "path": "Lean/Elab/Tactic/Location.olean",
      "imports": [
        "Lean.Elab.Tactic.ElabTerm"
      ]
    },
    "Lean.Elab.Tactic.Match": {
      "path": "Lean/Elab/Tactic/Match.olean",
      "imports": [
        "Lean.Elab.Match",
        "Lean.Elab.Tactic.Induction"
      ]
    },
    "Lean.Elab.Tactic.Meta": {
      "path": "Lean/Elab/Tactic/Meta.olean",
      "imports": [
        "Lean.Elab.SyntheticMVars"
      ]
    },
    "Lean.Elab.Tactic.Monotonicity": {
      "path": "Lean/Elab/Tactic/Monotonicity.olean",
      "imports": [
        "Lean.Meta.Tactic.Split",
        "Lean.Elab.RecAppSyntax",
        "Lean.Elab.Tactic.Basic",
        "Init.Internal.Order"
      ]
    },
    "Lean.Elab.Tactic.NormCast": {
      "path": "Lean/Elab/Tactic/NormCast.olean",
      "imports": [
        "Lean.Meta.Tactic.NormCast",
        "Lean.Elab.Tactic.Conv.Simp"
      ]
    },
    "Lean.Elab.Tactic.Omega.Core": {
      "path": "Lean/Elab/Tactic/Omega/Core.olean",
      "imports": [
        "Lean.Elab.Tactic.Omega.OmegaM",
        "Lean.Elab.Tactic.Omega.MinNatAbs"
      ]
    },
    "Lean.Elab.Tactic.Omega.Frontend": {
      "path": "Lean/Elab/Tactic/Omega/Frontend.olean",
      "imports": [
        "Lean.Elab.Tactic.Omega.Core",
        "Lean.Elab.Tactic.FalseOrByContra",
        "Lean.Elab.Tactic.Config",
        "Lean.Meta.Tactic.Simp.Attr",
        "Lean.Elab.Tactic.BuiltinTactic"
      ]
    },
    "Lean.Elab.Tactic.Omega.MinNatAbs": {
      "path": "Lean/Elab/Tactic/Omega/MinNatAbs.olean",
      "imports": [
        "Init.Data.Int.Order",
        "Init.Data.List.MinMax",
        "Init.Data.Nat.Order"
      ]
    },
    "Lean.Elab.Tactic.Omega.OmegaM": {
      "path": "Lean/Elab/Tactic/Omega/OmegaM.olean",
      "imports": [
        "Lean.Meta.AppBuilder",
        "Lean.Meta.Canonicalizer"
      ]
    },
    "Lean.Elab.Tactic.Omega": {
      "path": "Lean/Elab/Tactic/Omega.olean",
      "imports": [
        "Lean.Elab.Tactic.Omega.Frontend"
      ]
    },
    "Lean.Elab.Tactic.RCases": {
      "path": "Lean/Elab/Tactic/RCases.olean",
      "imports": [
        "Lean.Elab.Tactic.ElabTerm",
        "Lean.Elab.Tactic.Induction",
        "Lean.Elab.Tactic.Generalize",
        "Lean.Meta.Tactic.Replace"
      ]
    },
    "Lean.Elab.Tactic.RenameInaccessibles": {
      "path": "Lean/Elab/Tactic/RenameInaccessibles.olean",
      "imports": [
        "Lean.Elab.Term",
        "Lean.Elab.Binders"
      ]
    },
    "Lean.Elab.Tactic.Repeat": {
      "path": "Lean/Elab/Tactic/Repeat.olean",
      "imports": [
        "Lean.Meta.Tactic.Repeat",
        "Lean.Elab.Tactic.Basic"
      ]
    },
    "Lean.Elab.Tactic.Rewrite": {
      "path": "Lean/Elab/Tactic/Rewrite.olean",
      "imports": [
        "Lean.Meta.Tactic.Rewrite",
        "Lean.Meta.Tactic.Replace",
        "Lean.Elab.Tactic.Location",
        "Lean.Meta.Eqns"
      ]
    },
    "Lean.Elab.Tactic.Rewrites": {
      "path": "Lean/Elab/Tactic/Rewrites.olean",
      "imports": [
        "Lean.Elab.Tactic.Location",
        "Lean.Meta.Tactic.Replace",
        "Lean.Meta.Tactic.Rewrites"
      ]
    },
    "Lean.Elab.Tactic.Rfl": {
      "path": "Lean/Elab/Tactic/Rfl.olean",
      "imports": [
        "Lean.Meta.Tactic.Rfl"
      ]
    },
    "Lean.Elab.Tactic.Show": {
      "path": "Lean/Elab/Tactic/Show.olean",
      "imports": [
        "Lean.Elab.Tactic.Change"
      ]
    },
    "Lean.Elab.Tactic.ShowTerm": {
      "path": "Lean/Elab/Tactic/ShowTerm.olean",
      "imports": [
        "Lean.Elab.ElabRules",
        "Lean.Meta.Tactic.TryThis"
      ]
    },
    "Lean.Elab.Tactic.Simp": {
      "path": "Lean/Elab/Tactic/Simp.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp",
        "Lean.Meta.Tactic.Simp.LoopProtection",
        "Lean.Elab.BuiltinNotation",
        "Lean.Elab.Tactic.Location"
      ]
    },
    "Lean.Elab.Tactic.SimpArith": {
      "path": "Lean/Elab/Tactic/SimpArith.olean",
      "imports": [
        "Lean.Elab.Tactic.Simp",
        "Lean.Meta.Tactic.TryThis"
      ]
    },
    "Lean.Elab.Tactic.SimpTrace": {
      "path": "Lean/Elab/Tactic/SimpTrace.olean",
      "imports": [
        "Lean.Elab.ElabRules",
        "Lean.Elab.Tactic.Simp",
        "Lean.Meta.Tactic.TryThis",
        "Lean.LibrarySuggestions.Basic"
      ]
    },
    "Lean.Elab.Tactic.Simpa": {
      "path": "Lean/Elab/Tactic/Simpa.olean",
      "imports": [
        "Lean.Meta.Tactic.TryThis",
        "Lean.Elab.Tactic.Simp",
        "Lean.Elab.App"
      ]
    },
    "Lean.Elab.Tactic.Simproc": {
      "path": "Lean/Elab/Tactic/Simproc.olean",
      "imports": [
        "Init.Simproc",
        "Lean.Meta.Tactic.Simp.Simproc",
        "Lean.Elab.Command"
      ]
    },
    "Lean.Elab.Tactic.SolveByElim": {
      "path": "Lean/Elab/Tactic/SolveByElim.olean",
      "imports": [
        "Lean.Meta.Tactic.SolveByElim",
        "Lean.Elab.Tactic.Config",
        "Lean.LibrarySuggestions.Basic"
      ]
    },
    "Lean.Elab.Tactic.Split": {
      "path": "Lean/Elab/Tactic/Split.olean",
      "imports": [
        "Lean.Meta.Hint",
        "Lean.Meta.Tactic.Split",
        "Lean.Elab.Tactic.Location"
      ]
    },
    "Lean.Elab.Tactic.Symm": {
      "path": "Lean/Elab/Tactic/Symm.olean",
      "imports": [
        "Lean.Meta.Tactic.Symm",
        "Lean.Elab.Tactic.Location"
      ]
    },
    "Lean.Elab.Tactic.TreeTacAttr": {
      "path": "Lean/Elab/Tactic/TreeTacAttr.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp"
      ]
    },
    "Lean.Elab.Tactic.Try": {
      "path": "Lean/Elab/Tactic/Try.olean",
      "imports": [
        "Lean.Meta.Tactic.ExposeNames",
        "Lean.Meta.Tactic.Try",
        "Lean.Elab.Tactic.SimpTrace",
        "Lean.Elab.Tactic.LibrarySearch",
        "Lean.Elab.Tactic.Grind.Main",
        "Lean.Elab.Parallel",
        "Lean.Elab.Command"
      ]
    },
    "Lean.Elab.Tactic.Unfold": {
      "path": "Lean/Elab/Tactic/Unfold.olean",
      "imports": [
        "Lean.Meta.Tactic.Unfold",
        "Lean.Elab.Tactic.Location"
      ]
    },
    "Lean.Elab.Tactic": {
      "path": "Lean/Elab/Tactic.olean",
      "imports": [
        "Lean.Elab.Tactic.Basic",
        "Lean.Elab.Tactic.ElabTerm",
        "Lean.Elab.Tactic.Induction",
        "Lean.Elab.Tactic.Generalize",
        "Lean.Elab.Tactic.Injection",
        "Lean.Elab.Tactic.Match",
        "Lean.Elab.Tactic.Rewrite",
        "Lean.Elab.Tactic.Location",
        "Lean.Elab.Tactic.SimpTrace",
        "Lean.Elab.Tactic.Simp",
        "Lean.Elab.Tactic.Simproc",
        "Lean.Elab.Tactic.BuiltinTactic",
        "Lean.Elab.Tactic.Split",
        "Lean.Elab.Tactic.Conv",
        "Lean.Elab.Tactic.Delta",
        "Lean.Elab.Tactic.Meta",
        "Lean.Elab.Tactic.Unfold",
        "Lean.Elab.Tactic.Calc",
        "Lean.Elab.Tactic.Congr",
        "Lean.Elab.Tactic.Guard",
        "Lean.Elab.Tactic.RCases",
        "Lean.Elab.Tactic.Repeat",
        "Lean.Elab.Tactic.Ext",
        "Lean.Elab.Tactic.Change",
        "Lean.Elab.Tactic.FalseOrByContra",
        "Lean.Elab.Tactic.Omega",
        "Lean.Elab.Tactic.Simpa",
        "Lean.Elab.Tactic.NormCast",
        "Lean.Elab.Tactic.Symm",
        "Lean.Elab.Tactic.SolveByElim",
        "Lean.Elab.Tactic.LibrarySearch",
        "Lean.Elab.Tactic.ShowTerm",
        "Lean.Elab.Tactic.Rfl",
        "Lean.Elab.Tactic.Rewrites",
        "Lean.Elab.Tactic.DiscrTreeKey",
        "Lean.Elab.Tactic.BVDecide",
        "Lean.Elab.Tactic.BoolToPropSimps",
        "Lean.Elab.Tactic.Classical",
        "Lean.Elab.Tactic.Grind",
        "Lean.Elab.Tactic.Monotonicity",
        "Lean.Elab.Tactic.Try",
        "Lean.Elab.Tactic.AsAuxLemma",
        "Lean.Elab.Tactic.TreeTacAttr",
        "Lean.Elab.Tactic.ExposeNames",
        "Lean.Elab.Tactic.SimpArith",
        "Lean.Elab.Tactic.Show",
        "Lean.Elab.Tactic.Lets",
        "Lean.Elab.Tactic.Do"
      ]
    },
    "Lean.Elab.Task": {
      "path": "Lean/Elab/Task.olean",
      "imports": [
        "Lean.Elab.Tactic.Basic"
      ]
    },
    "Lean.Elab.Term.TermElabM": {
      "path": "Lean/Elab/Term/TermElabM.olean",
      "imports": [
        "Lean.Meta.Coe",
        "Lean.Util.CollectLevelMVars",
        "Lean.Linter.Deprecated",
        "Lean.Elab.Attributes",
        "Lean.Elab.Config",
        "Lean.Elab.Level",
        "Lean.Elab.PreDefinition.TerminationHint",
        "Lean.Elab.DeclarationRange",
        "Lean.Elab.WhereFinally",
        "Lean.Elab.InfoTree.InlayHints",
        "Lean.Parser.Term"
      ]
    },
    "Lean.Elab.Term": {
      "path": "Lean/Elab/Term.olean",
      "imports": [
        "Lean.Elab.DeclModifiers",
        "Lean.Elab.Term.TermElabM"
      ]
    },
    "Lean.Elab.Time": {
      "path": "Lean/Elab/Time.olean",
      "imports": [
        "Lean.Elab.Command"
      ]
    },
    "Lean.Elab.Util": {
      "path": "Lean/Elab/Util.olean",
      "imports": [
        "Lean.Parser.Extension",
        "Lean.Parser.Command",
        "Lean.KeyedDeclsAttribute",
        "Lean.BuiltinDocAttr",
        "Lean.ExtraModUses",
        "all"
      ]
    },
    "Lean.Elab.WhereFinally": {
      "path": "Lean/Elab/WhereFinally.olean",
      "imports": [
        "Lean.Parser.Term"
      ]
    },
    "Lean.Elab": {
      "path": "Lean/Elab.olean",
      "imports": [
        "Lean.Elab.Import",
        "Lean.Elab.Exception",
        "Lean.Elab.Config",
        "Lean.Elab.Command",
        "Lean.Elab.Term",
        "Lean.Elab.App",
        "Lean.Elab.Binders",
        "Lean.Elab.BinderPredicates",
        "Lean.Elab.LetRec",
        "Lean.Elab.Frontend",
        "Lean.Elab.BuiltinNotation",
        "Lean.Elab.Declaration",
        "Lean.Elab.Tactic",
        "Lean.Elab.Match",
        "Lean.Elab.Quotation",
        "Lean.Elab.Syntax",
        "Lean.Elab.Do",
        "Lean.Elab.StructInst",
        "Lean.Elab.StructInstHint",
        "Lean.Elab.MutualInductive",
        "Lean.Elab.Inductive",
        "Lean.Elab.Structure",
        "Lean.Elab.Print",
        "Lean.Elab.MutualDef",
        "Lean.Elab.AuxDef",
        "Lean.Elab.PreDefinition",
        "Lean.Elab.Deriving",
        "Lean.Elab.DeclarationRange",
        "Lean.Elab.Extra",
        "Lean.Elab.GenInjective",
        "Lean.Elab.BuiltinTerm",
        "Lean.Elab.Arg",
        "Lean.Elab.PatternVar",
        "Lean.Elab.ElabRules",
        "Lean.Elab.Macro",
        "Lean.Elab.Notation",
        "Lean.Elab.Mixfix",
        "Lean.Elab.MacroRules",
        "Lean.Elab.BuiltinCommand",
        "Lean.Elab.AssertExists",
        "Lean.Elab.Command.WithWeakNamespace",
        "Lean.Elab.BuiltinEvalCommand",
        "Lean.Elab.RecAppSyntax",
        "Lean.Elab.Eval",
        "Lean.Elab.Calc",
        "Lean.Elab.InheritDoc",
        "Lean.Elab.ParseImportsFast",
        "Lean.Elab.GuardMsgs",
        "Lean.Elab.CheckTactic",
        "Lean.Elab.MatchExpr",
        "Lean.Elab.Tactic.Doc",
        "Lean.Elab.Time",
        "Lean.Elab.RecommendedSpelling",
        "Lean.Elab.InfoTrees",
        "Lean.Elab.ErrorExplanation",
        "Lean.Elab.DocString",
        "Lean.Elab.DocString.Builtin",
        "Lean.Elab.Parallel"
      ]
    },
    "Lean.EnvExtension": {
      "path": "Lean/EnvExtension.olean",
      "imports": [
        "Lean.Environment"
      ]
    },
    "Lean.Environment": {
      "path": "Lean/Environment.olean",
      "imports": [
        "Init.Data.Array.BinSearch",
        "Init.Data.Stream",
        "Init.System.Promise",
        "Lean.Data.NameTrie",
        "Lean.Setup",
        "Lean.LocalContext",
        "Lean.Util.Path",
        "Lean.Util.FindExpr",
        "Lean.Util.Profile",
        "Lean.Util.InstantiateLevelParams",
        "Lean.Util.FoldConsts",
        "Lean.PrivateName",
        "Lean.LoadDynlib",
        "Init.Dynamic",
        "Init.Data.Slice",
        "Init.Data.String.TakeDrop"
      ]
    },
    "Lean.ErrorExplanation": {
      "path": "Lean/ErrorExplanation.olean",
      "imports": [
        "Lean.Message",
        "Lean.EnvExtension",
        "Lean.DocString.Links",
        "Init.Data.String.TakeDrop",
        "Init.Data.String.Extra",
        "Init.Data.String.Search"
      ]
    },
    "Lean.ErrorExplanations.CtorResultingTypeMismatch": {
      "path": "Lean/ErrorExplanations/CtorResultingTypeMismatch.olean",
      "imports": [
        "Lean.ErrorExplanation",
        "Lean.ErrorExplanation"
      ]
    },
    "Lean.ErrorExplanations.DependsOnNoncomputable": {
      "path": "Lean/ErrorExplanations/DependsOnNoncomputable.olean",
      "imports": [
        "Lean.ErrorExplanation",
        "Lean.ErrorExplanation"
      ]
    },
    "Lean.ErrorExplanations.InductionWithNoAlts": {
      "path": "Lean/ErrorExplanations/InductionWithNoAlts.olean",
      "imports": [
        "Lean.ErrorExplanation",
        "Lean.ErrorExplanation"
      ]
    },
    "Lean.ErrorExplanations.InductiveParamMismatch": {
      "path": "Lean/ErrorExplanations/InductiveParamMismatch.olean",
      "imports": [
        "Lean.ErrorExplanation",
        "Lean.ErrorExplanation"
      ]
    },
    "Lean.ErrorExplanations.InductiveParamMissing": {
      "path": "Lean/ErrorExplanations/InductiveParamMissing.olean",
      "imports": [
        "Lean.ErrorExplanation",
        "Lean.ErrorExplanation"
      ]
    },
    "Lean.ErrorExplanations.InferBinderTypeFailed": {
      "path": "Lean/ErrorExplanations/InferBinderTypeFailed.olean",
      "imports": [
        "Lean.ErrorExplanation",
        "Lean.ErrorExplanation"
      ]
    },
    "Lean.ErrorExplanations.InferDefTypeFailed": {
      "path": "Lean/ErrorExplanations/InferDefTypeFailed.olean",
      "imports": [
        "Lean.ErrorExplanation",
        "Lean.ErrorExplanation"
      ]
    },
    "Lean.ErrorExplanations.InvalidDottedIdent": {
      "path": "Lean/ErrorExplanations/InvalidDottedIdent.olean",
      "imports": [
        "Lean.ErrorExplanation",
        "Lean.ErrorExplanation"
      ]
    },
    "Lean.ErrorExplanations.InvalidField": {
      "path": "Lean/ErrorExplanations/InvalidField.olean",
      "imports": [
        "Lean.ErrorExplanation",
        "Lean.ErrorExplanation"
      ]
    },
    "Lean.ErrorExplanations.ProjNonPropFromProp": {
      "path": "Lean/ErrorExplanations/ProjNonPropFromProp.olean",
      "imports": [
        "Lean.ErrorExplanation",
        "Lean.ErrorExplanation"
      ]
    },
    "Lean.ErrorExplanations.PropRecLargeElim": {
      "path": "Lean/ErrorExplanations/PropRecLargeElim.olean",
      "imports": [
        "Lean.ErrorExplanation",
        "Lean.ErrorExplanation"
      ]
    },
    "Lean.ErrorExplanations.RedundantMatchAlt": {
      "path": "Lean/ErrorExplanations/RedundantMatchAlt.olean",
      "imports": [
        "Lean.ErrorExplanation",
        "Lean.ErrorExplanation"
      ]
    },
    "Lean.ErrorExplanations.SynthInstanceFailed": {
      "path": "Lean/ErrorExplanations/SynthInstanceFailed.olean",
      "imports": [
        "Lean.ErrorExplanation",
        "Lean.ErrorExplanation"
      ]
    },
    "Lean.ErrorExplanations.UnknownIdentifier": {
      "path": "Lean/ErrorExplanations/UnknownIdentifier.olean",
      "imports": [
        "Lean.ErrorExplanation",
        "Lean.ErrorExplanation",
        "Std.Data.HashSet.Basic"
      ]
    },
    "Lean.ErrorExplanations": {
      "path": "Lean/ErrorExplanations.olean",
      "imports": [
        "Lean.ErrorExplanations.CtorResultingTypeMismatch",
        "Lean.ErrorExplanations.DependsOnNoncomputable",
        "Lean.ErrorExplanations.InductionWithNoAlts",
        "Lean.ErrorExplanations.InductiveParamMismatch",
        "Lean.ErrorExplanations.InductiveParamMissing",
        "Lean.ErrorExplanations.InferBinderTypeFailed",
        "Lean.ErrorExplanations.InferDefTypeFailed",
        "Lean.ErrorExplanations.InvalidDottedIdent",
        "Lean.ErrorExplanations.InvalidField",
        "Lean.ErrorExplanations.ProjNonPropFromProp",
        "Lean.ErrorExplanations.PropRecLargeElim",
        "Lean.ErrorExplanations.RedundantMatchAlt",
        "Lean.ErrorExplanations.SynthInstanceFailed",
        "Lean.ErrorExplanations.UnknownIdentifier"
      ]
    },
    "Lean.Exception": {
      "path": "Lean/Exception.olean",
      "imports": [
        "Lean.InternalExceptionId",
        "Lean.ErrorExplanations"
      ]
    },
    "Lean.Expr": {
      "path": "Lean/Expr.olean",
      "imports": [
        "Init.Data.Hashable",
        "Lean.Level"
      ]
    },
    "Lean.ExtraModUses": {
      "path": "Lean/ExtraModUses.olean",
      "imports": [
        "Lean.CoreM",
        "Lean.Compiler.MetaAttr",
        "Init.Data.Range.Polymorphic.Stream"
      ]
    },
    "Lean.HeadIndex": {
      "path": "Lean/HeadIndex.olean",
      "imports": [
        "Lean.Expr"
      ]
    },
    "Lean.Hygiene": {
      "path": "Lean/Hygiene.olean",
      "imports": [
        "Lean.Data.Format"
      ]
    },
    "Lean.IdentifierSuggestion": {
      "path": "Lean/IdentifierSuggestion.olean",
      "imports": [
        "Lean.Attributes",
        "Lean.Exception",
        "Lean.Meta.Hint",
        "Lean.Elab.DeclModifiers",
        "Lean.ResolveName",
        "all"
      ]
    },
    "Lean.ImportingFlag": {
      "path": "Lean/ImportingFlag.olean",
      "imports": [
        "Init.System.IO"
      ]
    },
    "Lean.InternalExceptionId": {
      "path": "Lean/InternalExceptionId.olean",
      "imports": [
        "Init.System.IO",
        "Init.Data.ToString.Name"
      ]
    },
    "Lean.KeyedDeclsAttribute": {
      "path": "Lean/KeyedDeclsAttribute.olean",
      "imports": [
        "Lean.ScopedEnvExtension",
        "Lean.Compiler.InitAttr",
        "Lean.Compiler.IR.CompilerM",
        "Lean.ExtraModUses"
      ]
    },
    "Lean.LabelAttribute": {
      "path": "Lean/LabelAttribute.olean",
      "imports": [
        "Lean.DocString",
        "Init.Data.String.Extra",
        "Init.Data.ToString.Name"
      ]
    },
    "Lean.Language.Basic": {
      "path": "Lean/Language/Basic.olean",
      "imports": [
        "Lean.Parser.Types",
        "Lean.Util.Trace"
      ]
    },
    "Lean.Language.Lean.Types": {
      "path": "Lean/Language/Lean/Types.olean",
      "imports": [
        "Lean.Elab.Command"
      ]
    },
    "Lean.Language.Lean": {
      "path": "Lean/Language/Lean.olean",
      "imports": [
        "Lean.Language.Util",
        "Lean.Language.Lean.Types",
        "Lean.Elab.Import"
      ]
    },
    "Lean.Language.Util": {
      "path": "Lean/Language/Util.olean",
      "imports": [
        "Lean.Elab.InfoTree"
      ]
    },
    "Lean.Level": {
      "path": "Lean/Level.olean",
      "imports": [
        "Init.Data.Array.QSort",
        "Lean.Data.PersistentHashSet",
        "Lean.Hygiene",
        "Init.Data.Option.Coe"
      ]
    },
    "Lean.LibrarySuggestions.Basic": {
      "path": "Lean/LibrarySuggestions/Basic.olean",
      "imports": [
        "Lean.Elab.Command",
        "Lean.Meta.Eval",
        "Lean.Meta.CompletionName",
        "Lean.Linter.Deprecated",
        "Init.Data.Random",
        "Lean.Elab.Tactic.Grind.Annotated"
      ]
    },
    "Lean.LibrarySuggestions.Default": {
      "path": "Lean/LibrarySuggestions/Default.olean",
      "imports": [
        "Lean.LibrarySuggestions.Basic",
        "Lean.LibrarySuggestions.SineQuaNon",
        "all"
      ]
    },
    "Lean.LibrarySuggestions.MePo": {
      "path": "Lean/LibrarySuggestions/MePo.olean",
      "imports": [
        "Lean.LibrarySuggestions.Basic",
        "Lean.LibrarySuggestions.SymbolFrequency",
        "Lean.Meta.Basic"
      ]
    },
    "Lean.LibrarySuggestions.SineQuaNon": {
      "path": "Lean/LibrarySuggestions/SineQuaNon.olean",
      "imports": [
        "Lean.CoreM",
        "Lean.Meta.Basic",
        "Lean.Meta.Instances",
        "Lean.LibrarySuggestions.SymbolFrequency",
        "Lean.LibrarySuggestions.Basic"
      ]
    },
    "Lean.LibrarySuggestions.SymbolFrequency": {
      "path": "Lean/LibrarySuggestions/SymbolFrequency.olean",
      "imports": [
        "Lean.CoreM",
        "Lean.Meta.Basic",
        "Lean.Meta.InferType",
        "Lean.Meta.FunInfo",
        "Lean.AddDecl",
        "Lean.LibrarySuggestions.Basic"
      ]
    },
    "Lean.LibrarySuggestions": {
      "path": "Lean/LibrarySuggestions.olean",
      "imports": [
        "Lean.LibrarySuggestions.Basic",
        "Lean.LibrarySuggestions.SymbolFrequency",
        "Lean.LibrarySuggestions.MePo",
        "Lean.LibrarySuggestions.SineQuaNon",
        "Lean.LibrarySuggestions.Default"
      ]
    },
    "Lean.Linter.Basic": {
      "path": "Lean/Linter/Basic.olean",
      "imports": [
        "Lean.MonadEnv"
      ]
    },
    "Lean.Linter.Builtin": {
      "path": "Lean/Linter/Builtin.olean",
      "imports": [
        "Lean.Linter.Util",
        "Lean.Elab.Command"
      ]
    },
    "Lean.Linter.Coe": {
      "path": "Lean/Linter/Coe.olean",
      "imports": [
        "Lean.Elab.Command",
        "Lean.Server.InfoUtils",
        "Lean.Linter.Basic",
        "Lean.Linter.Deprecated",
        "all"
      ]
    },
    "Lean.Linter.ConstructorAsVariable": {
      "path": "Lean/Linter/ConstructorAsVariable.olean",
      "imports": [
        "Lean.Elab.Command",
        "Lean.Linter.Util"
      ]
    },
    "Lean.Linter.Deprecated": {
      "path": "Lean/Linter/Deprecated.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Linter.Basic",
        "Lean.Elab.InfoTree.Main",
        "Lean.ExtraModUses"
      ]
    },
    "Lean.Linter.DocsOnAlt": {
      "path": "Lean/Linter/DocsOnAlt.olean",
      "imports": [
        "Lean.Parser.Syntax",
        "Lean.Data.Options",
        "Lean.Elab.Command",
        "Lean.Linter.Basic",
        "Lean.Server.InfoUtils"
      ]
    },
    "Lean.Linter.List": {
      "path": "Lean/Linter/List.olean",
      "imports": [
        "Lean.Elab.Command",
        "Lean.Server.InfoUtils",
        "Lean.Linter.Basic"
      ]
    },
    "Lean.Linter.MissingDocs": {
      "path": "Lean/Linter/MissingDocs.olean",
      "imports": [
        "Lean.Parser.Syntax",
        "Lean.Meta.Tactic.Simp.RegisterCommand",
        "Lean.Elab.Command",
        "Lean.Linter.Util"
      ]
    },
    "Lean.Linter.Omit": {
      "path": "Lean/Linter/Omit.olean",
      "imports": [
        "Lean.Elab.Command",
        "Lean.Linter.Util"
      ]
    },
    "Lean.Linter.Sets": {
      "path": "Lean/Linter/Sets.olean",
      "imports": [
        "Lean.Linter.Basic",
        "Lean.Elab.Command"
      ]
    },
    "Lean.Linter.UnusedSimpArgs": {
      "path": "Lean/Linter/UnusedSimpArgs.olean",
      "imports": [
        "Lean.Elab.Command",
        "Lean.Elab.Tactic.Simp",
        "Lean.Linter.Util"
      ]
    },
    "Lean.Linter.UnusedVariables": {
      "path": "Lean/Linter/UnusedVariables.olean",
      "imports": [
        "Lean.Elab.Command",
        "Lean.Linter.Util"
      ]
    },
    "Lean.Linter.Util": {
      "path": "Lean/Linter/Util.olean",
      "imports": [
        "Lean.Server.InfoUtils",
        "Lean.Linter.Basic"
      ]
    },
    "Lean.Linter": {
      "path": "Lean/Linter.olean",
      "imports": [
        "Lean.Linter.Util",
        "Lean.Linter.Builtin",
        "Lean.Linter.ConstructorAsVariable",
        "Lean.Linter.Deprecated",
        "Lean.Linter.DocsOnAlt",
        "Lean.Linter.UnusedVariables",
        "Lean.Linter.MissingDocs",
        "Lean.Linter.Omit",
        "Lean.Linter.List",
        "Lean.Linter.Sets",
        "Lean.Linter.UnusedSimpArgs",
        "Lean.Linter.Coe"
      ]
    },
    "Lean.LoadDynlib": {
      "path": "Lean/LoadDynlib.olean",
      "imports": [
        "Init.System.IO",
        "Init.Data.String.TakeDrop"
      ]
    },
    "Lean.LocalContext": {
      "path": "Lean/LocalContext.olean",
      "imports": [
        "Init.Data.Nat.Control",
        "Lean.Data.PersistentArray",
        "Lean.Expr"
      ]
    },
    "Lean.Log": {
      "path": "Lean/Log.olean",
      "imports": [
        "Lean.ErrorExplanations",
        "{"
      ]
    },
    "Lean.Message": {
      "path": "Lean/Message.olean",
      "imports": [
        "Init.Data.Slice.Array",
        "Lean.Util.PPExt",
        "Lean.Util.Sorry",
        "Init.Data.String.Search"
      ]
    },
    "Lean.Meta.ACLt": {
      "path": "Lean/Meta/ACLt.olean",
      "imports": [
        "Lean.Meta.DiscrTree"
      ]
    },
    "Lean.Meta.AbstractMVars": {
      "path": "Lean/Meta/AbstractMVars.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.AbstractNestedProofs": {
      "path": "Lean/Meta/AbstractNestedProofs.olean",
      "imports": [
        "Init.Grind.Util",
        "Lean.Meta.Closure",
        "Lean.Meta.Transform"
      ]
    },
    "Lean.Meta.AppBuilder": {
      "path": "Lean/Meta/AppBuilder.olean",
      "imports": [
        "Lean.Meta.SynthInstance",
        "Lean.Meta.DecLevel",
        "Lean.Meta.SameCtorUtils",
        "Lean.Data.Array"
      ]
    },
    "Lean.Meta.ArgsPacker.Basic": {
      "path": "Lean/Meta/ArgsPacker/Basic.olean",
      "imports": [
        "Init.Data.Array.Basic"
      ]
    },
    "Lean.Meta.ArgsPacker": {
      "path": "Lean/Meta/ArgsPacker.olean",
      "imports": [
        "Lean.Meta.AppBuilder",
        "Lean.Meta.PProdN",
        "Lean.Meta.ArgsPacker.Basic"
      ]
    },
    "Lean.Meta.Basic": {
      "path": "Lean/Meta/Basic.olean",
      "imports": [
        "Lean.Data.LOption",
        "Lean.Class",
        "Lean.ReducibilityAttrs",
        "Lean.Util.MonadBacktrack",
        "Lean.Compiler.InlineAttrs",
        "Lean.Meta.TransparencyMode",
        "Lean",
        "Lean"
      ]
    },
    "Lean.Meta.BinderNameHint": {
      "path": "Lean/Meta/BinderNameHint.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.Canonicalizer": {
      "path": "Lean/Meta/Canonicalizer.olean",
      "imports": [
        "Lean.Util.ShareCommon",
        "Lean.Meta.FunInfo",
        "Std.Data.HashMap.Raw"
      ]
    },
    "Lean.Meta.CasesInfo": {
      "path": "Lean/Meta/CasesInfo.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.AuxRecursor"
      ]
    },
    "Lean.Meta.Check": {
      "path": "Lean/Meta/Check.olean",
      "imports": [
        "Lean.Meta.Sorry",
        "Lean.AddDecl"
      ]
    },
    "Lean.Meta.CheckTactic": {
      "path": "Lean/Meta/CheckTactic.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.Closure": {
      "path": "Lean/Meta/Closure.olean",
      "imports": [
        "Lean.Meta.Check",
        "Lean.Meta.Tactic.AuxLemma",
        "Lean.Util.ForEachExpr"
      ]
    },
    "Lean.Meta.Coe": {
      "path": "Lean/Meta/Coe.olean",
      "imports": [
        "Lean.Meta.AppBuilder",
        "Lean.ExtraModUses"
      ]
    },
    "Lean.Meta.CoeAttr": {
      "path": "Lean/Meta/CoeAttr.olean",
      "imports": [
        "Lean.Meta.FunInfo"
      ]
    },
    "Lean.Meta.CollectFVars": {
      "path": "Lean/Meta/CollectFVars.olean",
      "imports": [
        "Lean.Util.CollectFVars",
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.CollectMVars": {
      "path": "Lean/Meta/CollectMVars.olean",
      "imports": [
        "Lean.Util.CollectMVars",
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.CompletionName": {
      "path": "Lean/Meta/CompletionName.olean",
      "imports": [
        "Lean.Meta.Match.MatcherInfo"
      ]
    },
    "Lean.Meta.CongrTheorems": {
      "path": "Lean/Meta/CongrTheorems.olean",
      "imports": [
        "Lean.AddDecl",
        "Lean.ReservedNameAction",
        "Lean.Meta.Tactic.Subst"
      ]
    },
    "Lean.Meta.Constructions.BRecOn": {
      "path": "Lean/Meta/Constructions/BRecOn.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.CompletionName",
        "Lean.Meta.PProdN",
        "Lean.Meta.Tactic.Cases",
        "Lean.Meta.Tactic.Refl"
      ]
    },
    "Lean.Meta.Constructions.CasesOn": {
      "path": "Lean/Meta/Constructions/CasesOn.olean",
      "imports": [
        "Lean.AddDecl"
      ]
    },
    "Lean.Meta.Constructions.CasesOnSameCtor": {
      "path": "Lean/Meta/Constructions/CasesOnSameCtor.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.CompletionName",
        "Lean.Meta.Constructions.CtorIdx",
        "Lean.Meta.Constructions.CtorElim",
        "Lean.Elab.App",
        "Lean.Meta.SameCtorUtils"
      ]
    },
    "Lean.Meta.Constructions.CtorElim": {
      "path": "Lean/Meta/Constructions/CtorElim.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.CompletionName",
        "Lean.Meta.Constructions.CtorIdx",
        "Lean.Meta.NatTable",
        "Lean.Elab.App",
        "Lean.Meta.Tactic.Simp.Attr"
      ]
    },
    "Lean.Meta.Constructions.CtorIdx": {
      "path": "Lean/Meta/Constructions/CtorIdx.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.AddDecl",
        "Lean.Meta.AppBuilder",
        "Lean.Meta.CompletionName",
        "Lean.Linter.Deprecated"
      ]
    },
    "Lean.Meta.Constructions.NoConfusion": {
      "path": "Lean/Meta/Constructions/NoConfusion.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.AddDecl",
        "Lean.Meta.AppBuilder",
        "Lean.Meta.CompletionName",
        "Lean.Meta.Constructions.CtorIdx",
        "Lean.Meta.Constructions.CtorElim",
        "Lean.Meta.Tactic.Subst"
      ]
    },
    "Lean.Meta.Constructions.RecOn": {
      "path": "Lean/Meta/Constructions/RecOn.olean",
      "imports": [
        "Lean.AddDecl",
        "Lean.Meta.CompletionName"
      ]
    },
    "Lean.Meta.Constructions.SparseCasesOn": {
      "path": "Lean/Meta/Constructions/SparseCasesOn.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.AddDecl",
        "Lean.Meta.Constructions.CtorIdx",
        "Lean.Meta.AppBuilder",
        "Lean.Meta.HasNotBit"
      ]
    },
    "Lean.Meta.Constructions.SparseCasesOnEq": {
      "path": "Lean/Meta/Constructions/SparseCasesOnEq.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.AddDecl",
        "Lean.Meta.Constructions.SparseCasesOn",
        "Lean.Meta.AppBuilder",
        "Lean.Meta.HasNotBit",
        "Lean.Meta.Tactic.Util",
        "Lean.Meta.Tactic.Cases",
        "Lean.Meta.Tactic.Refl"
      ]
    },
    "Lean.Meta.Constructions": {
      "path": "Lean/Meta/Constructions.olean",
      "imports": [
        "Lean.Meta.Constructions.CasesOn",
        "Lean.Meta.Constructions.NoConfusion",
        "Lean.Meta.Constructions.RecOn",
        "Lean.Meta.Constructions.BRecOn",
        "Lean.Meta.Constructions.CasesOnSameCtor",
        "Lean.Meta.Constructions.SparseCasesOn",
        "Lean.Meta.Constructions.SparseCasesOnEq"
      ]
    },
    "Lean.Meta.CtorIdxHInj": {
      "path": "Lean/Meta/CtorIdxHInj.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.Tactic.Refl",
        "Lean.Meta.Tactic.Cases",
        "Lean.Meta.Tactic.Assumption",
        "Lean.Meta.Tactic.Simp.Main",
        "Lean.Meta.SameCtorUtils",
        "Lean.Meta.Constructions.CtorIdx"
      ]
    },
    "Lean.Meta.CtorRecognizer": {
      "path": "Lean/Meta/CtorRecognizer.olean",
      "imports": [
        "Lean.Meta.LitValues",
        "Lean.Meta.Offset"
      ]
    },
    "Lean.Meta.DecLevel": {
      "path": "Lean/Meta/DecLevel.olean",
      "imports": [
        "Lean.Meta.InferType"
      ]
    },
    "Lean.Meta.Diagnostics": {
      "path": "Lean/Meta/Diagnostics.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.PrettyPrinter"
      ]
    },
    "Lean.Meta.DiscrTree": {
      "path": "Lean/Meta/DiscrTree.olean",
      "imports": [
        "Lean.Meta.WHNF",
        "Lean.Meta.DiscrTreeTypes"
      ]
    },
    "Lean.Meta.DiscrTreeTypes": {
      "path": "Lean/Meta/DiscrTreeTypes.olean",
      "imports": [
        "Lean.ToExpr"
      ]
    },
    "Lean.Meta.Eqns": {
      "path": "Lean/Meta/Eqns.olean",
      "imports": [
        "Lean.Meta.Match.MatcherInfo",
        "Lean.DefEqAttrib",
        "Lean.Meta.LetToHave",
        "Lean.Meta.AppBuilder"
      ]
    },
    "Lean.Meta.Eval": {
      "path": "Lean/Meta/Eval.olean",
      "imports": [
        "Lean.AddDecl",
        "Lean.Meta.Check",
        "Lean.Util.CollectLevelParams"
      ]
    },
    "Lean.Meta.ExprDefEq": {
      "path": "Lean/Meta/ExprDefEq.olean",
      "imports": [
        "Lean.Meta.UnificationHint",
        "Lean.Util.OccursCheck"
      ]
    },
    "Lean.Meta.ExprLens": {
      "path": "Lean/Meta/ExprLens.olean",
      "imports": [
        "Lean.SubExpr"
      ]
    },
    "Lean.Meta.ExprTraverse": {
      "path": "Lean/Meta/ExprTraverse.olean",
      "imports": [
        "Lean.SubExpr"
      ]
    },
    "Lean.Meta.ForEachExpr": {
      "path": "Lean/Meta/ForEachExpr.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.FunInfo": {
      "path": "Lean/Meta/FunInfo.olean",
      "imports": [
        "Lean.Meta.InferType"
      ]
    },
    "Lean.Meta.GeneralizeTelescope": {
      "path": "Lean/Meta/GeneralizeTelescope.olean",
      "imports": [
        "Lean.Meta.KAbstract",
        "Lean.Meta.Check"
      ]
    },
    "Lean.Meta.GeneralizeVars": {
      "path": "Lean/Meta/GeneralizeVars.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Util.CollectFVars"
      ]
    },
    "Lean.Meta.GetUnfoldableConst": {
      "path": "Lean/Meta/GetUnfoldableConst.olean",
      "imports": [
        "Lean.Meta.GlobalInstances"
      ]
    },
    "Lean.Meta.GlobalInstances": {
      "path": "Lean/Meta/GlobalInstances.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.HasNotBit": {
      "path": "Lean/Meta/HasNotBit.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Util.Recognizers",
        "Lean.Meta.MatchUtil"
      ]
    },
    "Lean.Meta.Hint": {
      "path": "Lean/Meta/Hint.olean",
      "imports": [
        "Lean.Meta.TryThis",
        "Lean.Util.Diff",
        "*",
        "{",
        "*",
        "{"
      ]
    },
    "Lean.Meta.IndPredBelow": {
      "path": "Lean/Meta/IndPredBelow.olean",
      "imports": [
        "Lean.Meta.Match.MatcherApp.Basic",
        "Lean.Meta.Constructions.CasesOn",
        "Lean.Meta.Match.Match",
        "Lean.Meta.Tactic.SolveByElim"
      ]
    },
    "Lean.Meta.Inductive": {
      "path": "Lean/Meta/Inductive.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.InferType": {
      "path": "Lean/Meta/InferType.olean",
      "imports": [
        "Lean.Data.LBool",
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.Injective": {
      "path": "Lean/Meta/Injective.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.Tactic.Refl",
        "Lean.Meta.Tactic.Cases",
        "Lean.Meta.Tactic.Assumption",
        "Lean.Meta.Tactic.Simp.Main",
        "Lean.Meta.SameCtorUtils"
      ]
    },
    "Lean.Meta.Instances": {
      "path": "Lean/Meta/Instances.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.Stream",
        "Lean.Meta.DiscrTree",
        "Lean.Meta.CollectMVars"
      ]
    },
    "Lean.Meta.IntInstTesters": {
      "path": "Lean/Meta/IntInstTesters.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.Iterator": {
      "path": "Lean/Meta/Iterator.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.KAbstract": {
      "path": "Lean/Meta/KAbstract.olean",
      "imports": [
        "Lean.HeadIndex",
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.KExprMap": {
      "path": "Lean/Meta/KExprMap.olean",
      "imports": [
        "Lean.Data.AssocList",
        "Lean.HeadIndex",
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.LazyDiscrTree": {
      "path": "Lean/Meta/LazyDiscrTree.olean",
      "imports": [
        "Lean.Meta.CompletionName",
        "Lean.Meta.DiscrTree"
      ]
    },
    "Lean.Meta.LetToHave": {
      "path": "Lean/Meta/LetToHave.olean",
      "imports": [
        "Lean.Meta.Check",
        "Lean.ReservedNameAction",
        "Lean.AddDecl",
        "Lean.Meta.Transform",
        "Lean.Util.CollectFVars",
        "Lean.Util.CollectMVars"
      ]
    },
    "Lean.Meta.LevelDefEq": {
      "path": "Lean/Meta/LevelDefEq.olean",
      "imports": [
        "Lean.Util.CollectMVars",
        "Lean.Meta.DecLevel"
      ]
    },
    "Lean.Meta.LitValues": {
      "path": "Lean/Meta/LitValues.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Init.Data.Rat.Basic"
      ]
    },
    "Lean.Meta.Match.AltTelescopes": {
      "path": "Lean/Meta/Match/AltTelescopes.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.Match.MatcherInfo",
        "Lean.Meta.Match.NamedPatterns",
        "Lean.Meta.MatchUtil",
        "Lean.Meta.AppBuilder"
      ]
    },
    "Lean.Meta.Match.Basic": {
      "path": "Lean/Meta/Match/Basic.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.Tactic.FVarSubst",
        "Lean.Meta.CollectFVars",
        "Lean.Meta.Match.Value",
        "Lean.Meta.AppBuilder",
        "Lean.Meta.Tactic.Util",
        "Lean.Meta.Tactic.Assert",
        "Lean.Meta.Tactic.Subst",
        "Lean.Meta.Match.NamedPatterns"
      ]
    },
    "Lean.Meta.Match.CaseArraySizes": {
      "path": "Lean/Meta/Match/CaseArraySizes.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.Tactic.FVarSubst",
        "Lean.Meta.Match.CaseValues",
        "Lean.Meta.AppBuilder",
        "Lean.Meta.Tactic.Util",
        "Lean.Meta.Tactic.Assert",
        "Lean.Meta.Tactic.Subst"
      ]
    },
    "Lean.Meta.Match.CaseValues": {
      "path": "Lean/Meta/Match/CaseValues.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.Tactic.FVarSubst",
        "Lean.Meta.Tactic.Subst"
      ]
    },
    "Lean.Meta.Match.MVarRenaming": {
      "path": "Lean/Meta/Match/MVarRenaming.olean",
      "imports": [
        "Lean.Util.ReplaceExpr"
      ]
    },
    "Lean.Meta.Match.Match": {
      "path": "Lean/Meta/Match/Match.olean",
      "imports": [
        "Lean.Meta.Closure",
        "Lean.Meta.Tactic.Contradiction",
        "Lean.Meta.GeneralizeTelescope",
        "Lean.Meta.Match.Basic",
        "Lean.Meta.Match.MatcherApp.Basic",
        "Lean.Meta.Match.MVarRenaming",
        "Lean.Meta.Match.MVarRenaming",
        "Lean.Meta.Match.SimpH",
        "Lean.Meta.Match.SolveOverlap",
        "Lean.Meta.HasNotBit",
        "Lean.Meta.Match.CaseArraySizes",
        "Lean.Meta.Match.CaseValues",
        "Lean.Meta.Match.NamedPatterns"
      ]
    },
    "Lean.Meta.Match.MatchEqs": {
      "path": "Lean/Meta/Match/MatchEqs.olean",
      "imports": [
        "Lean.Meta.Match.Match",
        "Lean.Meta.Match.MatchEqsExt",
        "Lean.Meta.Tactic.Refl",
        "Lean.Meta.Tactic.Delta",
        "Lean.Meta.Tactic.SplitIf",
        "Lean.Meta.Tactic.CasesOnStuckLHS",
        "Lean.Meta.Match.SimpH",
        "Lean.Meta.Match.AltTelescopes",
        "Lean.Meta.Match.NamedPatterns",
        "Lean.Meta.SplitSparseCasesOn"
      ]
    },
    "Lean.Meta.Match.MatchEqsExt": {
      "path": "Lean/Meta/Match/MatchEqsExt.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.Match.Basic",
        "Lean.Meta.Match.MatcherInfo",
        "Lean.Meta.Eqns"
      ]
    },
    "Lean.Meta.Match.MatchPatternAttr": {
      "path": "Lean/Meta/Match/MatchPatternAttr.olean",
      "imports": [
        "Lean.Attributes"
      ]
    },
    "Lean.Meta.Match.MatcherApp.Basic": {
      "path": "Lean/Meta/Match/MatcherApp/Basic.olean",
      "imports": [
        "Lean.Meta.Match.MatcherInfo"
      ]
    },
    "Lean.Meta.Match.MatcherApp.Transform": {
      "path": "Lean/Meta/Match/MatcherApp/Transform.olean",
      "imports": [
        "Lean.Meta.Match.MatcherApp.Basic",
        "Lean.Meta.Match.MatchEqsExt",
        "Lean.Meta.Match.AltTelescopes",
        "Lean.Meta.AppBuilder",
        "Lean.Meta.Tactic.Split",
        "Lean.Meta.Tactic.Refl"
      ]
    },
    "Lean.Meta.Match.MatcherApp": {
      "path": "Lean/Meta/Match/MatcherApp.olean",
      "imports": [
        "Lean.Meta.Match.MatcherApp.Basic",
        "Lean.Meta.Match.MatcherApp.Transform"
      ]
    },
    "Lean.Meta.Match.MatcherInfo": {
      "path": "Lean/Meta/Match/MatcherInfo.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.Match.NamedPatterns": {
      "path": "Lean/Meta/Match/NamedPatterns.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.AppBuilder"
      ]
    },
    "Lean.Meta.Match.Rewrite": {
      "path": "Lean/Meta/Match/Rewrite.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Types",
        "Lean.Meta.Match.MatcherApp.Transform",
        "Lean.Meta.Tactic.Assumption",
        "Lean.Meta.Tactic.Refl",
        "Lean.Meta.Tactic.Simp.Rewrite"
      ]
    },
    "Lean.Meta.Match.SimpH": {
      "path": "Lean/Meta/Match/SimpH.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.Tactic.Contradiction"
      ]
    },
    "Lean.Meta.Match.SolveOverlap": {
      "path": "Lean/Meta/Match/SolveOverlap.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.Tactic.Contradiction"
      ]
    },
    "Lean.Meta.Match.Value": {
      "path": "Lean/Meta/Match/Value.olean",
      "imports": [
        "Lean.Meta.LitValues"
      ]
    },
    "Lean.Meta.Match": {
      "path": "Lean/Meta/Match.olean",
      "imports": [
        "Lean.Meta.Match.MatchPatternAttr",
        "Lean.Meta.Match.Match",
        "Lean.Meta.Match.CaseValues",
        "Lean.Meta.Match.CaseArraySizes",
        "Lean.Meta.Match.MatchEqs"
      ]
    },
    "Lean.Meta.MatchUtil": {
      "path": "Lean/Meta/MatchUtil.olean",
      "imports": [
        "Lean.Util.Recognizers",
        "Lean.Meta.CtorRecognizer"
      ]
    },
    "Lean.Meta.MethodSpecs": {
      "path": "Lean/Meta/MethodSpecs.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.SimpTheorems",
        "Lean.Meta.Tactic.Simp.Main"
      ]
    },
    "Lean.Meta.MkIffOfInductiveProp": {
      "path": "Lean/Meta/MkIffOfInductiveProp.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Elab.Term.TermElabM",
        "Lean.Elab.Tactic.Basic",
        "Lean.Meta.Tactic.Apply",
        "Lean.Meta.Tactic.Intro",
        "Lean.Meta.Tactic.Cases"
      ]
    },
    "Lean.Meta.NatInstTesters": {
      "path": "Lean/Meta/NatInstTesters.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.NatTable": {
      "path": "Lean/Meta/NatTable.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.InferType"
      ]
    },
    "Lean.Meta.Offset": {
      "path": "Lean/Meta/Offset.olean",
      "imports": [
        "Lean.Data.LBool",
        "Lean.Meta.Basic",
        "Lean.Meta.NatInstTesters",
        "Lean.Util.SafeExponentiation"
      ]
    },
    "Lean.Meta.Order": {
      "path": "Lean/Meta/Order.olean",
      "imports": [
        "Lean.Meta.PProdN",
        "Lean.Meta.AppBuilder",
        "Init.Internal.Order.Basic"
      ]
    },
    "Lean.Meta.PPGoal": {
      "path": "Lean/Meta/PPGoal.olean",
      "imports": [
        "Lean.Meta.InferType"
      ]
    },
    "Lean.Meta.PProdN": {
      "path": "Lean/Meta/PProdN.olean",
      "imports": [
        "Lean.Meta.InferType",
        "Lean.Meta.Transform"
      ]
    },
    "Lean.Meta.ProdN": {
      "path": "Lean/Meta/ProdN.olean",
      "imports": [
        "Lean.Meta.InferType",
        "Lean.Meta.DecLevel"
      ]
    },
    "Lean.Meta.RecursorInfo": {
      "path": "Lean/Meta/RecursorInfo.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.Reduce": {
      "path": "Lean/Meta/Reduce.olean",
      "imports": [
        "Lean.Meta.FunInfo"
      ]
    },
    "Lean.Meta.ReduceEval": {
      "path": "Lean/Meta/ReduceEval.olean",
      "imports": [
        "Lean.Meta.Offset"
      ]
    },
    "Lean.Meta.SameCtorUtils": {
      "path": "Lean/Meta/SameCtorUtils.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.Transform"
      ]
    },
    "Lean.Meta.SizeOf": {
      "path": "Lean/Meta/SizeOf.olean",
      "imports": [
        "Lean.AddDecl",
        "Lean.Meta.AppBuilder",
        "Lean.DefEqAttrib"
      ]
    },
    "Lean.Meta.Sorry": {
      "path": "Lean/Meta/Sorry.olean",
      "imports": [
        "Lean.Data.Lsp.Utf16",
        "Lean.Meta.ForEachExpr",
        "Lean.Meta.InferType",
        "Lean.Util.Recognizers"
      ]
    },
    "Lean.Meta.SplitSparseCasesOn": {
      "path": "Lean/Meta/SplitSparseCasesOn.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.Tactic.Delta",
        "Lean.Meta.Tactic.Rewrite",
        "Lean.Meta.Constructions.SparseCasesOn",
        "Lean.Meta.Constructions.SparseCasesOnEq",
        "Lean.Meta.HasNotBit",
        "Lean.Meta.Tactic.Cases"
      ]
    },
    "Lean.Meta.Structure": {
      "path": "Lean/Meta/Structure.olean",
      "imports": [
        "Lean.AddDecl",
        "Lean.Meta.AppBuilder"
      ]
    },
    "Lean.Meta.Sym.InstantiateS": {
      "path": "Lean/Meta/Sym/InstantiateS.olean",
      "imports": [
        "Lean.Meta.Sym.SymM",
        "Lean.Meta.Sym.ReplaceS",
        "Lean.Meta.Sym.LooseBVarsS",
        "Init.Grind"
      ]
    },
    "Lean.Meta.Sym.Intro": {
      "path": "Lean/Meta/Sym/Intro.olean",
      "imports": [
        "Lean.Meta.Sym.SymM",
        "Lean.Meta.Sym.InstantiateS",
        "Lean.Meta.Sym.IsClass",
        "Lean.Meta.Tactic.Grind.AlphaShareBuilder"
      ]
    },
    "Lean.Meta.Sym.IsClass": {
      "path": "Lean/Meta/Sym/IsClass.olean",
      "imports": [
        "Lean.Meta.Sym.SymM"
      ]
    },
    "Lean.Meta.Sym.LooseBVarsS": {
      "path": "Lean/Meta/Sym/LooseBVarsS.olean",
      "imports": [
        "Lean.Meta.Sym.SymM",
        "Lean.Meta.Sym.ReplaceS"
      ]
    },
    "Lean.Meta.Sym.Main": {
      "path": "Lean/Meta/Sym/Main.olean",
      "imports": [
        "Lean.Meta.Sym.SymM",
        "Lean.Meta.Sym.Util",
        "Lean.Meta.Tactic.Grind.Main"
      ]
    },
    "Lean.Meta.Sym.MaxFVar": {
      "path": "Lean/Meta/Sym/MaxFVar.olean",
      "imports": [
        "Lean.Meta.Sym.SymM"
      ]
    },
    "Lean.Meta.Sym.ReplaceS": {
      "path": "Lean/Meta/Sym/ReplaceS.olean",
      "imports": [
        "Lean.Meta.Sym.SymM",
        "Lean.Meta.Tactic.Grind.AlphaShareBuilder"
      ]
    },
    "Lean.Meta.Sym.SymM": {
      "path": "Lean/Meta/Sym/SymM.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Main"
      ]
    },
    "Lean.Meta.Sym.Util": {
      "path": "Lean/Meta/Sym/Util.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types"
      ]
    },
    "Lean.Meta.Sym": {
      "path": "Lean/Meta/Sym.olean",
      "imports": [
        "Lean.Meta.Sym.SymM",
        "Lean.Meta.Sym.Main",
        "Lean.Meta.Sym.Util",
        "Lean.Meta.Sym.MaxFVar",
        "Lean.Meta.Sym.ReplaceS",
        "Lean.Meta.Sym.LooseBVarsS",
        "Lean.Meta.Sym.InstantiateS",
        "Lean.Meta.Sym.IsClass",
        "Lean.Meta.Sym.Intro"
      ]
    },
    "Lean.Meta.SynthInstance": {
      "path": "Lean/Meta/SynthInstance.olean",
      "imports": [
        "Init.Data.Array.InsertionSort",
        "Lean.Meta.Instances",
        "Lean.Meta.AbstractMVars",
        "Lean.Meta.Check"
      ]
    },
    "Lean.Meta.Tactic.AC.Main": {
      "path": "Lean/Meta/Tactic/AC/Main.olean",
      "imports": [
        "Lean.Meta.Tactic.Refl",
        "Lean.Meta.Tactic.Simp.Main",
        "Lean.Elab.Tactic.Rewrite"
      ]
    },
    "Lean.Meta.Tactic.AC": {
      "path": "Lean/Meta/Tactic/AC.olean",
      "imports": [
        "Lean.Meta.Tactic.AC.Main"
      ]
    },
    "Lean.Meta.Tactic.Acyclic": {
      "path": "Lean/Meta/Tactic/Acyclic.olean",
      "imports": [
        "Lean.Meta.MatchUtil",
        "Lean.Meta.Tactic.Simp.Main"
      ]
    },
    "Lean.Meta.Tactic.Apply": {
      "path": "Lean/Meta/Tactic/Apply.olean",
      "imports": [
        "Lean.Meta.Tactic.Util",
        "Lean.PrettyPrinter",
        "Lean.Meta.AppBuilder"
      ]
    },
    "Lean.Meta.Tactic.Assert": {
      "path": "Lean/Meta/Tactic/Assert.olean",
      "imports": [
        "Lean.Meta.Tactic.FVarSubst",
        "Lean.Meta.Tactic.Intro",
        "Lean.Meta.Tactic.Revert",
        "Lean.Util.ForEachExpr",
        "Lean.Meta.AppBuilder"
      ]
    },
    "Lean.Meta.Tactic.Assumption": {
      "path": "Lean/Meta/Tactic/Assumption.olean",
      "imports": [
        "Lean.Meta.Tactic.Util"
      ]
    },
    "Lean.Meta.Tactic.AuxLemma": {
      "path": "Lean/Meta/Tactic/AuxLemma.olean",
      "imports": [
        "Lean.AddDecl",
        "Lean.DefEqAttrib"
      ]
    },
    "Lean.Meta.Tactic.Backtrack": {
      "path": "Lean/Meta/Tactic/Backtrack.olean",
      "imports": [
        "Lean.Meta.Iterator",
        "Lean.Meta.Tactic.IndependentOf"
      ]
    },
    "Lean.Meta.Tactic.Cases": {
      "path": "Lean/Meta/Tactic/Cases.olean",
      "imports": [
        "Lean.Meta.Tactic.Induction",
        "Lean.Meta.Tactic.Acyclic",
        "Lean.Meta.Tactic.UnifyEq",
        "Lean.Meta.Constructions.SparseCasesOn",
        "Lean.Meta.Constructions.CtorIdx"
      ]
    },
    "Lean.Meta.Tactic.CasesOnStuckLHS": {
      "path": "Lean/Meta/Tactic/CasesOnStuckLHS.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.Tactic.SplitIf"
      ]
    },
    "Lean.Meta.Tactic.Cleanup": {
      "path": "Lean/Meta/Tactic/Cleanup.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.CollectFVars",
        "Lean.Meta.Tactic.Clear"
      ]
    },
    "Lean.Meta.Tactic.Clear": {
      "path": "Lean/Meta/Tactic/Clear.olean",
      "imports": [
        "Lean.Meta.Tactic.Util"
      ]
    },
    "Lean.Meta.Tactic.Congr": {
      "path": "Lean/Meta/Tactic/Congr.olean",
      "imports": [
        "Lean.Meta.CongrTheorems",
        "Lean.Meta.Tactic.Assert",
        "Lean.Meta.Tactic.Refl",
        "Lean.Meta.Tactic.Assumption"
      ]
    },
    "Lean.Meta.Tactic.Constructor": {
      "path": "Lean/Meta/Tactic/Constructor.olean",
      "imports": [
        "Lean.Meta.Tactic.Apply"
      ]
    },
    "Lean.Meta.Tactic.Contradiction": {
      "path": "Lean/Meta/Tactic/Contradiction.olean",
      "imports": [
        "Lean.Meta.Tactic.Assumption",
        "Lean.Meta.Tactic.Cases",
        "Lean.Meta.Tactic.Apply",
        "Lean.Meta.Tactic.Simp.Main",
        "Lean.Meta.HasNotBit"
      ]
    },
    "Lean.Meta.Tactic.Delta": {
      "path": "Lean/Meta/Tactic/Delta.olean",
      "imports": [
        "Lean.Meta.Tactic.Replace"
      ]
    },
    "Lean.Meta.Tactic.ElimInfo": {
      "path": "Lean/Meta/Tactic/ElimInfo.olean",
      "imports": [
        "Lean.Meta.Check"
      ]
    },
    "Lean.Meta.Tactic.ExposeNames": {
      "path": "Lean/Meta/Tactic/ExposeNames.olean",
      "imports": [
        "Lean.Meta.Tactic.Util"
      ]
    },
    "Lean.Meta.Tactic.Ext": {
      "path": "Lean/Meta/Tactic/Ext.olean",
      "imports": [
        "Init.Data.Array.InsertionSort",
        "Lean.Meta.DiscrTree"
      ]
    },
    "Lean.Meta.Tactic.FVarSubst": {
      "path": "Lean/Meta/Tactic/FVarSubst.olean",
      "imports": [
        "Lean.Data.AssocList",
        "Lean.LocalContext",
        "Lean.Util.ReplaceExpr"
      ]
    },
    "Lean.Meta.Tactic.FunInd": {
      "path": "Lean/Meta/Tactic/FunInd.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Types",
        "Lean.Meta.Match.MatcherApp.Transform",
        "Lean.Meta.Match.Rewrite",
        "Lean.Meta.Injective",
        "Lean.Meta.ArgsPacker",
        "Lean.Elab.PreDefinition.WF.Eqns",
        "Lean.Elab.PreDefinition.Structural.Eqns",
        "Lean.Elab.PreDefinition.Structural.FindRecArg",
        "Lean.Meta.Tactic.ElimInfo",
        "Lean.Meta.Tactic.FunIndInfo",
        "Lean.Data.Array",
        "Lean.Meta.Tactic.Simp.Rewrite",
        "Lean.Meta.Tactic.Replace"
      ]
    },
    "Lean.Meta.Tactic.FunIndCollect": {
      "path": "Lean/Meta/Tactic/FunIndCollect.olean",
      "imports": [
        "Lean.Meta.Tactic.Util",
        "Lean.Meta.Tactic.FunIndInfo"
      ]
    },
    "Lean.Meta.Tactic.FunIndInfo": {
      "path": "Lean/Meta/Tactic/FunIndInfo.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.ReservedNameAction"
      ]
    },
    "Lean.Meta.Tactic.Generalize": {
      "path": "Lean/Meta/Tactic/Generalize.olean",
      "imports": [
        "Lean.Meta.KAbstract",
        "Lean.Meta.Tactic.Intro",
        "Lean.Meta.Tactic.FVarSubst",
        "Lean.Meta.Tactic.Revert",
        "Lean.Meta.AppBuilder"
      ]
    },
    "Lean.Meta.Tactic.Grind.AC.Action": {
      "path": "Lean/Meta/Tactic/Grind/AC/Action.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Action",
        "Lean.Meta.Tactic.Grind.AC.Eq"
      ]
    },
    "Lean.Meta.Tactic.Grind.AC.DenoteExpr": {
      "path": "Lean/Meta/Tactic/Grind/AC/DenoteExpr.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.AC.Util",
        "Lean.Meta.AppBuilder"
      ]
    },
    "Lean.Meta.Tactic.Grind.AC.Eq": {
      "path": "Lean/Meta/Tactic/Grind/AC/Eq.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.AC.Util",
        "Lean.Meta.Tactic.Grind.AC.DenoteExpr",
        "Lean.Meta.Tactic.Grind.AC.Proof",
        "Lean.Meta.Tactic.Grind.AC.Seq",
        "Lean.Meta.Tactic.Grind.AC.Inv"
      ]
    },
    "Lean.Meta.Tactic.Grind.AC.Internalize": {
      "path": "Lean/Meta/Tactic/Grind/AC/Internalize.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.AC.Util",
        "Lean.Meta.Tactic.Grind.AC.DenoteExpr"
      ]
    },
    "Lean.Meta.Tactic.Grind.AC.Inv": {
      "path": "Lean/Meta/Tactic/Grind/AC/Inv.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.AC.Util",
        "Lean.Meta.Tactic.Grind.AC.Seq"
      ]
    },
    "Lean.Meta.Tactic.Grind.AC.PP": {
      "path": "Lean/Meta/Tactic/Grind/AC/PP.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.AC.DenoteExpr"
      ]
    },
    "Lean.Meta.Tactic.Grind.AC.Proof": {
      "path": "Lean/Meta/Tactic/Grind/AC/Proof.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.AC.Util",
        "Lean.Data.RArray",
        "Lean.Meta.Tactic.Grind.Diseq",
        "Lean.Meta.Tactic.Grind.ProofUtil",
        "Lean.Meta.Tactic.Grind.AC.ToExpr",
        "Lean.Meta.Tactic.Grind.AC.VarRename"
      ]
    },
    "Lean.Meta.Tactic.Grind.AC.Seq": {
      "path": "Lean/Meta/Tactic/Grind/AC/Seq.olean",
      "imports": [
        "Init.Grind.AC",
        "Init.Data.Ord"
      ]
    },
    "Lean.Meta.Tactic.Grind.AC.ToExpr": {
      "path": "Lean/Meta/Tactic/Grind/AC/ToExpr.olean",
      "imports": [
        "Init.Grind.AC",
        "Lean.ToExpr"
      ]
    },
    "Lean.Meta.Tactic.Grind.AC.Types": {
      "path": "Lean/Meta/Tactic/Grind/AC/Types.olean",
      "imports": [
        "Init.Grind.AC",
        "Std.Data.HashMap",
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.AC.Seq"
      ]
    },
    "Lean.Meta.Tactic.Grind.AC.Util": {
      "path": "Lean/Meta/Tactic/Grind/AC/Util.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.AC.Types",
        "Lean.Meta.Tactic.Grind.ProveEq",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingId",
        "Lean.Meta.Tactic.Grind.Simp"
      ]
    },
    "Lean.Meta.Tactic.Grind.AC.Var": {
      "path": "Lean/Meta/Tactic/Grind/AC/Var.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Util"
      ]
    },
    "Lean.Meta.Tactic.Grind.AC.VarRename": {
      "path": "Lean/Meta/Tactic/Grind/AC/VarRename.olean",
      "imports": [
        "Init.Grind.AC",
        "Lean.Meta.Tactic.Grind.VarRename"
      ]
    },
    "Lean.Meta.Tactic.Grind.AC": {
      "path": "Lean/Meta/Tactic/Grind/AC.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.AC.Types",
        "Lean.Meta.Tactic.Grind.AC.Util",
        "Lean.Meta.Tactic.Grind.AC.Var",
        "Lean.Meta.Tactic.Grind.AC.Internalize",
        "Lean.Meta.Tactic.Grind.AC.Eq",
        "Lean.Meta.Tactic.Grind.AC.Seq",
        "Lean.Meta.Tactic.Grind.AC.Proof",
        "Lean.Meta.Tactic.Grind.AC.DenoteExpr",
        "Lean.Meta.Tactic.Grind.AC.ToExpr",
        "Lean.Meta.Tactic.Grind.AC.VarRename",
        "Lean.Meta.Tactic.Grind.AC.PP",
        "Lean.Meta.Tactic.Grind.AC.Inv",
        "Lean.Meta.Tactic.Grind.AC.Action"
      ]
    },
    "Lean.Meta.Tactic.Grind.Action": {
      "path": "Lean/Meta/Tactic/Grind/Action.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types"
      ]
    },
    "Lean.Meta.Tactic.Grind.AlphaShareBuilder": {
      "path": "Lean/Meta/Tactic/Grind/AlphaShareBuilder.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types"
      ]
    },
    "Lean.Meta.Tactic.Grind.AlphaShareCommon": {
      "path": "Lean/Meta/Tactic/Grind/AlphaShareCommon.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.ExprPtr"
      ]
    },
    "Lean.Meta.Tactic.Grind.Anchor": {
      "path": "Lean/Meta/Tactic/Grind/Anchor.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.MarkNestedSubsingletons"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.Action": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/Action.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Action",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.EqCnstr"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.DenoteExpr": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/DenoteExpr.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Functions"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.EqCnstr": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/EqCnstr.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingId",
        "Lean.Meta.Tactic.Grind.ProveEq",
        "Lean.Meta.Tactic.Grind.Diseq",
        "Lean.Meta.Tactic.Grind.Arith.Util",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Proof",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.DenoteExpr",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Inv",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Reify",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.SafePoly"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.Functions": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/Functions.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.CommRing.MonadRing"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.Internalize": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/Internalize.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingId",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Arith.Util",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Reify",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.DenoteExpr"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.Inv": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/Inv.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingM",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Poly"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.MonadCanon": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/MonadCanon.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Types"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.MonadRing": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/MonadRing.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.CommRing.MonadCanon"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.MonadSemiring": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/MonadSemiring.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.CommRing.MonadCanon"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.NonCommRingM": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/NonCommRingM.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingM"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.NonCommSemiringM": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/NonCommSemiringM.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.CommRing.SemiringM"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.PP": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/PP.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.DenoteExpr",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingM"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.Poly": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/Poly.olean",
      "imports": [
        "Init.Grind.Ring.CommSolver"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.Power": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/Power.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Init.Grind",
        "Lean.Meta.Tactic.Grind.PropagatorAttr",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Arith.Simproc",
        "Lean.Meta.NatInstTesters"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.Proof": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/Proof.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingId",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.NonCommRingM",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.NonCommSemiringM",
        "Lean.Data.RArray",
        "Lean.Meta.Tactic.Grind.Diseq",
        "Lean.Meta.Tactic.Grind.ProofUtil",
        "Lean.Meta.Tactic.Grind.Arith.Util",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.DenoteExpr",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.SafePoly",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.ToExpr",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.VarRename"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.Reify": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/Reify.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.CommRing.NonCommRingM",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.NonCommSemiringM",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Functions"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.RingId": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/RingId.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingM",
        "Init.Grind.Ring.Field",
        "Init.Grind.Ring.Envelope",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Arith.Insts"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.RingM": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/RingM.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.SynthInstance",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.MonadRing",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Functions",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Poly"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.SafePoly": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/SafePoly.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingM",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Poly",
        "Lean.Meta.Tactic.Grind.Arith.EvalNum"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.SemiringM": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/SemiringM.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingM",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.MonadSemiring",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.DenoteExpr",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Functions"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.ToExpr": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/ToExpr.olean",
      "imports": [
        "Init.Grind.Ring.CommSemiringAdapter",
        "Lean.ToExpr"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.Types": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/Types.olean",
      "imports": [
        "Init.Grind.Ring.CommSemiringAdapter",
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Poly",
        "Lean.Data.PersistentArray"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing.VarRename": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing/VarRename.olean",
      "imports": [
        "Init.Grind.Ring.CommSemiringAdapter",
        "Lean.Meta.Tactic.Grind.VarRename"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.CommRing": {
      "path": "Lean/Meta/Tactic/Grind/Arith/CommRing.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Poly",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Types",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingId",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Internalize",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.ToExpr",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingM",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.SemiringM",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.NonCommRingM",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.NonCommSemiringM",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Functions",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Reify",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.EqCnstr",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Proof",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.DenoteExpr",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Inv",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.PP",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.VarRename",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.MonadCanon",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.MonadRing",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.MonadSemiring",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Action",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Power"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.Action": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/Action.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Action",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Search"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.CommRing": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/CommRing.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Types",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingId",
        "Lean.Meta.Tactic.Grind.ProveEq",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Util",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Var",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Reify",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.DenoteExpr",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.SafePoly"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.DvdCnstr": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/DvdCnstr.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Types",
        "Init.Data.Int.OfNat",
        "Init.Grind.Propagator",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.PropagatorAttr",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Var",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Nat",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Proof",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Norm",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.CommRing",
        "Lean.Meta.NatInstTesters"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.EqCnstr": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/EqCnstr.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Types",
        "Init.Data.Int.OfNat",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Proof",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Var",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.DvdCnstr",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.LeCnstr",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Nat",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.CommRing",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Norm",
        "Lean.Meta.Tactic.Grind.Arith.EvalNum",
        "Lean.Meta.NatInstTesters"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.Inv": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/Inv.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Types",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Util",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Var"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.LeCnstr": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/LeCnstr.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.ToInt",
        "Init.Data.Int.OfNat",
        "Lean.Meta.Tactic.Simp.Arith.Int",
        "Lean.Meta.Tactic.Grind.PropagatorAttr",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Var",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Proof",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Nat",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Norm",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.CommRing"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.MBTC": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/MBTC.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Util",
        "Lean.Meta.Tactic.Grind.MBTC",
        "Lean.Meta.Tactic.Grind.Arith.ModelUtil",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Model"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.Model": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/Model.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Types",
        "Init.Grind.ToInt",
        "Lean.Meta.Tactic.Grind.Arith.ModelUtil"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.Nat": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/Nat.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Types",
        "Init.Data.Int.OfNat",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Norm",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.ToInt",
        "Lean.Meta.NatInstTesters"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.Norm": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/Norm.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Util",
        "Lean.Meta.IntInstTesters"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.Proof": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/Proof.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Types",
        "Init.Data.Int.OfNat",
        "Lean.Meta.Tactic.Grind.Diseq",
        "Lean.Meta.Tactic.Grind.ProofUtil",
        "Lean.Meta.Tactic.Simp.Arith.Int.Simp",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.CommRing",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Util",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Nat",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.VarRename",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.VarRename",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.ToExpr"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.ReorderVars": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/ReorderVars.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Types",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.EqCnstr",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.DvdCnstr",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.LeCnstr",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Inv"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.Search": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/Search.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.SearchM",
        "Lean.Meta.Tactic.Simp.Arith.Int.Simp",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Var",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.DvdCnstr",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.LeCnstr",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.EqCnstr",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Model",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.ReorderVars",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Proof"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.SearchM": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/SearchM.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Types",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Util"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.ToInt": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/ToInt.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Util",
        "Init.Grind.ToIntLemmas",
        "Init.GrindInstances.ToInt",
        "Lean.Meta.Tactic.Grind.SynthInstance",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Arith.EvalNum",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Norm"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.ToIntInfo": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/ToIntInfo.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Util",
        "Init.Grind.ToInt"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.Types": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/Types.olean",
      "imports": [
        "Init.Data.Int.Linear",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Types",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.ToIntInfo",
        "Lean.Meta.Tactic.Grind.ExprPtr",
        "Lean.Meta.Tactic.Grind.Arith.Util"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.Util": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/Util.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Types",
        "Lean.Meta.Tactic.Grind.Arith.Util",
        "Lean.Meta.Tactic.Simp.Arith.Int.Simp"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.Var": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/Var.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Types",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Nat",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.ToInt"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat.VarRename": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat/VarRename.olean",
      "imports": [
        "Init.Data.Int.Linear",
        "Lean.Meta.Tactic.Grind.VarRename"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Cutsat": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Cutsat.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.DvdCnstr",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.LeCnstr",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Search",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Inv",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Proof",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Types",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Util",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Var",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.EqCnstr",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.SearchM",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Model",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.MBTC",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Nat",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.CommRing",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.VarRename",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Action"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.EvalNum": {
      "path": "Lean/Meta/Tactic/Grind/Arith/EvalNum.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.IntInstTesters",
        "Lean.Meta.NatInstTesters"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.FieldNormNum": {
      "path": "Lean/Meta/Tactic/Grind/Arith/FieldNormNum.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.Tactic.Grind.SynthInstance",
        "Lean.Util.SafeExponentiation",
        "Lean.Meta.AppBuilder",
        "Init.Grind.FieldNormNum"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Insts": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Insts.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.EvalNum",
        "Lean.Meta.Tactic.Grind.SynthInstance",
        "Init.Grind.Ring"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.IsRelevant": {
      "path": "Lean/Meta/Tactic/Grind/Arith/IsRelevant.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Arith.Util",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.ToInt",
        "Lean.Meta.Tactic.Grind.Arith.Linear.StructId"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.Action": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/Action.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Action",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Search"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.Den": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/Den.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Linear.LinearM",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Reify",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.DenoteExpr",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.SafePoly"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.DenoteExpr": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/DenoteExpr.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Util",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Util",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.DenoteExpr",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Var"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.IneqCnstr": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/IneqCnstr.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Linear.LinearM",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Reify",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.DenoteExpr",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Den",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Var",
        "Lean.Meta.Tactic.Grind.Arith.Linear.StructId",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Reify",
        "Lean.Meta.Tactic.Grind.Arith.Linear.DenoteExpr",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Proof",
        "Lean.Meta.Tactic.Grind.Arith.Linear.OfNatModule"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.Internalize": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/Internalize.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Linear.OfNatModule",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Arith.Util",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Reify",
        "Lean.Meta.Tactic.Grind.Arith.Linear.StructId",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Var",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Util",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Reify"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.Inv": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/Inv.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Linear.LinearM",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Util"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.LinearM": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/LinearM.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Linear.Types",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingM"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.MBTC": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/MBTC.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.MBTC",
        "Lean.Meta.Tactic.Grind.Arith.ModelUtil",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Model",
        "Lean.Meta.Tactic.Grind.Arith.Linear.PropagateEq"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.Model": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/Model.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Linear.Types",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Reify",
        "Lean.Meta.Tactic.Grind.Arith.ModelUtil",
        "Init.Grind.Module.Envelope"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.OfNatModule": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/OfNatModule.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Linear.LinearM",
        "Lean.Meta.Tactic.Grind.Simp",
        "Init.Grind.Module.OfNatModule",
        "Init.Grind.Module.NatModuleNorm",
        "Lean.Meta.Tactic.Grind.Diseq",
        "Lean.Meta.Tactic.Grind.Proof",
        "Lean.Meta.Tactic.Grind.Arith.Linear.ToExpr"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.PP": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/PP.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Linear.Types",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Model",
        "Lean.Meta.Tactic.Grind.Arith.Util"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.Proof": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/Proof.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Linear.LinearM",
        "Lean.Meta.Tactic.Grind.Arith.Util",
        "Init.Grind.Module.OfNatModule",
        "Lean.Data.RArray",
        "Lean.Meta.Tactic.Grind.Arith.Linear.ToExpr",
        "Lean.Meta.Tactic.Grind.Arith.Linear.DenoteExpr",
        "Lean.Meta.Tactic.Grind.Diseq",
        "Lean.Meta.Tactic.Grind.ProofUtil",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.VarRename",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.ToExpr",
        "Lean.Meta.Tactic.Grind.Arith.Linear.VarRename",
        "Lean.Meta.Tactic.Grind.Arith.Linear.OfNatModule"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.PropagateEq": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/PropagateEq.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Linear.LinearM",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Reify",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.DenoteExpr",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Den",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Var",
        "Lean.Meta.Tactic.Grind.Arith.Linear.StructId",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Reify",
        "Lean.Meta.Tactic.Grind.Arith.Linear.IneqCnstr",
        "Lean.Meta.Tactic.Grind.Arith.Linear.DenoteExpr",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Proof",
        "Lean.Meta.Tactic.Grind.Arith.Linear.OfNatModule"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.Reify": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/Reify.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Linear.LinearM",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Var"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.Search": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/Search.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Linear.SearchM",
        "Lean.Meta.Tactic.Grind.Arith.Linear.DenoteExpr",
        "Lean.Meta.Tactic.Grind.Arith.Linear.IneqCnstr",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Proof"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.SearchM": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/SearchM.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Linear.LinearM"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.StructId": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/StructId.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.OrderInsts",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.ToInt",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingId",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Util",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Var",
        "Lean.Meta.Tactic.Grind.Arith.Insts",
        "Init.Grind.Module.Envelope"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.ToExpr": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/ToExpr.olean",
      "imports": [
        "Init.Grind.Ordered.Linarith",
        "Lean.ToExpr"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.Types": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/Types.olean",
      "imports": [
        "Init.Grind.Ring.CommSolver",
        "Init.Grind.Ordered.Linarith",
        "Lean.Meta.Tactic.Grind.Types",
        "Init.Data.Rat.Basic"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.Util": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/Util.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Linear.LinearM",
        "Lean.Meta.Tactic.Grind.Arith.Util",
        "Init.Data.Int.Gcd"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.Var": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/Var.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Linear.LinearM",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Util"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear.VarRename": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear/VarRename.olean",
      "imports": [
        "Init.Grind.Ordered.Linarith",
        "Lean.Meta.Tactic.Grind.VarRename"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Linear": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Linear.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Linear.Types",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Util",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Var",
        "Lean.Meta.Tactic.Grind.Arith.Linear.StructId",
        "Lean.Meta.Tactic.Grind.Arith.Linear.IneqCnstr",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Reify",
        "Lean.Meta.Tactic.Grind.Arith.Linear.DenoteExpr",
        "Lean.Meta.Tactic.Grind.Arith.Linear.ToExpr",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Proof",
        "Lean.Meta.Tactic.Grind.Arith.Linear.SearchM",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Search",
        "Lean.Meta.Tactic.Grind.Arith.Linear.PropagateEq",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Internalize",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Model",
        "Lean.Meta.Tactic.Grind.Arith.Linear.PP",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Inv",
        "Lean.Meta.Tactic.Grind.Arith.Linear.MBTC",
        "Lean.Meta.Tactic.Grind.Arith.Linear.VarRename",
        "Lean.Meta.Tactic.Grind.Arith.Linear.OfNatModule",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Action"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Main": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Main.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Init.Grind.Propagator",
        "Lean.Meta.Tactic.Grind.PropagatorAttr",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.LeCnstr",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Search",
        "Lean.Meta.Tactic.Grind.Arith.Linear.IneqCnstr",
        "Lean.Meta.Tactic.Grind.Arith.Linear.Search"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Model": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Model.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Model"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.ModelUtil": {
      "path": "Lean/Meta/Tactic/Grind/Arith/ModelUtil.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Init.Data.Rat.Basic",
        "Lean.Meta.Tactic.Grind.Arith.Util",
        "Init.Grind.Module.Envelope"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Propagate": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Propagate.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Init.Grind",
        "Lean.Meta.Tactic.Grind.PropagatorAttr",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingId",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.NonCommRingM",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.NonCommSemiringM"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Simproc": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Simproc.olean",
      "imports": [
        "Init.Grind.Ring.Basic",
        "Init.Simproc",
        "Lean.Meta.Tactic.Simp.Simproc",
        "Lean.Meta.Tactic.Grind.SynthInstance",
        "Init.Grind.Ring.Field",
        "Init.Grind.FieldNormNum",
        "Lean.Meta.Tactic.Grind.Arith.FieldNormNum"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Types": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Types.olean",
      "imports": [
        "Init.Core"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith.Util": {
      "path": "Lean/Meta/Tactic/Grind/Arith/Util.olean",
      "imports": [
        "Init.Grind.Ring.Basic",
        "Lean.Meta.SynthInstance",
        "Init.Data.Rat.Basic"
      ]
    },
    "Lean.Meta.Tactic.Grind.Arith": {
      "path": "Lean/Meta/Tactic/Grind/Arith.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Arith.Util",
        "Lean.Meta.Tactic.Grind.Arith.Types",
        "Lean.Meta.Tactic.Grind.Arith.Main",
        "Lean.Meta.Tactic.Grind.Arith.CommRing",
        "Lean.Meta.Tactic.Grind.Arith.Linear",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat",
        "Lean.Meta.Tactic.Grind.Arith.Simproc",
        "Lean.Meta.Tactic.Grind.Arith.Propagate"
      ]
    },
    "Lean.Meta.Tactic.Grind.Attr": {
      "path": "Lean/Meta/Tactic/Grind/Attr.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Injective",
        "Lean.Meta.Tactic.Grind.Cases",
        "Lean.Meta.Tactic.Grind.ExtAttr",
        "Lean.Meta.Tactic.Simp.Attr",
        "Lean.ExtraModUses"
      ]
    },
    "Lean.Meta.Tactic.Grind.Beta": {
      "path": "Lean/Meta/Tactic/Grind/Beta.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types"
      ]
    },
    "Lean.Meta.Tactic.Grind.Canon": {
      "path": "Lean/Meta/Tactic/Grind/Canon.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Init.Grind.Util",
        "Lean.Meta.FunInfo",
        "Lean.Util.FVarSubset",
        "Lean.Meta.IntInstTesters",
        "Lean.Meta.NatInstTesters",
        "Lean.Meta.Tactic.Grind.SynthInstance"
      ]
    },
    "Lean.Meta.Tactic.Grind.Cases": {
      "path": "Lean/Meta/Tactic/Grind/Cases.olean",
      "imports": [
        "Lean.Meta.Tactic.Cases",
        "Lean.Meta.Tactic.Grind.Extension"
      ]
    },
    "Lean.Meta.Tactic.Grind.CasesMatch": {
      "path": "Lean/Meta/Tactic/Grind/CasesMatch.olean",
      "imports": [
        "Lean.Meta.Tactic.Util",
        "Lean.Meta.Tactic.Grind.Util",
        "Lean.Meta.Match.MatcherApp",
        "Lean.Meta.Tactic.Grind.MatchCond",
        "Lean.Meta.Tactic.Grind.Simp"
      ]
    },
    "Lean.Meta.Tactic.Grind.CastLike": {
      "path": "Lean/Meta/Tactic/Grind/CastLike.olean",
      "imports": [
        "Lean.Expr",
        "Init.Grind.Ring.Envelope",
        "Init.Grind.Module.Envelope"
      ]
    },
    "Lean.Meta.Tactic.Grind.CheckResult": {
      "path": "Lean/Meta/Tactic/Grind/CheckResult.olean",
      "imports": [
        "Init.Data.Repr"
      ]
    },
    "Lean.Meta.Tactic.Grind.CollectParams": {
      "path": "Lean/Meta/Tactic/Grind/CollectParams.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types"
      ]
    },
    "Lean.Meta.Tactic.Grind.Core": {
      "path": "Lean/Meta/Tactic/Grind/Core.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Inv",
        "Lean.Meta.Tactic.Grind.PP",
        "Lean.Meta.Tactic.Grind.Ctor",
        "Lean.Meta.Tactic.Grind.Util",
        "Lean.Meta.Tactic.Grind.Beta",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Internalize"
      ]
    },
    "Lean.Meta.Tactic.Grind.Ctor": {
      "path": "Lean/Meta/Tactic/Grind/Ctor.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Injective",
        "Lean.Meta.Tactic.Grind.Simp"
      ]
    },
    "Lean.Meta.Tactic.Grind.CtorIdx": {
      "path": "Lean/Meta/Tactic/Grind/CtorIdx.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Constructions.CtorIdx",
        "Lean.Meta.CtorIdxHInj"
      ]
    },
    "Lean.Meta.Tactic.Grind.Diseq": {
      "path": "Lean/Meta/Tactic/Grind/Diseq.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Init.Grind.Lemmas"
      ]
    },
    "Lean.Meta.Tactic.Grind.EMatch": {
      "path": "Lean/Meta/Tactic/Grind/EMatch.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Util.CollectLevelMVars",
        "Lean.Meta.Tactic.Grind.Core",
        "Lean.Meta.Tactic.Grind.Util",
        "Lean.Meta.Tactic.Grind.MatchDiscrOnly",
        "Lean.Meta.Tactic.Grind.ProveEq",
        "Lean.Meta.Tactic.Grind.SynthInstance",
        "Lean.Meta.Tactic.Grind.Simp"
      ]
    },
    "Lean.Meta.Tactic.Grind.EMatchAction": {
      "path": "Lean/Meta/Tactic/Grind/EMatchAction.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Action",
        "Lean.Meta.Tactic.Grind.Intro",
        "Lean.Util.ParamMinimizer",
        "Lean.Meta.Tactic.Grind.EMatch",
        "Lean.Meta.Tactic.Grind.EMatchTheoremParam",
        "Lean.Meta.Tactic.Grind.EMatchTheoremPtr",
        "Lean.Meta.Tactic.Grind.MarkNestedSubsingletons"
      ]
    },
    "Lean.Meta.Tactic.Grind.EMatchTheorem": {
      "path": "Lean/Meta/Tactic/Grind/EMatchTheorem.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Extension",
        "Init.Grind.Util",
        "Lean.Util.ForEachExpr",
        "Lean.Meta.Tactic.Grind.Util",
        "Lean.Meta.Match.Basic",
        "Lean.Meta.Tactic.TryThis"
      ]
    },
    "Lean.Meta.Tactic.Grind.EMatchTheoremParam": {
      "path": "Lean/Meta/Tactic/Grind/EMatchTheoremParam.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Anchor",
        "Lean.Meta.Tactic.Grind.EMatchTheorem",
        "Lean.Meta.Eqns"
      ]
    },
    "Lean.Meta.Tactic.Grind.EMatchTheoremPtr": {
      "path": "Lean/Meta/Tactic/Grind/EMatchTheoremPtr.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.EMatchTheorem"
      ]
    },
    "Lean.Meta.Tactic.Grind.EqResolution": {
      "path": "Lean/Meta/Tactic/Grind/EqResolution.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.AppBuilder",
        "Lean.Meta.MatchUtil",
        "Lean.Util.ForEachExpr"
      ]
    },
    "Lean.Meta.Tactic.Grind.ExprPtr": {
      "path": "Lean/Meta/Tactic/Grind/ExprPtr.olean",
      "imports": [
        "Lean.Expr"
      ]
    },
    "Lean.Meta.Tactic.Grind.Ext": {
      "path": "Lean/Meta/Tactic/Grind/Ext.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.SynthInstance"
      ]
    },
    "Lean.Meta.Tactic.Grind.ExtAttr": {
      "path": "Lean/Meta/Tactic/Grind/ExtAttr.olean",
      "imports": [
        "Lean.Meta.Tactic.Ext",
        "Lean.Meta.Tactic.Grind.Extension"
      ]
    },
    "Lean.Meta.Tactic.Grind.Extension": {
      "path": "Lean/Meta/Tactic/Grind/Extension.olean",
      "imports": [
        "Lean.Expr",
        "Lean.Data.PersistentHashMap",
        "Lean.Meta.Tactic.Grind.Theorems"
      ]
    },
    "Lean.Meta.Tactic.Grind.Filter": {
      "path": "Lean/Meta/Tactic/Grind/Filter.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types"
      ]
    },
    "Lean.Meta.Tactic.Grind.Finish": {
      "path": "Lean/Meta/Tactic/Grind/Finish.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Action",
        "Lean.Meta.Tactic.Grind.EMatchAction",
        "Lean.Meta.Tactic.Grind.Split",
        "Lean.Meta.Tactic.Grind.Intro"
      ]
    },
    "Lean.Meta.Tactic.Grind.ForallProp": {
      "path": "Lean/Meta/Tactic/Grind/ForallProp.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Init.Grind.Propagator",
        "Init.Simproc",
        "Init.Grind.Norm",
        "Lean.Meta.Tactic.Grind.PropagatorAttr",
        "Lean.Meta.Tactic.Grind.Propagate",
        "Lean.Meta.Tactic.Grind.Internalize",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Anchor",
        "Lean.Meta.Tactic.Grind.EqResolution",
        "Lean.Meta.Tactic.Grind.SynthInstance"
      ]
    },
    "Lean.Meta.Tactic.Grind.Injection": {
      "path": "Lean/Meta/Tactic/Grind/Injection.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.Tactic.Clear",
        "Lean.Meta.AppBuilder"
      ]
    },
    "Lean.Meta.Tactic.Grind.Injective": {
      "path": "Lean/Meta/Tactic/Grind/Injective.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.EMatchTheorem",
        "Lean.Meta.FunInfo"
      ]
    },
    "Lean.Meta.Tactic.Grind.Internalize": {
      "path": "Lean/Meta/Tactic/Grind/Internalize.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Types",
        "Lean.Meta.Tactic.Grind.Arith.IsRelevant",
        "Lean.Meta.Match.MatchEqsExt",
        "Lean.Meta.Tactic.Grind.Util",
        "Lean.Meta.Tactic.Grind.Beta",
        "Lean.Meta.Tactic.Grind.MatchCond",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Proof",
        "Lean.Meta.Tactic.Grind.MarkNestedSubsingletons",
        "Lean.Meta.Tactic.Grind.PropagateInj",
        "Lean.Util.CollectLevelParams"
      ]
    },
    "Lean.Meta.Tactic.Grind.Intro": {
      "path": "Lean/Meta/Tactic/Grind/Intro.olean",
      "imports": [
        "Init.Grind.Lemmas",
        "Lean.Meta.Tactic.Grind.Action",
        "Lean.Meta.Tactic.Apply",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Util",
        "Lean.Meta.Tactic.Grind.CasesMatch",
        "Lean.Meta.Tactic.Grind.Injection",
        "Lean.Meta.Tactic.Grind.Core",
        "Lean.Meta.Tactic.Grind.RevertAll"
      ]
    },
    "Lean.Meta.Tactic.Grind.Inv": {
      "path": "Lean/Meta/Tactic/Grind/Inv.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Init.Grind.Util",
        "Lean.Meta.Tactic.Grind.Proof",
        "Lean.Meta.Tactic.Grind.MatchCond",
        "Lean.Meta.Tactic.Grind.Util"
      ]
    },
    "Lean.Meta.Tactic.Grind.LawfulEqCmp": {
      "path": "Lean/Meta/Tactic/Grind/LawfulEqCmp.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Util",
        "Lean.Meta.Tactic.Grind.SynthInstance"
      ]
    },
    "Lean.Meta.Tactic.Grind.Lookahead": {
      "path": "Lean/Meta/Tactic/Grind/Lookahead.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Intro",
        "Lean.Meta.Tactic.Grind.Action",
        "Lean.Meta.Tactic.Grind.Split",
        "Lean.Meta.Tactic.Grind.EMatch",
        "Lean.Meta.Tactic.Grind.EMatchAction"
      ]
    },
    "Lean.Meta.Tactic.Grind.MBTC": {
      "path": "Lean/Meta/Tactic/Grind/MBTC.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Canon",
        "Lean.Meta.Tactic.Grind.CastLike"
      ]
    },
    "Lean.Meta.Tactic.Grind.Main": {
      "path": "Lean/Meta/Tactic/Grind/Main.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Util",
        "Lean.Meta.Closure",
        "Lean.PrettyPrinter",
        "Lean.Meta.Tactic.ExposeNames",
        "Lean.Meta.Tactic.Simp.Diagnostics",
        "Lean.Meta.Tactic.Simp.Rewrite",
        "Lean.Meta.Tactic.Grind.Split",
        "Lean.Meta.Tactic.Grind.RevertAll",
        "Lean.Meta.Tactic.Grind.PropagatorAttr",
        "Lean.Meta.Tactic.Grind.Proj",
        "Lean.Meta.Tactic.Grind.ForallProp",
        "Lean.Meta.Tactic.Grind.CtorIdx",
        "Lean.Meta.Tactic.Grind.Inv",
        "Lean.Meta.Tactic.Grind.Intro",
        "Lean.Meta.Tactic.Grind.EMatch",
        "Lean.Meta.Tactic.Grind.Solve",
        "Lean.Meta.Tactic.Grind.Internalize",
        "Lean.Meta.Tactic.Grind.SimpUtil",
        "Lean.Meta.Tactic.Grind.LawfulEqCmp",
        "Lean.Meta.Tactic.Grind.ReflCmp",
        "Lean.Meta.Tactic.Grind.PP",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Core"
      ]
    },
    "Lean.Meta.Tactic.Grind.MarkNestedSubsingletons": {
      "path": "Lean/Meta/Tactic/Grind/MarkNestedSubsingletons.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Init.Grind.Util",
        "Lean.Meta.Tactic.Grind.ExprPtr",
        "Lean.Meta.Tactic.Grind.Util"
      ]
    },
    "Lean.Meta.Tactic.Grind.MatchCond": {
      "path": "Lean/Meta/Tactic/Grind/MatchCond.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Init.Grind",
        "Init.Simproc",
        "Lean.Meta.Tactic.Contradiction",
        "Lean.Meta.Tactic.Grind.ProveEq",
        "Lean.Meta.Tactic.Grind.PropagatorAttr"
      ]
    },
    "Lean.Meta.Tactic.Grind.MatchDiscrOnly": {
      "path": "Lean/Meta/Tactic/Grind/MatchDiscrOnly.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Simproc",
        "Init.Grind.Util",
        "Init.Simproc",
        "Lean.Meta.Tactic.Simp.Rewrite"
      ]
    },
    "Lean.Meta.Tactic.Grind.Order.Assert": {
      "path": "Lean/Meta/Tactic/Grind/Order/Assert.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Order.OrderM",
        "Init.Grind.Propagator",
        "Init.Grind.Order",
        "Lean.Meta.Tactic.Grind.PropagatorAttr",
        "Lean.Meta.Tactic.Grind.Order.Util",
        "Lean.Meta.Tactic.Grind.Order.Proof"
      ]
    },
    "Lean.Meta.Tactic.Grind.Order.Internalize": {
      "path": "Lean/Meta/Tactic/Grind/Order/Internalize.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Order.OrderM",
        "Init.Data.Int.OfNat",
        "Init.Grind.Module.Envelope",
        "Init.Grind.Order",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.SafePoly",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Reify",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.DenoteExpr",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.Proof",
        "Lean.Meta.Tactic.Grind.Arith.Cutsat.Nat",
        "Lean.Meta.Tactic.Grind.Order.StructId",
        "Lean.Meta.Tactic.Grind.Order.Util",
        "Lean.Meta.Tactic.Grind.Order.Assert",
        "Lean.Meta.Tactic.Grind.Order.Proof"
      ]
    },
    "Lean.Meta.Tactic.Grind.Order.OrderM": {
      "path": "Lean/Meta/Tactic/Grind/Order/OrderM.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Order.Types"
      ]
    },
    "Lean.Meta.Tactic.Grind.Order.Proof": {
      "path": "Lean/Meta/Tactic/Grind/Order/Proof.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Order.OrderM",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingM",
        "Init.Grind.Order"
      ]
    },
    "Lean.Meta.Tactic.Grind.Order.StructId": {
      "path": "Lean/Meta/Tactic/Grind/Order/StructId.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Order.Types",
        "Lean.Meta.Tactic.Grind.OrderInsts",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.RingId",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.NonCommRingM"
      ]
    },
    "Lean.Meta.Tactic.Grind.Order.Types": {
      "path": "Lean/Meta/Tactic/Grind/Order/Types.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Init.Data.Rat.Basic"
      ]
    },
    "Lean.Meta.Tactic.Grind.Order.Util": {
      "path": "Lean/Meta/Tactic/Grind/Order/Util.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Order.OrderM",
        "Lean.Meta.Tactic.Grind.Arith.Util"
      ]
    },
    "Lean.Meta.Tactic.Grind.Order": {
      "path": "Lean/Meta/Tactic/Grind/Order.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Order.Types",
        "Lean.Meta.Tactic.Grind.Order.Internalize",
        "Lean.Meta.Tactic.Grind.Order.StructId",
        "Lean.Meta.Tactic.Grind.Order.OrderM",
        "Lean.Meta.Tactic.Grind.Order.Assert",
        "Lean.Meta.Tactic.Grind.Order.Util"
      ]
    },
    "Lean.Meta.Tactic.Grind.OrderInsts": {
      "path": "Lean/Meta/Tactic/Grind/OrderInsts.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.SynthInstance"
      ]
    },
    "Lean.Meta.Tactic.Grind.PP": {
      "path": "Lean/Meta/Tactic/Grind/PP.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Init.Grind.Util",
        "Init.Grind.Injective",
        "Init.Grind.PP",
        "Lean.Meta.Tactic.Grind.Arith.Model",
        "Lean.Meta.Tactic.Grind.Arith.CommRing.PP",
        "Lean.Meta.Tactic.Grind.Arith.Linear.PP",
        "Lean.Meta.Tactic.Grind.AC.PP",
        "Lean.Meta.Tactic.Grind.CastLike",
        "Lean.PrettyPrinter"
      ]
    },
    "Lean.Meta.Tactic.Grind.Parser": {
      "path": "Lean/Meta/Tactic/Grind/Parser.olean",
      "imports": [
        "Lean.Parser.Command"
      ]
    },
    "Lean.Meta.Tactic.Grind.Proj": {
      "path": "Lean/Meta/Tactic/Grind/Proj.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Internalize"
      ]
    },
    "Lean.Meta.Tactic.Grind.Proof": {
      "path": "Lean/Meta/Tactic/Grind/Proof.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Init.Grind.Lemmas"
      ]
    },
    "Lean.Meta.Tactic.Grind.ProofUtil": {
      "path": "Lean/Meta/Tactic/Grind/ProofUtil.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types"
      ]
    },
    "Lean.Meta.Tactic.Grind.Propagate": {
      "path": "Lean/Meta/Tactic/Grind/Propagate.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Init.Grind",
        "Lean.Meta.Tactic.Grind.PropagatorAttr",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Ext",
        "Lean.Meta.Tactic.Grind.Diseq"
      ]
    },
    "Lean.Meta.Tactic.Grind.PropagateInj": {
      "path": "Lean/Meta/Tactic/Grind/PropagateInj.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Init.Grind.Propagator",
        "Init.Grind.Injective",
        "Lean.Meta.Tactic.Grind.PropagatorAttr",
        "Lean.Meta.Tactic.Grind.Simp"
      ]
    },
    "Lean.Meta.Tactic.Grind.PropagatorAttr": {
      "path": "Lean/Meta/Tactic/Grind/PropagatorAttr.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Proof",
        "Lean.Compiler.InitAttr",
        "Init.Grind"
      ]
    },
    "Lean.Meta.Tactic.Grind.ProveEq": {
      "path": "Lean/Meta/Tactic/Grind/ProveEq.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Simp"
      ]
    },
    "Lean.Meta.Tactic.Grind.ReflCmp": {
      "path": "Lean/Meta/Tactic/Grind/ReflCmp.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.SynthInstance",
        "Lean.Meta.Tactic.Grind.Util"
      ]
    },
    "Lean.Meta.Tactic.Grind.RegisterCommand": {
      "path": "Lean/Meta/Tactic/Grind/RegisterCommand.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Attr"
      ]
    },
    "Lean.Meta.Tactic.Grind.RevertAll": {
      "path": "Lean/Meta/Tactic/Grind/RevertAll.olean",
      "imports": [
        "Lean.Meta.Tactic.Revert"
      ]
    },
    "Lean.Meta.Tactic.Grind.Simp": {
      "path": "Lean/Meta/Tactic/Grind/Simp.olean",
      "imports": [
        "Init.Grind.Lemmas",
        "Lean.Meta.Tactic.Simp.Main",
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Util",
        "Lean.Meta.Tactic.Grind.MatchDiscrOnly",
        "Lean.Meta.Tactic.Grind.MarkNestedSubsingletons"
      ]
    },
    "Lean.Meta.Tactic.Grind.SimpUtil": {
      "path": "Lean/Meta/Tactic/Grind/SimpUtil.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Simproc",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.MatchDiscrOnly",
        "Lean.Meta.Tactic.Grind.MatchCond",
        "Lean.Meta.Tactic.Grind.ForallProp",
        "Lean.Meta.Tactic.Grind.Arith.Simproc",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.List",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Core",
        "Lean.Meta.Tactic.Grind.Util",
        "Init.Grind.Norm"
      ]
    },
    "Lean.Meta.Tactic.Grind.Solve": {
      "path": "Lean/Meta/Tactic/Grind/Solve.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Finish"
      ]
    },
    "Lean.Meta.Tactic.Grind.Split": {
      "path": "Lean/Meta/Tactic/Grind/Split.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Action",
        "Lean.Meta.Tactic.Grind.Anchor",
        "Lean.Meta.Tactic.Grind.Intro",
        "Lean.Meta.Tactic.Grind.Util",
        "Lean.Meta.Tactic.Grind.CasesMatch",
        "Lean.Meta.Tactic.Grind.Internalize"
      ]
    },
    "Lean.Meta.Tactic.Grind.SynthInstance": {
      "path": "Lean/Meta/Tactic/Grind/SynthInstance.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.SynthInstance"
      ]
    },
    "Lean.Meta.Tactic.Grind.Theorems": {
      "path": "Lean/Meta/Tactic/Grind/Theorems.olean",
      "imports": [
        "Lean.HeadIndex",
        "Lean.Meta.Basic",
        "Lean.Meta.Eqns"
      ]
    },
    "Lean.Meta.Tactic.Grind.Types": {
      "path": "Lean/Meta/Tactic/Grind/Types.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Types",
        "Lean.Meta.Tactic.Grind.AlphaShareCommon",
        "Lean.Meta.Tactic.Grind.Attr",
        "Lean.Meta.Tactic.Grind.CheckResult",
        "Lean.Meta.Tactic.Grind.Extension",
        "Init.Data.Queue",
        "Lean.Meta.Tactic.Grind.ExprPtr",
        "Lean.HeadIndex",
        "Lean.Meta.Tactic.Grind.ExtAttr",
        "Lean.Meta.AbstractNestedProofs",
        "Lean.Meta.Match.MatchEqsExt",
        "Lean.PrettyPrinter",
        "Lean.Parser.Do"
      ]
    },
    "Lean.Meta.Tactic.Grind.Util": {
      "path": "Lean/Meta/Tactic/Grind/Util.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Simproc",
        "Init.Simproc",
        "Lean.Meta.AbstractNestedProofs",
        "Lean.Meta.Tactic.Clear"
      ]
    },
    "Lean.Meta.Tactic.Grind.VarRename": {
      "path": "Lean/Meta/Tactic/Grind/VarRename.olean",
      "imports": [
        "Init.Data.Array.QSort",
        "Std.Data.HashSet",
        "Init.Data.Hashable"
      ]
    },
    "Lean.Meta.Tactic.Grind": {
      "path": "Lean/Meta/Tactic/Grind.olean",
      "imports": [
        "Lean.Meta.Tactic.Grind.Attr",
        "Lean.Meta.Tactic.Grind.RevertAll",
        "Lean.Meta.Tactic.Grind.Types",
        "Lean.Meta.Tactic.Grind.Util",
        "Lean.Meta.Tactic.Grind.Cases",
        "Lean.Meta.Tactic.Grind.Injection",
        "Lean.Meta.Tactic.Grind.Core",
        "Lean.Meta.Tactic.Grind.Canon",
        "Lean.Meta.Tactic.Grind.MarkNestedSubsingletons",
        "Lean.Meta.Tactic.Grind.Inv",
        "Lean.Meta.Tactic.Grind.Proof",
        "Lean.Meta.Tactic.Grind.Propagate",
        "Lean.Meta.Tactic.Grind.PP",
        "Lean.Meta.Tactic.Grind.Simp",
        "Lean.Meta.Tactic.Grind.Ctor",
        "Lean.Meta.Tactic.Grind.Parser",
        "Lean.Meta.Tactic.Grind.EMatchTheorem",
        "Lean.Meta.Tactic.Grind.EMatch",
        "Lean.Meta.Tactic.Grind.Main",
        "Lean.Meta.Tactic.Grind.CasesMatch",
        "Lean.Meta.Tactic.Grind.Arith",
        "Lean.Meta.Tactic.Grind.Ext",
        "Lean.Meta.Tactic.Grind.MatchCond",
        "Lean.Meta.Tactic.Grind.MatchDiscrOnly",
        "Lean.Meta.Tactic.Grind.Diseq",
        "Lean.Meta.Tactic.Grind.MBTC",
        "Lean.Meta.Tactic.Grind.Lookahead",
        "Lean.Meta.Tactic.Grind.LawfulEqCmp",
        "Lean.Meta.Tactic.Grind.ReflCmp",
        "Lean.Meta.Tactic.Grind.SynthInstance",
        "Lean.Meta.Tactic.Grind.AC",
        "Lean.Meta.Tactic.Grind.VarRename",
        "Lean.Meta.Tactic.Grind.ProofUtil",
        "Lean.Meta.Tactic.Grind.PropagateInj",
        "Lean.Meta.Tactic.Grind.Order",
        "Lean.Meta.Tactic.Grind.Anchor",
        "Lean.Meta.Tactic.Grind.Action",
        "Lean.Meta.Tactic.Grind.EMatchTheoremParam",
        "Lean.Meta.Tactic.Grind.EMatchAction",
        "Lean.Meta.Tactic.Grind.Filter",
        "Lean.Meta.Tactic.Grind.CollectParams",
        "Lean.Meta.Tactic.Grind.Finish",
        "Lean.Meta.Tactic.Grind.RegisterCommand",
        "Lean.Meta.Tactic.Grind.AlphaShareCommon",
        "Lean.Meta.Tactic.Grind.AlphaShareBuilder"
      ]
    },
    "Lean.Meta.Tactic.IndependentOf": {
      "path": "Lean/Meta/Tactic/IndependentOf.olean",
      "imports": [
        "Lean.Meta.CollectMVars",
        "Lean.Meta.Tactic.Util"
      ]
    },
    "Lean.Meta.Tactic.Induction": {
      "path": "Lean/Meta/Tactic/Induction.olean",
      "imports": [
        "Lean.Meta.RecursorInfo",
        "Lean.Meta.SynthInstance",
        "Lean.Meta.Tactic.Revert",
        "Lean.Meta.Tactic.Intro",
        "Lean.Meta.Tactic.FVarSubst"
      ]
    },
    "Lean.Meta.Tactic.Injection": {
      "path": "Lean/Meta/Tactic/Injection.olean",
      "imports": [
        "Lean.Meta.Tactic.Subst"
      ]
    },
    "Lean.Meta.Tactic.Intro": {
      "path": "Lean/Meta/Tactic/Intro.olean",
      "imports": [
        "Lean.Meta.Tactic.Util"
      ]
    },
    "Lean.Meta.Tactic.Lets": {
      "path": "Lean/Meta/Tactic/Lets.olean",
      "imports": [
        "Lean.Meta.Tactic.Replace",
        "Lean.Meta.LetToHave"
      ]
    },
    "Lean.Meta.Tactic.LibrarySearch": {
      "path": "Lean/Meta/Tactic/LibrarySearch.olean",
      "imports": [
        "Lean.Meta.LazyDiscrTree",
        "Lean.Meta.Tactic.SolveByElim",
        "Lean.Meta.Tactic.Grind.Main",
        "Lean.Util.Heartbeats",
        "Init.Grind.Util",
        "Init.Try",
        "Lean.Elab.Tactic.Basic"
      ]
    },
    "Lean.Meta.Tactic.NormCast": {
      "path": "Lean/Meta/Tactic/NormCast.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Attr",
        "Lean.Meta.CoeAttr"
      ]
    },
    "Lean.Meta.Tactic.Refl": {
      "path": "Lean/Meta/Tactic/Refl.olean",
      "imports": [
        "Lean.Meta.Reduce",
        "Lean.Meta.Tactic.Apply"
      ]
    },
    "Lean.Meta.Tactic.Rename": {
      "path": "Lean/Meta/Tactic/Rename.olean",
      "imports": [
        "Lean.Meta.Tactic.Util"
      ]
    },
    "Lean.Meta.Tactic.Repeat": {
      "path": "Lean/Meta/Tactic/Repeat.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.Tactic.Replace": {
      "path": "Lean/Meta/Tactic/Replace.olean",
      "imports": [
        "Lean.Elab.InfoTree.Main",
        "Lean.Meta.AppBuilder",
        "Lean.Meta.MatchUtil",
        "Lean.Meta.Tactic.Assert"
      ]
    },
    "Lean.Meta.Tactic.Revert": {
      "path": "Lean/Meta/Tactic/Revert.olean",
      "imports": [
        "Lean.Meta.Tactic.Clear"
      ]
    },
    "Lean.Meta.Tactic.Rewrite": {
      "path": "Lean/Meta/Tactic/Rewrite.olean",
      "imports": [
        "Lean.Meta.AppBuilder",
        "Lean.Meta.MatchUtil",
        "Lean.Meta.KAbstract",
        "Lean.Meta.Tactic.Apply",
        "Lean.Meta.BinderNameHint"
      ]
    },
    "Lean.Meta.Tactic.Rewrites": {
      "path": "Lean/Meta/Tactic/Rewrites.olean",
      "imports": [
        "Lean.Meta.LazyDiscrTree",
        "Lean.Meta.Tactic.Assumption",
        "Lean.Meta.Tactic.Rewrite",
        "Lean.Meta.Tactic.Refl",
        "Lean.Meta.Tactic.SolveByElim",
        "Lean.Meta.Tactic.TryThis",
        "Lean.Util.Heartbeats"
      ]
    },
    "Lean.Meta.Tactic.Rfl": {
      "path": "Lean/Meta/Tactic/Rfl.olean",
      "imports": [
        "Lean.Elab.Tactic.Basic",
        "Lean.Meta.Tactic.Refl"
      ]
    },
    "Lean.Meta.Tactic.Simp.Arith.Int.Basic": {
      "path": "Lean/Meta/Tactic/Simp/Arith/Int/Basic.olean",
      "imports": [
        "Init.Data.Int.Linear",
        "Lean.Util.SortExprs",
        "Lean.Meta.IntInstTesters",
        "Lean.Meta.AppBuilder",
        "Lean.Meta.KExprMap",
        "Lean.Data.RArray"
      ]
    },
    "Lean.Meta.Tactic.Simp.Arith.Int.Simp": {
      "path": "Lean/Meta/Tactic/Simp/Arith/Int/Simp.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Arith.Util",
        "Lean.Meta.Tactic.Simp.Arith.Int.Basic"
      ]
    },
    "Lean.Meta.Tactic.Simp.Arith.Int": {
      "path": "Lean/Meta/Tactic/Simp/Arith/Int.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Arith.Int.Basic",
        "Lean.Meta.Tactic.Simp.Arith.Int.Simp"
      ]
    },
    "Lean.Meta.Tactic.Simp.Arith.Nat.Basic": {
      "path": "Lean/Meta/Tactic/Simp/Arith/Nat/Basic.olean",
      "imports": [
        "Lean.Util.SortExprs",
        "Lean.Meta.KExprMap",
        "Lean.Data.RArray",
        "Lean.Meta.AppBuilder",
        "Lean.Meta.NatInstTesters"
      ]
    },
    "Lean.Meta.Tactic.Simp.Arith.Nat.Simp": {
      "path": "Lean/Meta/Tactic/Simp/Arith/Nat/Simp.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Arith.Util",
        "Lean.Meta.Tactic.Simp.Arith.Nat.Basic",
        "Lean.Meta.AppBuilder"
      ]
    },
    "Lean.Meta.Tactic.Simp.Arith.Nat": {
      "path": "Lean/Meta/Tactic/Simp/Arith/Nat.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Arith.Nat.Basic",
        "Lean.Meta.Tactic.Simp.Arith.Nat.Simp"
      ]
    },
    "Lean.Meta.Tactic.Simp.Arith.Util": {
      "path": "Lean/Meta/Tactic/Simp/Arith/Util.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.Tactic.Simp.Arith": {
      "path": "Lean/Meta/Tactic/Simp/Arith.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Arith.Nat",
        "Lean.Meta.Tactic.Simp.Arith.Int"
      ]
    },
    "Lean.Meta.Tactic.Simp.Attr": {
      "path": "Lean/Meta/Tactic/Simp/Attr.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Simproc"
      ]
    },
    "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Array": {
      "path": "Lean/Meta/Tactic/Simp/BuiltinSimprocs/Array.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat"
      ]
    },
    "Lean.Meta.Tactic.Simp.BuiltinSimprocs.BitVec": {
      "path": "Lean/Meta/Tactic/Simp/BuiltinSimprocs/BitVec.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Int"
      ]
    },
    "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Char": {
      "path": "Lean/Meta/Tactic/Simp/BuiltinSimprocs/Char.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.UInt"
      ]
    },
    "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Core": {
      "path": "Lean/Meta/Tactic/Simp/BuiltinSimprocs/Core.olean",
      "imports": [
        "Init.Simproc",
        "Lean.Meta.Tactic.Simp.Simproc"
      ]
    },
    "Lean.Meta.Tactic.Simp.BuiltinSimprocs.CtorIdx": {
      "path": "Lean/Meta/Tactic/Simp/BuiltinSimprocs/CtorIdx.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Simproc",
        "Init.Simproc",
        "Lean.Meta.Constructions.CtorIdx"
      ]
    },
    "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Fin": {
      "path": "Lean/Meta/Tactic/Simp/BuiltinSimprocs/Fin.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat"
      ]
    },
    "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Int": {
      "path": "Lean/Meta/Tactic/Simp/BuiltinSimprocs/Int.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat"
      ]
    },
    "Lean.Meta.Tactic.Simp.BuiltinSimprocs.List": {
      "path": "Lean/Meta/Tactic/Simp/BuiltinSimprocs/List.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat"
      ]
    },
    "Lean.Meta.Tactic.Simp.BuiltinSimprocs.MethodSpecs": {
      "path": "Lean/Meta/Tactic/Simp/BuiltinSimprocs/MethodSpecs.olean",
      "imports": [
        "Init.Simproc",
        "Lean.Meta.Tactic.Simp.Simproc",
        "Lean.Meta.MethodSpecs",
        "Lean.Meta.Tactic.Simp.Main"
      ]
    },
    "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat": {
      "path": "Lean/Meta/Tactic/Simp/BuiltinSimprocs/Nat.olean",
      "imports": [
        "Init.Simproc",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Util"
      ]
    },
    "Lean.Meta.Tactic.Simp.BuiltinSimprocs.SInt": {
      "path": "Lean/Meta/Tactic/Simp/BuiltinSimprocs/SInt.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Int"
      ]
    },
    "Lean.Meta.Tactic.Simp.BuiltinSimprocs.String": {
      "path": "Lean/Meta/Tactic/Simp/BuiltinSimprocs/String.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Char"
      ]
    },
    "Lean.Meta.Tactic.Simp.BuiltinSimprocs.UInt": {
      "path": "Lean/Meta/Tactic/Simp/BuiltinSimprocs/UInt.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat"
      ]
    },
    "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Util": {
      "path": "Lean/Meta/Tactic/Simp/BuiltinSimprocs/Util.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Simproc"
      ]
    },
    "Lean.Meta.Tactic.Simp.BuiltinSimprocs": {
      "path": "Lean/Meta/Tactic/Simp/BuiltinSimprocs.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Core",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Nat",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Fin",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.UInt",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.SInt",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Int",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Char",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.String",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.BitVec",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.List",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.Array",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.MethodSpecs",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs.CtorIdx"
      ]
    },
    "Lean.Meta.Tactic.Simp.Diagnostics": {
      "path": "Lean/Meta/Tactic/Simp/Diagnostics.olean",
      "imports": [
        "Lean.Meta.Diagnostics",
        "Lean.Meta.Tactic.Simp.Types"
      ]
    },
    "Lean.Meta.Tactic.Simp.LoopProtection": {
      "path": "Lean/Meta/Tactic/Simp/LoopProtection.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Types",
        "Lean.Linter.Basic"
      ]
    },
    "Lean.Meta.Tactic.Simp.Main": {
      "path": "Lean/Meta/Tactic/Simp/Main.olean",
      "imports": [
        "Lean.Meta.Tactic.Replace",
        "Lean.Meta.Tactic.Simp.Rewrite",
        "Lean.Meta.Tactic.Simp.Diagnostics",
        "Lean.Meta.Match.Value",
        "Lean.Util.CollectLooseBVars",
        "Lean.PrettyPrinter",
        "Lean.ExtraModUses"
      ]
    },
    "Lean.Meta.Tactic.Simp.RegisterCommand": {
      "path": "Lean/Meta/Tactic/Simp/RegisterCommand.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Simproc",
        "Lean.Meta.Tactic.Simp.Attr"
      ]
    },
    "Lean.Meta.Tactic.Simp.Rewrite": {
      "path": "Lean/Meta/Tactic/Simp/Rewrite.olean",
      "imports": [
        "Lean.Meta.ACLt",
        "Lean.Meta.Match.MatchEqsExt",
        "Lean.Meta.Tactic.UnifyEq",
        "Lean.Meta.Tactic.Simp.Arith",
        "Lean.Meta.Tactic.Simp.Attr",
        "Lean.Meta.BinderNameHint"
      ]
    },
    "Lean.Meta.Tactic.Simp.SimpAll": {
      "path": "Lean/Meta/Tactic/Simp/SimpAll.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.Main"
      ]
    },
    "Lean.Meta.Tactic.Simp.SimpCongrTheorems": {
      "path": "Lean/Meta/Tactic/Simp/SimpCongrTheorems.olean",
      "imports": [
        "Lean.Util.Recognizers",
        "Lean.Util.CollectMVars",
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.Tactic.Simp.SimpTheorems": {
      "path": "Lean/Meta/Tactic/Simp/SimpTheorems.olean",
      "imports": [
        "Lean.Meta.DiscrTree",
        "Lean.Meta.Tactic.AuxLemma",
        "Lean.DocString",
        "Lean.Meta.AppBuilder",
        "Lean.Meta.Eqns",
        "Lean.ExtraModUses"
      ]
    },
    "Lean.Meta.Tactic.Simp.Simproc": {
      "path": "Lean/Meta/Tactic/Simp/Simproc.olean",
      "imports": [
        "Lean.Compiler.InitAttr",
        "Lean.Meta.Tactic.Simp.Types"
      ]
    },
    "Lean.Meta.Tactic.Simp.Types": {
      "path": "Lean/Meta/Tactic/Simp/Types.olean",
      "imports": [
        "Lean.Meta.AppBuilder",
        "Lean.Meta.CongrTheorems",
        "Lean.Meta.Eqns",
        "Lean.Meta.Tactic.Simp.SimpTheorems",
        "Lean.Meta.Tactic.Simp.SimpCongrTheorems",
        "Lean.Meta.Tactic.Replace"
      ]
    },
    "Lean.Meta.Tactic.Simp": {
      "path": "Lean/Meta/Tactic/Simp.olean",
      "imports": [
        "Lean.Meta.Tactic.Simp.SimpTheorems",
        "Lean.Meta.Tactic.Simp.SimpCongrTheorems",
        "Lean.Meta.Tactic.Simp.Types",
        "Lean.Meta.Tactic.Simp.Main",
        "Lean.Meta.Tactic.Simp.Rewrite",
        "Lean.Meta.Tactic.Simp.SimpAll",
        "Lean.Meta.Tactic.Simp.Simproc",
        "Lean.Meta.Tactic.Simp.BuiltinSimprocs",
        "Lean.Meta.Tactic.Simp.RegisterCommand",
        "Lean.Meta.Tactic.Simp.Attr",
        "Lean.Meta.Tactic.Simp.Diagnostics",
        "Lean.Meta.Tactic.Simp.Arith"
      ]
    },
    "Lean.Meta.Tactic.SolveByElim": {
      "path": "Lean/Meta/Tactic/SolveByElim.olean",
      "imports": [
        "Init.Data.Sum",
        "Lean.LabelAttribute",
        "Lean.Meta.Tactic.Backtrack",
        "Lean.Meta.Tactic.Constructor",
        "Lean.Meta.Tactic.Repeat",
        "Lean.Meta.Tactic.Symm",
        "Lean.Elab.Term"
      ]
    },
    "Lean.Meta.Tactic.Split": {
      "path": "Lean/Meta/Tactic/Split.olean",
      "imports": [
        "Lean.Meta.Match.MatcherApp.Basic",
        "Lean.Meta.Tactic.Apply",
        "Lean.Meta.Tactic.Generalize",
        "Lean.Meta.Tactic.Simp.Types",
        "Lean.Meta.Tactic.Simp.Main",
        "Lean.Meta.Tactic.SplitIf"
      ]
    },
    "Lean.Meta.Tactic.SplitIf": {
      "path": "Lean/Meta/Tactic/SplitIf.olean",
      "imports": [
        "Lean.Meta.Tactic.Cases",
        "Lean.Meta.Tactic.Simp.Rewrite",
        "Lean.Meta.Tactic.Simp.Main"
      ]
    },
    "Lean.Meta.Tactic.Subst": {
      "path": "Lean/Meta/Tactic/Subst.olean",
      "imports": [
        "Lean.Meta.AppBuilder",
        "Lean.Meta.MatchUtil",
        "Lean.Meta.Tactic.Assert"
      ]
    },
    "Lean.Meta.Tactic.Symm": {
      "path": "Lean/Meta/Tactic/Symm.olean",
      "imports": [
        "Lean.Meta.Reduce",
        "Lean.Meta.Tactic.Assert",
        "Lean.Meta.DiscrTree",
        "Lean.Meta.AppBuilder"
      ]
    },
    "Lean.Meta.Tactic.Try.Collect": {
      "path": "Lean/Meta/Tactic/Try/Collect.olean",
      "imports": [
        "Init.Try",
        "Lean.Meta.Tactic.LibrarySearch",
        "Lean.Meta.Tactic.FunIndCollect",
        "Lean.Meta.Eqns"
      ]
    },
    "Lean.Meta.Tactic.Try": {
      "path": "Lean/Meta/Tactic/Try.olean",
      "imports": [
        "Lean.Meta.Tactic.Try.Collect"
      ]
    },
    "Lean.Meta.Tactic.TryThis": {
      "path": "Lean/Meta/Tactic/TryThis.olean",
      "imports": [
        "Lean.Elab.Tactic.Basic",
        "Lean.Server.CodeActions",
        "Lean.Widget.UserWidget",
        "Lean.Meta.Tactic.ExposeNames",
        "Lean.Meta.Hint",
        "Lean.Meta.Hint"
      ]
    },
    "Lean.Meta.Tactic.Unfold": {
      "path": "Lean/Meta/Tactic/Unfold.olean",
      "imports": [
        "Lean.Meta.Tactic.Delta",
        "Lean.Meta.Tactic.Simp.Main"
      ]
    },
    "Lean.Meta.Tactic.UnifyEq": {
      "path": "Lean/Meta/Tactic/UnifyEq.olean",
      "imports": [
        "Lean.Meta.Tactic.Injection"
      ]
    },
    "Lean.Meta.Tactic.Util": {
      "path": "Lean/Meta/Tactic/Util.olean",
      "imports": [
        "Lean.Util.ForEachExprWhere",
        "Lean.Meta.PPGoal",
        "Lean.Meta.AppBuilder"
      ]
    },
    "Lean.Meta.Tactic": {
      "path": "Lean/Meta/Tactic.olean",
      "imports": [
        "Lean.Meta.Tactic.Intro",
        "Lean.Meta.Tactic.Assumption",
        "Lean.Meta.Tactic.Contradiction",
        "Lean.Meta.Tactic.Apply",
        "Lean.Meta.Tactic.Revert",
        "Lean.Meta.Tactic.Clear",
        "Lean.Meta.Tactic.Assert",
        "Lean.Meta.Tactic.Rewrite",
        "Lean.Meta.Tactic.Generalize",
        "Lean.Meta.Tactic.Replace",
        "Lean.Meta.Tactic.Lets",
        "Lean.Meta.Tactic.Induction",
        "Lean.Meta.Tactic.Cases",
        "Lean.Meta.Tactic.ElimInfo",
        "Lean.Meta.Tactic.Delta",
        "Lean.Meta.Tactic.Constructor",
        "Lean.Meta.Tactic.Simp",
        "Lean.Meta.Tactic.AuxLemma",
        "Lean.Meta.Tactic.SplitIf",
        "Lean.Meta.Tactic.Split",
        "Lean.Meta.Tactic.TryThis",
        "Lean.Meta.Tactic.Cleanup",
        "Lean.Meta.Tactic.Unfold",
        "Lean.Meta.Tactic.Rename",
        "Lean.Meta.Tactic.AC",
        "Lean.Meta.Tactic.Refl",
        "Lean.Meta.Tactic.Congr",
        "Lean.Meta.Tactic.Repeat",
        "Lean.Meta.Tactic.NormCast",
        "Lean.Meta.Tactic.IndependentOf",
        "Lean.Meta.Tactic.Symm",
        "Lean.Meta.Tactic.Backtrack",
        "Lean.Meta.Tactic.SolveByElim",
        "Lean.Meta.Tactic.FunInd",
        "Lean.Meta.Tactic.Rfl",
        "Lean.Meta.Tactic.Rewrites",
        "Lean.Meta.Tactic.Grind",
        "Lean.Meta.Tactic.Ext",
        "Lean.Meta.Tactic.Try"
      ]
    },
    "Lean.Meta.Transform": {
      "path": "Lean/Meta/Transform.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Meta.TransparencyMode": {
      "path": "Lean/Meta/TransparencyMode.olean",
      "imports": [
        "Init.Data.UInt.Basic"
      ]
    },
    "Lean.Meta.TryThis": {
      "path": "Lean/Meta/TryThis.olean",
      "imports": [
        "Lean.Data.Lsp.Basic",
        "Lean.PrettyPrinter"
      ]
    },
    "Lean.Meta.UnificationHint": {
      "path": "Lean/Meta/UnificationHint.olean",
      "imports": [
        "Lean.Meta.SynthInstance"
      ]
    },
    "Lean.Meta.WHNF": {
      "path": "Lean/Meta/WHNF.olean",
      "imports": [
        "Lean.Structure",
        "Lean.Util.Recognizers",
        "Lean.Util.SafeExponentiation",
        "Lean.Meta.GetUnfoldableConst",
        "Lean.Meta.FunInfo",
        "Lean.Meta.CtorRecognizer",
        "Lean.Meta.Match.MatcherInfo",
        "Lean.Meta.Match.MatchPatternAttr",
        "Lean.Meta.Transform"
      ]
    },
    "Lean.Meta": {
      "path": "Lean/Meta.olean",
      "imports": [
        "Lean.Meta.Basic",
        "Lean.Meta.LevelDefEq",
        "Lean.Meta.WHNF",
        "Lean.Meta.InferType",
        "Lean.Meta.FunInfo",
        "Lean.Meta.ExprDefEq",
        "Lean.Meta.DecLevel",
        "Lean.Meta.DiscrTree",
        "Lean.Meta.Reduce",
        "Lean.Meta.Instances",
        "Lean.Meta.AbstractMVars",
        "Lean.Meta.SynthInstance",
        "Lean.Meta.AppBuilder",
        "Lean.Meta.Sorry",
        "Lean.Meta.Tactic",
        "Lean.Meta.KAbstract",
        "Lean.Meta.RecursorInfo",
        "Lean.Meta.GeneralizeTelescope",
        "Lean.Meta.Match",
        "Lean.Meta.ReduceEval",
        "Lean.Meta.Closure",
        "Lean.Meta.AbstractNestedProofs",
        "Lean.Meta.LetToHave",
        "Lean.Meta.ForEachExpr",
        "Lean.Meta.Transform",
        "Lean.Meta.PPGoal",
        "Lean.Meta.UnificationHint",
        "Lean.Meta.Inductive",
        "Lean.Meta.SizeOf",
        "Lean.Meta.IndPredBelow",
        "Lean.Meta.Coe",
        "Lean.Meta.CollectFVars",
        "Lean.Meta.GeneralizeVars",
        "Lean.Meta.Injective",
        "Lean.Meta.Structure",
        "Lean.Meta.Constructions",
        "Lean.Meta.CongrTheorems",
        "Lean.Meta.Eqns",
        "Lean.Meta.ExprLens",
        "Lean.Meta.ExprTraverse",
        "Lean.Meta.Eval",
        "Lean.Meta.CoeAttr",
        "Lean.Meta.Iterator",
        "Lean.Meta.LazyDiscrTree",
        "Lean.Meta.LitValues",
        "Lean.Meta.CheckTactic",
        "Lean.Meta.Canonicalizer",
        "Lean.Meta.Diagnostics",
        "Lean.Meta.BinderNameHint",
        "Lean.Meta.TryThis",
        "Lean.Meta.Hint",
        "Lean.Meta.MethodSpecs",
        "Lean.Meta.CtorIdxHInj",
        "Lean.Meta.Sym"
      ]
    },
    "Lean.MetavarContext": {
      "path": "Lean/MetavarContext.olean",
      "imports": [
        "Init.ShareCommon",
        "Lean.Util.MonadCache",
        "Lean.LocalContext",
        "Init.Data.Slice"
      ]
    },
    "Lean.Modifiers": {
      "path": "Lean/Modifiers.olean",
      "imports": [
        "Lean.EnvExtension"
      ]
    },
    "Lean.MonadEnv": {
      "path": "Lean/MonadEnv.olean",
      "imports": [
        "Lean.Elab.Exception",
        "Lean.Log",
        "Lean.AuxRecursor",
        "Lean.Compiler.Old"
      ]
    },
    "Lean.Namespace": {
      "path": "Lean/Namespace.olean",
      "imports": [
        "Lean.EnvExtension"
      ]
    },
    "Lean.Parser.Attr": {
      "path": "Lean/Parser/Attr.olean",
      "imports": [
        "Lean.Parser.Extra"
      ]
    },
    "Lean.Parser.Basic": {
      "path": "Lean/Parser/Basic.olean",
      "imports": [
        "Lean.Parser.Types"
      ]
    },
    "Lean.Parser.Command": {
      "path": "Lean/Parser/Command.olean",
      "imports": [
        "Lean.Parser.Do",
        "Lean.DocString.Parser",
        "Lean.Parser.Basic"
      ]
    },
    "Lean.Parser.Do": {
      "path": "Lean/Parser/Do.olean",
      "imports": [
        "Lean.Parser.Term"
      ]
    },
    "Lean.Parser.Extension": {
      "path": "Lean/Parser/Extension.olean",
      "imports": [
        "Lean.Parser.Basic",
        "Lean.ScopedEnvExtension",
        "Lean.BuiltinDocAttr"
      ]
    },
    "Lean.Parser.Extra": {
      "path": "Lean/Parser/Extra.olean",
      "imports": [
        "Lean.PrettyPrinter.Formatter",
        "Lean.PrettyPrinter.Parenthesizer",
        "Lean.Hygiene",
        "all",
        "all",
        "all"
      ]
    },
    "Lean.Parser.Level": {
      "path": "Lean/Parser/Level.olean",
      "imports": [
        "Lean.Parser.Extra"
      ]
    },
    "Lean.Parser.Module": {
      "path": "Lean/Parser/Module.olean",
      "imports": [
        "Lean.Parser.Command",
        "Lean.Parser.Extra"
      ]
    },
    "Lean.Parser.StrInterpolation": {
      "path": "Lean/Parser/StrInterpolation.olean",
      "imports": [
        "Lean.Parser.Basic"
      ]
    },
    "Lean.Parser.Syntax": {
      "path": "Lean/Parser/Syntax.olean",
      "imports": [
        "Lean.Parser.Command"
      ]
    },
    "Lean.Parser.Tactic.Doc": {
      "path": "Lean/Parser/Tactic/Doc.olean",
      "imports": [
        "Lean.Environment",
        "Lean.Elab.InfoTree.Main",
        "Lean.Parser.Attr",
        "Lean.Parser.Extension",
        "Lean.ExtraModUses"
      ]
    },
    "Lean.Parser.Tactic": {
      "path": "Lean/Parser/Tactic.olean",
      "imports": [
        "Lean.Parser.Term",
        "Lean.Parser.Tactic.Doc",
        "Std.Tactic.Do.Syntax"
      ]
    },
    "Lean.Parser.Term.Basic": {
      "path": "Lean/Parser/Term/Basic.olean",
      "imports": [
        "Lean.Parser.Attr",
        "Lean.Parser.Level",
        "Lean.Parser.Term.Doc",
        "Lean.Parser.Basic"
      ]
    },
    "Lean.Parser.Term.Doc": {
      "path": "Lean/Parser/Term/Doc.olean",
      "imports": [
        "Lean.Parser.Extension",
        "Init.Data.String.Search"
      ]
    },
    "Lean.Parser.Term": {
      "path": "Lean/Parser/Term.olean",
      "imports": [
        "Lean.Parser.Term.Basic",
        "Lean.Parser.Term.Basic",
        "Lean.Parser.Term.Doc",
        "Lean.DocString.Parser",
        "Lean.DocString.Formatter"
      ]
    },
    "Lean.Parser.Types": {
      "path": "Lean/Parser/Types.olean",
      "imports": [
        "Lean.Data.Trie",
        "Lean.DocString.Extension"
      ]
    },
    "Lean.Parser": {
      "path": "Lean/Parser.olean",
      "imports": [
        "Lean.Parser.Basic",
        "Lean.Parser.Level",
        "Lean.Parser.Term",
        "Lean.Parser.Tactic",
        "Lean.Parser.Command",
        "Lean.Parser.Module",
        "Lean.Parser.Syntax",
        "Lean.Parser.Do",
        "Lean.Parser.Tactic.Doc"
      ]
    },
    "Lean.ParserCompiler.Attribute": {
      "path": "Lean/ParserCompiler/Attribute.olean",
      "imports": [
        "Lean.Compiler.InitAttr",
        "Lean.ExtraModUses"
      ]
    },
    "Lean.ParserCompiler": {
      "path": "Lean/ParserCompiler.olean",
      "imports": [
        "Lean.Meta.ReduceEval",
        "Lean.Meta.WHNF",
        "Lean.KeyedDeclsAttribute",
        "Lean.ParserCompiler.Attribute",
        "Lean.Parser.Extension"
      ]
    },
    "Lean.PrettyPrinter.Basic": {
      "path": "Lean/PrettyPrinter/Basic.olean",
      "imports": [
        "Lean.KeyedDeclsAttribute"
      ]
    },
    "Lean.PrettyPrinter.Delaborator.Attributes": {
      "path": "Lean/PrettyPrinter/Delaborator/Attributes.olean",
      "imports": [
        "Lean.Attributes"
      ]
    },
    "Lean.PrettyPrinter.Delaborator.Basic": {
      "path": "Lean/PrettyPrinter/Delaborator/Basic.olean",
      "imports": [
        "Lean.KeyedDeclsAttribute",
        "Lean.PrettyPrinter.Delaborator.TopDownAnalyze",
        "Lean.Elab.InfoTree.Main",
        "Init.Data.ToString.Name",
        "Lean.ExtraModUses"
      ]
    },
    "Lean.PrettyPrinter.Delaborator.Builtins": {
      "path": "Lean/PrettyPrinter/Delaborator/Builtins.olean",
      "imports": [
        "Lean.PrettyPrinter.Delaborator.Basic",
        "Lean.Meta.CoeAttr",
        "Lean.Meta.Structure",
        "Lean.Parser.Command",
        "Lean.Parser.Command"
      ]
    },
    "Lean.PrettyPrinter.Delaborator.FieldNotation": {
      "path": "Lean/PrettyPrinter/Delaborator/FieldNotation.olean",
      "imports": [
        "Lean.Meta.WHNF",
        "Lean.PrettyPrinter.Delaborator.Attributes",
        "Lean.PrettyPrinter.Delaborator.Options"
      ]
    },
    "Lean.PrettyPrinter.Delaborator.Options": {
      "path": "Lean/PrettyPrinter/Delaborator/Options.olean",
      "imports": [
        "Lean.Data.Options"
      ]
    },
    "Lean.PrettyPrinter.Delaborator.SubExpr": {
      "path": "Lean/PrettyPrinter/Delaborator/SubExpr.olean",
      "imports": [
        "Lean.SubExpr"
      ]
    },
    "Lean.PrettyPrinter.Delaborator.TopDownAnalyze": {
      "path": "Lean/PrettyPrinter/Delaborator/TopDownAnalyze.olean",
      "imports": [
        "Lean.Meta.SynthInstance",
        "Lean.Util.FindMVar",
        "Lean.Util.FindLevelMVar",
        "Lean.Util.CollectLevelParams",
        "Lean.Util.ReplaceLevel",
        "Lean.PrettyPrinter.Delaborator.FieldNotation",
        "Lean.PrettyPrinter.Delaborator.SubExpr",
        "Lean.Elab.Config"
      ]
    },
    "Lean.PrettyPrinter.Delaborator": {
      "path": "Lean/PrettyPrinter/Delaborator.olean",
      "imports": [
        "Lean.PrettyPrinter.Delaborator.Options",
        "Lean.PrettyPrinter.Delaborator.SubExpr",
        "Lean.PrettyPrinter.Delaborator.TopDownAnalyze",
        "Lean.PrettyPrinter.Delaborator.Basic",
        "Lean.PrettyPrinter.Delaborator.Builtins"
      ]
    },
    "Lean.PrettyPrinter.Formatter": {
      "path": "Lean/PrettyPrinter/Formatter.olean",
      "imports": [
        "Lean.Parser.Extension",
        "Lean.Parser.StrInterpolation",
        "Lean.ParserCompiler.Attribute",
        "Lean.PrettyPrinter.Basic",
        "Lean.PrettyPrinter.Delaborator.Options",
        "Lean.ExtraModUses"
      ]
    },
    "Lean.PrettyPrinter.Parenthesizer": {
      "path": "Lean/PrettyPrinter/Parenthesizer.olean",
      "imports": [
        "Lean.Parser.Extension",
        "Lean.Parser.StrInterpolation",
        "Lean.ParserCompiler.Attribute",
        "Lean.PrettyPrinter.Basic",
        "Lean.PrettyPrinter.Delaborator.Options",
        "Lean.ExtraModUses"
      ]
    },
    "Lean.PrettyPrinter": {
      "path": "Lean/PrettyPrinter.olean",
      "imports": [
        "Lean.PrettyPrinter.Delaborator.Basic",
        "Lean.PrettyPrinter.Delaborator",
        "Lean.PrettyPrinter.Parenthesizer",
        "Lean.PrettyPrinter.Formatter",
        "Lean.Parser.Module",
        "Lean.ParserCompiler",
        "Lean.Util.NumObjs",
        "Lean.Util.ShareCommon"
      ]
    },
    "Lean.PrivateName": {
      "path": "Lean/PrivateName.olean",
      "imports": [
        "Init.Notation",
        "Init.Data.Option.Coe"
      ]
    },
    "Lean.ProjFns": {
      "path": "Lean/ProjFns.olean",
      "imports": [
        "Lean.EnvExtension"
      ]
    },
    "Lean.ReducibilityAttrs": {
      "path": "Lean/ReducibilityAttrs.olean",
      "imports": [
        "Lean.ScopedEnvExtension"
      ]
    },
    "Lean.Replay": {
      "path": "Lean/Replay.olean",
      "imports": [
        "Lean.AddDecl"
      ]
    },
    "Lean.ReservedNameAction": {
      "path": "Lean/ReservedNameAction.olean",
      "imports": [
        "Lean.CoreM"
      ]
    },
    "Lean.ResolveName": {
      "path": "Lean/ResolveName.olean",
      "imports": [
        "Lean.Modifiers",
        "Lean.Exception",
        "Lean.Namespace",
        "Lean.Log"
      ]
    },
    "Lean.Runtime": {
      "path": "Lean/Runtime.olean",
      "imports": [
        "Init.Prelude"
      ]
    },
    "Lean.ScopedEnvExtension": {
      "path": "Lean/ScopedEnvExtension.olean",
      "imports": [
        "Lean.Attributes"
      ]
    },
    "Lean.Server.AsyncList": {
      "path": "Lean/Server/AsyncList.olean",
      "imports": [
        "Lean.Server.ServerTask"
      ]
    },
    "Lean.Server.CodeActions.Attr": {
      "path": "Lean/Server/CodeActions/Attr.olean",
      "imports": [
        "Lean.Server.CodeActions.Basic",
        "Lean.Compiler.IR.CompilerM"
      ]
    },
    "Lean.Server.CodeActions.Basic": {
      "path": "Lean/Server/CodeActions/Basic.olean",
      "imports": [
        "Lean.Server.Requests"
      ]
    },
    "Lean.Server.CodeActions.Provider": {
      "path": "Lean/Server/CodeActions/Provider.olean",
      "imports": [
        "Std.Data.Iterators.Producers.Range",
        "Std.Data.Iterators.Combinators.StepSize",
        "Lean.Elab.BuiltinTerm",
        "Lean.Elab.BuiltinNotation",
        "Lean.Server.CodeActions.Attr"
      ]
    },
    "Lean.Server.CodeActions.UnknownIdentifier": {
      "path": "Lean/Server/CodeActions/UnknownIdentifier.olean",
      "imports": [
        "Lean.Server.Completion.CompletionInfoSelection",
        "Lean.Server.CodeActions.Basic"
      ]
    },
    "Lean.Server.CodeActions": {
      "path": "Lean/Server/CodeActions.olean",
      "imports": [
        "Lean.Server.CodeActions.Attr",
        "Lean.Server.CodeActions.Basic",
        "Lean.Server.CodeActions.Provider"
      ]
    },
    "Lean.Server.Completion.CompletionCollectors": {
      "path": "Lean/Server/Completion/CompletionCollectors.olean",
      "imports": [
        "Lean.Data.FuzzyMatching",
        "Lean.Elab.Tactic.Doc",
        "Lean.Server.Completion.CompletionResolution",
        "Lean.Server.Completion.EligibleHeaderDecls",
        "Lean.Server.RequestCancellation"
      ]
    },
    "Lean.Server.Completion.CompletionInfoSelection": {
      "path": "Lean/Server/Completion/CompletionInfoSelection.olean",
      "imports": [
        "Lean.Server.Completion.SyntheticCompletion"
      ]
    },
    "Lean.Server.Completion.CompletionItemCompression": {
      "path": "Lean/Server/Completion/CompletionItemCompression.olean",
      "imports": [
        "Lean.Data.Lsp.LanguageFeatures"
      ]
    },
    "Lean.Server.Completion.CompletionResolution": {
      "path": "Lean/Server/Completion/CompletionResolution.olean",
      "imports": [
        "Lean.Data.Lsp",
        "Lean.Server.Completion.CompletionInfoSelection",
        "Lean.Linter.Deprecated"
      ]
    },
    "Lean.Server.Completion.CompletionUtils": {
      "path": "Lean/Server/Completion/CompletionUtils.olean",
      "imports": [
        "Lean.Meta.WHNF"
      ]
    },
    "Lean.Server.Completion.EligibleHeaderDecls": {
      "path": "Lean/Server/Completion/EligibleHeaderDecls.olean",
      "imports": [
        "Lean.Meta.CompletionName",
        "Lean.Data.Lsp.LanguageFeatures",
        "Lean.AddDecl",
        "Lean.ProjFns",
        "Std.Sync.Mutex",
        "Lean.Linter.Deprecated"
      ]
    },
    "Lean.Server.Completion.ImportCompletion": {
      "path": "Lean/Server/Completion/ImportCompletion.olean",
      "imports": [
        "Lean.Util.LakePath",
        "Lean.Data.Lsp",
        "Lean.Parser.Module",
        "Lean.Parser.Module"
      ]
    },
    "Lean.Server.Completion.SyntheticCompletion": {
      "path": "Lean/Server/Completion/SyntheticCompletion.olean",
      "imports": [
        "Lean.Server.InfoUtils",
        "Lean.Server.Completion.CompletionUtils",
        "Lean.Parser.Term"
      ]
    },
    "Lean.Server.Completion": {
      "path": "Lean/Server/Completion.olean",
      "imports": [
        "Lean.Server.Completion.CompletionCollectors",
        "Std.Data.HashMap"
      ]
    },
    "Lean.Server.FileSource": {
      "path": "Lean/Server/FileSource.olean",
      "imports": [
        "Lean.Data.Lsp"
      ]
    },
    "Lean.Server.FileWorker.ExampleHover": {
      "path": "Lean/Server/FileWorker/ExampleHover.olean",
      "imports": [
        "Lean.Elab.Do"
      ]
    },
    "Lean.Server.FileWorker.InlayHints": {
      "path": "Lean/Server/FileWorker/InlayHints.olean",
      "imports": [
        "Lean.Server.GoTo",
        "Lean.Server.Requests"
      ]
    },
    "Lean.Server.FileWorker.RequestHandling": {
      "path": "Lean/Server/FileWorker/RequestHandling.olean",
      "imports": [
        "Lean.Server.FileWorker.ExampleHover",
        "Lean.Server.FileWorker.InlayHints",
        "Lean.Server.FileWorker.SemanticHighlighting",
        "Lean.Server.FileWorker.SignatureHelp",
        "Lean.Server.Completion",
        "Lean.Server.References",
        "Lean.Server.Completion.CompletionItemCompression",
        "Lean.Parser.Module",
        "Lean.Widget.Diff"
      ]
    },
    "Lean.Server.FileWorker.SemanticHighlighting": {
      "path": "Lean/Server/FileWorker/SemanticHighlighting.olean",
      "imports": [
        "Lean.Server.Requests",
        "Lean.DocString.Syntax",
        "Init.Data.List.Sort"
      ]
    },
    "Lean.Server.FileWorker.SetupFile": {
      "path": "Lean/Server/FileWorker/SetupFile.olean",
      "imports": [
        "Lean.Server.Utils",
        "Lean.Util.LakePath",
        "Lean.Server.ServerTask"
      ]
    },
    "Lean.Server.FileWorker.SignatureHelp": {
      "path": "Lean/Server/FileWorker/SignatureHelp.olean",
      "imports": [
        "Lean.Server.InfoUtils",
        "Lean.Data.Lsp",
        "Init.Data.List.Sort.Basic",
        "Lean.PrettyPrinter.Delaborator",
        "Lean.Parser.Term"
      ]
    },
    "Lean.Server.FileWorker.Utils": {
      "path": "Lean/Server/FileWorker/Utils.olean",
      "imports": [
        "Lean.Language.Lean.Types",
        "Lean.Server.Snapshots",
        "Lean.Server.AsyncList",
        "Init.Data.ByteArray.Extra"
      ]
    },
    "Lean.Server.FileWorker.WidgetRequests": {
      "path": "Lean/Server/FileWorker/WidgetRequests.olean",
      "imports": [
        "Lean.Server.Rpc.RequestHandling",
        "Lean.Server.FileWorker.RequestHandling",
        "Lean.PrettyPrinter.Delaborator.Builtins"
      ]
    },
    "Lean.Server.FileWorker": {
      "path": "Lean/Server/FileWorker.olean",
      "imports": [
        "Std.Sync.Channel",
        "Lean.Language.Lean",
        "Lean.Server.FileWorker.Utils",
        "Lean.Server.FileWorker.RequestHandling",
        "Lean.Server.FileWorker.WidgetRequests",
        "Lean.Server.FileWorker.SetupFile",
        "Lean.Server.Completion.ImportCompletion",
        "Lean.Server.CodeActions.UnknownIdentifier"
      ]
    },
    "Lean.Server.GoTo": {
      "path": "Lean/Server/GoTo.olean",
      "imports": [
        "Lean.Server.Utils",
        "Lean.Data.Lsp.Internal",
        "Lean.Util.CollectFVars",
        "Lean.Util.ForEachExpr",
        "Lean.Parser.Module"
      ]
    },
    "Lean.Server.InfoUtils": {
      "path": "Lean/Server/InfoUtils.olean",
      "imports": [
        "Lean.DocString",
        "Lean.PrettyPrinter",
        "Lean.Parser.Term"
      ]
    },
    "Lean.Server.Logging": {
      "path": "Lean/Server/Logging.olean",
      "imports": [
        "Lean.Data.JsonRpc",
        "Std.Time",
        "Lean.Data.Lsp.Extra",
        "Lean.Data.Lsp.InitShutdown"
      ]
    },
    "Lean.Server.ProtocolOverview": {
      "path": "Lean/Server/ProtocolOverview.olean",
      "imports": [
        "Lean.Server.FileWorker.WidgetRequests",
        "Lean.Widget.UserWidget"
      ]
    },
    "Lean.Server.References": {
      "path": "Lean/Server/References.olean",
      "imports": [
        "Lean.Data.Lsp.Internal",
        "Lean.Server.Utils",
        "Lean.Elab.Import"
      ]
    },
    "Lean.Server.RequestCancellation": {
      "path": "Lean/Server/RequestCancellation.olean",
      "imports": [
        "Lean.Server.ServerTask"
      ]
    },
    "Lean.Server.Requests": {
      "path": "Lean/Server/Requests.olean",
      "imports": [
        "Lean.Server.RequestCancellation",
        "Lean.Server.FileSource",
        "Lean.Server.FileWorker.Utils",
        "Std.Sync.Mutex"
      ]
    },
    "Lean.Server.Rpc.Basic": {
      "path": "Lean/Server/Rpc/Basic.olean",
      "imports": [
        "Init.Dynamic",
        "Lean.Data.Json.FromToJson.Basic"
      ]
    },
    "Lean.Server.Rpc.Deriving": {
      "path": "Lean/Server/Rpc/Deriving.olean",
      "imports": [
        "Lean.Elab.Deriving.Basic"
      ]
    },
    "Lean.Server.Rpc.RequestHandling": {
      "path": "Lean/Server/Rpc/RequestHandling.olean",
      "imports": [
        "Lean.Server.Requests"
      ]
    },
    "Lean.Server.Rpc": {
      "path": "Lean/Server/Rpc.olean",
      "imports": [
        "Lean.Server.Rpc.Basic",
        "Lean.Server.Rpc.Deriving",
        "Lean.Server.Rpc.RequestHandling"
      ]
    },
    "Lean.Server.ServerTask": {
      "path": "Lean/Server/ServerTask.olean",
      "imports": [
        "Init.Task"
      ]
    },
    "Lean.Server.Snapshots": {
      "path": "Lean/Server/Snapshots.olean",
      "imports": [
        "Lean.Elab.Import",
        "Lean.Elab.Command",
        "Lean.Widget.InteractiveDiagnostic"
      ]
    },
    "Lean.Server.Test.Cancel": {
      "path": "Lean/Server/Test/Cancel.olean",
      "imports": [
        "Lean.Elab.Tactic.Basic",
        "Lean.Elab.Tactic.Basic"
      ]
    },
    "Lean.Server.Test.Refs": {
      "path": "Lean/Server/Test/Refs.olean",
      "imports": [
        "Init.Prelude"
      ]
    },
    "Lean.Server.Test.Runner": {
      "path": "Lean/Server/Test/Runner.olean",
      "imports": [
        "Lean.Widget",
        "Lean.Server.FileWorker.WidgetRequests",
        "Lean.Server.GoTo"
      ]
    },
    "Lean.Server.Test": {
      "path": "Lean/Server/Test.olean",
      "imports": [
        "Lean.Server.Test.Cancel",
        "Lean.Server.Test.Runner",
        "Lean.Server.Test.Refs"
      ]
    },
    "Lean.Server.Utils": {
      "path": "Lean/Server/Utils.olean",
      "imports": [
        "Init.System.Uri",
        "Lean.Data.Lsp.Communication",
        "Lean.Data.Lsp.Diagnostics",
        "Lean.Data.Lsp.Extra",
        "Lean.Server.InfoUtils"
      ]
    },
    "Lean.Server.Watchdog": {
      "path": "Lean/Server/Watchdog.olean",
      "imports": [
        "Lean.Data.FuzzyMatching",
        "Lean.Server.Requests",
        "Lean.Server.References",
        "Lean.Server.Completion.CompletionUtils",
        "Init.Data.List.Sort",
        "Std.Sync.Channel",
        "Lean.Server.Logging"
      ]
    },
    "Lean.Server": {
      "path": "Lean/Server.olean",
      "imports": [
        "Lean.Server.Watchdog",
        "Lean.Server.FileWorker",
        "Lean.Server.Rpc",
        "Lean.Server.CodeActions",
        "Lean.Server.Test",
        "Lean.Server.ProtocolOverview"
      ]
    },
    "Lean.Setup": {
      "path": "Lean/Setup.olean",
      "imports": [
        "Lean.Data.Json.Parser",
        "Lean.Util.LeanOptions"
      ]
    },
    "Lean.Shell": {
      "path": "Lean/Shell.olean",
      "imports": [
        "Lean.Elab.Frontend",
        "Lean.Elab.ParseImportsFast",
        "Lean.Server.Watchdog",
        "Lean.Server.FileWorker",
        "Lean.Compiler.IR.EmitC"
      ]
    },
    "Lean.Structure": {
      "path": "Lean/Structure.olean",
      "imports": [
        "Lean.ProjFns",
        "Lean.Exception"
      ]
    },
    "Lean.SubExpr": {
      "path": "Lean/SubExpr.olean",
      "imports": [
        "Lean.Meta.Basic"
      ]
    },
    "Lean.Syntax": {
      "path": "Lean/Syntax.olean",
      "imports": [
        "Init.Data.Slice",
        "Init.Data.Hashable",
        "Lean.Data.Format",
        "Init.Data.Option.Coe"
      ]
    },
    "Lean.ToExpr": {
      "path": "Lean/ToExpr.olean",
      "imports": [
        "Lean.ToLevel",
        "Init.Data.Rat.Basic"
      ]
    },
    "Lean.ToLevel": {
      "path": "Lean/ToLevel.olean",
      "imports": [
        "Lean.Expr"
      ]
    },
    "Lean.Util.CollectAxioms": {
      "path": "Lean/Util/CollectAxioms.olean",
      "imports": [
        "Lean.MonadEnv"
      ]
    },
    "Lean.Util.CollectFVars": {
      "path": "Lean/Util/CollectFVars.olean",
      "imports": [
        "Lean.LocalContext"
      ]
    },
    "Lean.Util.CollectLevelMVars": {
      "path": "Lean/Util/CollectLevelMVars.olean",
      "imports": [
        "Lean.Expr"
      ]
    },
    "Lean.Util.CollectLevelParams": {
      "path": "Lean/Util/CollectLevelParams.olean",
      "imports": [
        "Lean.Expr"
      ]
    },
    "Lean.Util.CollectLooseBVars": {
      "path": "Lean/Util/CollectLooseBVars.olean",
      "imports": [
        "Lean.Expr"
      ]
    },
    "Lean.Util.CollectMVars": {
      "path": "Lean/Util/CollectMVars.olean",
      "imports": [
        "Lean.Expr"
      ]
    },
    "Lean.Util.Diff": {
      "path": "Lean/Util/Diff.olean",
      "imports": [
        "Init.Data.Array.Subarray.Split",
        "Init.Data.Slice.Array.Iterator",
        "Init.Data.Range",
        "Std.Data.HashMap.Basic",
        "Init.Data.Iterators.Combinators.ULift",
        "Init.Data.String.Basic"
      ]
    },
    "Lean.Util.FVarSubset": {
      "path": "Lean/Util/FVarSubset.olean",
      "imports": [
        "Lean.Util.CollectFVars",
        "Lean.Util.FindExpr"
      ]
    },
    "Lean.Util.FindExpr": {
      "path": "Lean/Util/FindExpr.olean",
      "imports": [
        "Lean.Expr"
      ]
    },
    "Lean.Util.FindLevelMVar": {
      "path": "Lean/Util/FindLevelMVar.olean",
      "imports": [
        "Lean.Expr"
      ]
    },
    "Lean.Util.FindMVar": {
      "path": "Lean/Util/FindMVar.olean",
      "imports": [
        "Lean.Expr"
      ]
    },
    "Lean.Util.FoldConsts": {
      "path": "Lean/Util/FoldConsts.olean",
      "imports": [
        "Lean.Util.PtrSet",
        "Lean.Declaration"
      ]
    },
    "Lean.Util.ForEachExpr": {
      "path": "Lean/Util/ForEachExpr.olean",
      "imports": [
        "Lean.Expr",
        "Lean.Util.MonadCache"
      ]
    },
    "Lean.Util.ForEachExprWhere": {
      "path": "Lean/Util/ForEachExprWhere.olean",
      "imports": [
        "Lean.Expr",
        "Lean.Util.MonadCache"
      ]
    },
    "Lean.Util.HasConstCache": {
      "path": "Lean/Util/HasConstCache.olean",
      "imports": [
        "Lean.Expr",
        "Std.Data.HashMap.Raw"
      ]
    },
    "Lean.Util.Heartbeats": {
      "path": "Lean/Util/Heartbeats.olean",
      "imports": [
        "Lean.CoreM"
      ]
    },
    "Lean.Util.InstantiateLevelParams": {
      "path": "Lean/Util/InstantiateLevelParams.olean",
      "imports": [
        "Lean.Util.ReplaceExpr"
      ]
    },
    "Lean.Util.LakePath": {
      "path": "Lean/Util/LakePath.olean",
      "imports": [
        "Init.System.IO"
      ]
    },
    "Lean.Util.LeanOptions": {
      "path": "Lean/Util/LeanOptions.olean",
      "imports": [
        "Lean.Data.Json.FromToJson.Basic"
      ]
    },
    "Lean.Util.MonadBacktrack": {
      "path": "Lean/Util/MonadBacktrack.olean",
      "imports": [
        "Init.Control.Except",
        "Init.Data.Option.Coe"
      ]
    },
    "Lean.Util.MonadCache": {
      "path": "Lean/Util/MonadCache.olean",
      "imports": [
        "Std.Data.HashMap.Basic"
      ]
    },
    "Lean.Util.NumApps": {
      "path": "Lean/Util/NumApps.olean",
      "imports": [
        "Lean.Expr",
        "Lean.Util.PtrSet"
      ]
    },
    "Lean.Util.NumObjs": {
      "path": "Lean/Util/NumObjs.olean",
      "imports": [
        "Lean.Expr",
        "Lean.Util.PtrSet"
      ]
    },
    "Lean.Util.OccursCheck": {
      "path": "Lean/Util/OccursCheck.olean",
      "imports": [
        "Lean.MetavarContext"
      ]
    },
    "Lean.Util.PPExt": {
      "path": "Lean/Util/PPExt.olean",
      "imports": [
        "Lean.Elab.InfoTree.Types"
      ]
    },
    "Lean.Util.ParamMinimizer": {
      "path": "Lean/Util/ParamMinimizer.olean",
      "imports": [
        "Init.Data.Array.Basic",
        "Init.While",
        "Init.Data.Range.Polymorphic"
      ]
    },
    "Lean.Util.Path": {
      "path": "Lean/Util/Path.olean",
      "imports": [
        "Init.System.IO",
        "Init.Data.ToString.Name",
        "Init.Data.String.TakeDrop"
      ]
    },
    "Lean.Util.Profile": {
      "path": "Lean/Util/Profile.olean",
      "imports": [
        "Init.Data.OfScientific",
        "Lean.Data.Options"
      ]
    },
    "Lean.Util.Profiler": {
      "path": "Lean/Util/Profiler.olean",
      "imports": [
        "Lean.Util.Trace"
      ]
    },
    "Lean.Util.PtrSet": {
      "path": "Lean/Util/PtrSet.olean",
      "imports": [
        "Init.Data.Hashable",
        "Std.Data.HashSet.Basic"
      ]
    },
    "Lean.Util.RecDepth": {
      "path": "Lean/Util/RecDepth.olean",
      "imports": [
        "Lean.Data.Options"
      ]
    },
    "Lean.Util.Recognizers": {
      "path": "Lean/Util/Recognizers.olean",
      "imports": [
        "Lean.Environment"
      ]
    },
    "Lean.Util.ReplaceExpr": {
      "path": "Lean/Util/ReplaceExpr.olean",
      "imports": [
        "Lean.Expr",
        "Lean.Util.PtrSet"
      ]
    },
    "Lean.Util.ReplaceLevel": {
      "path": "Lean/Util/ReplaceLevel.olean",
      "imports": [
        "Lean.Expr"
      ]
    },
    "Lean.Util.Reprove": {
      "path": "Lean/Util/Reprove.olean",
      "imports": [
        "Lean.Elab.Command",
        "Lean.Elab.Tactic.Basic"
      ]
    },
    "Lean.Util.SCC": {
      "path": "Lean/Util/SCC.olean",
      "imports": [
        "Std.Data.HashMap.Basic",
        "Init.Data.Option.Coe"
      ]
    },
    "Lean.Util.SafeExponentiation": {
      "path": "Lean/Util/SafeExponentiation.olean",
      "imports": [
        "Lean.CoreM"
      ]
    },
    "Lean.Util.ShareCommon": {
      "path": "Lean/Util/ShareCommon.olean",
      "imports": [
        "Init.ShareCommon",
        "Std.Data.HashSet.Basic",
        "Lean.Data.PersistentHashSet"
      ]
    },
    "Lean.Util.Sorry": {
      "path": "Lean/Util/Sorry.olean",
      "imports": [
        "Lean.Util.FindExpr",
        "Lean.Declaration"
      ]
    },
    "Lean.Util.SortExprs": {
      "path": "Lean/Util/SortExprs.olean",
      "imports": [
        "Lean.Expr"
      ]
    },
    "Lean.Util.TestExtern": {
      "path": "Lean/Util/TestExtern.olean",
      "imports": [
        "Lean.Meta.Tactic.Unfold",
        "Lean.Meta.Eval",
        "Lean.Compiler.ImplementedByAttr",
        "Lean.Elab.Command"
      ]
    },
    "Lean.Util.Trace": {
      "path": "Lean/Util/Trace.olean",
      "imports": [
        "Lean.Elab.Exception",
        "Lean.Log"
      ]
    },
    "Lean.Util": {
      "path": "Lean/Util.olean",
      "imports": [
        "Lean.Util.CollectFVars",
        "Lean.Util.CollectLevelParams",
        "Lean.Util.CollectMVars",
        "Lean.Util.CollectLevelMVars",
        "Lean.Util.CollectLooseBVars",
        "Lean.Util.FindMVar",
        "Lean.Util.FindLevelMVar",
        "Lean.Util.MonadCache",
        "Lean.Util.PPExt",
        "Lean.Util.Path",
        "Lean.Util.Profile",
        "Lean.Util.RecDepth",
        "Lean.Util.ShareCommon",
        "Lean.Util.Sorry",
        "Lean.Util.Trace",
        "Lean.Util.FindExpr",
        "Lean.Util.ReplaceExpr",
        "Lean.Util.ForEachExpr",
        "Lean.Util.ForEachExprWhere",
        "Lean.Util.ReplaceLevel",
        "Lean.Util.FoldConsts",
        "Lean.Util.SCC",
        "Lean.Util.TestExtern",
        "Lean.Util.OccursCheck",
        "Lean.Util.HasConstCache",
        "Lean.Util.Heartbeats",
        "Lean.Util.SafeExponentiation",
        "Lean.Util.NumObjs",
        "Lean.Util.NumApps",
        "Lean.Util.FVarSubset",
        "Lean.Util.SortExprs",
        "Lean.Util.Reprove",
        "Lean.Util.ParamMinimizer"
      ]
    },
    "Lean.Widget.Basic": {
      "path": "Lean/Widget/Basic.olean",
      "imports": [
        "Lean.Elab.InfoTree",
        "Lean.Server.InfoUtils"
      ]
    },
    "Lean.Widget.Commands": {
      "path": "Lean/Widget/Commands.olean",
      "imports": [
        "Lean.Widget.UserWidget"
      ]
    },
    "Lean.Widget.Diff": {
      "path": "Lean/Widget/Diff.olean",
      "imports": [
        "Lean.Widget.InteractiveGoal"
      ]
    },
    "Lean.Widget.InteractiveCode": {
      "path": "Lean/Widget/InteractiveCode.olean",
      "imports": [
        "Lean.Widget.TaggedText",
        "Lean.Widget.Basic"
      ]
    },
    "Lean.Widget.InteractiveDiagnostic": {
      "path": "Lean/Widget/InteractiveDiagnostic.olean",
      "imports": [
        "Lean.Server.Utils",
        "Lean.Widget.InteractiveGoal",
        "Init.Data.Array.Subarray.Split",
        "Lean.Linter.UnusedVariables"
      ]
    },
    "Lean.Widget.InteractiveGoal": {
      "path": "Lean/Widget/InteractiveGoal.olean",
      "imports": [
        "Lean.Widget.InteractiveCode",
        "Lean.Data.Lsp.Extra"
      ]
    },
    "Lean.Widget.TaggedText": {
      "path": "Lean/Widget/TaggedText.olean",
      "imports": [
        "Lean.Server.Rpc.Basic"
      ]
    },
    "Lean.Widget.Types": {
      "path": "Lean/Widget/Types.olean",
      "imports": [
        "Lean.Server.Rpc.Basic"
      ]
    },
    "Lean.Widget.UserWidget": {
      "path": "Lean/Widget/UserWidget.olean",
      "imports": [
        "Lean.Elab.Eval",
        "Lean.Server.Rpc.RequestHandling",
        "Lean.Elab.Command"
      ]
    },
    "Lean.Widget": {
      "path": "Lean/Widget.olean",
      "imports": [
        "Lean.Widget.InteractiveCode",
        "Lean.Widget.InteractiveDiagnostic",
        "Lean.Widget.InteractiveGoal",
        "Lean.Widget.TaggedText",
        "Lean.Widget.UserWidget",
        "Lean.Widget.Commands"
      ]
    },
    "Lean": {
      "path": "Lean.olean",
      "imports": [
        "Lean.Data",
        "Lean.Compiler",
        "Lean.Environment",
        "Lean.Modifiers",
        "Lean.ProjFns",
        "Lean.Runtime",
        "Lean.ResolveName",
        "Lean.Attributes",
        "Lean.Parser",
        "Lean.ReducibilityAttrs",
        "Lean.Elab",
        "Lean.Class",
        "Lean.LocalContext",
        "Lean.MetavarContext",
        "Lean.AuxRecursor",
        "Lean.Meta",
        "Lean.Util",
        "Lean.Structure",
        "Lean.PrettyPrinter",
        "Lean.CoreM",
        "Lean.ReservedNameAction",
        "Lean.InternalExceptionId",
        "Lean.Server",
        "Lean.ScopedEnvExtension",
        "Lean.DocString",
        "Lean.DeclarationRange",
        "Lean.LoadDynlib",
        "Lean.Widget",
        "Lean.Log",
        "Lean.Linter",
        "Lean.SubExpr",
        "Lean.LabelAttribute",
        "Lean.AddDecl",
        "Lean.Replay",
        "Lean.PrivateName",
        "Lean.LibrarySuggestions",
        "Lean.Namespace",
        "Lean.EnvExtension",
        "Lean.ErrorExplanation",
        "Lean.ErrorExplanations",
        "Lean.DefEqAttrib",
        "Lean.Shell",
        "Lean.ExtraModUses"
      ]
    },
    "Leanc": {
      "path": "Leanc.olean",
      "imports": [
        "Lean.Compiler.FFI"
      ]
    },
    "Std.Data.ByteSlice": {
      "path": "Std/Data/ByteSlice.olean",
      "imports": [
        "Init.Data.ByteArray",
        "Init.Data.Slice.Basic",
        "Init.Data.Slice.Notation",
        "Init.Data.Range.Polymorphic.Nat"
      ]
    },
    "Std.Data.DHashMap.AdditionalOperations": {
      "path": "Std/Data/DHashMap/AdditionalOperations.olean",
      "imports": [
        "Std.Data.DHashMap.Internal.Raw",
        "Std.Data.DHashMap.Internal.WF"
      ]
    },
    "Std.Data.DHashMap.Basic": {
      "path": "Std/Data/DHashMap/Basic.olean",
      "imports": [
        "Std.Data.DHashMap.Raw",
        "all"
      ]
    },
    "Std.Data.DHashMap.DecidableEquiv": {
      "path": "Std/Data/DHashMap/DecidableEquiv.olean",
      "imports": [
        "Std.Data.DHashMap.Internal.RawLemmas"
      ]
    },
    "Std.Data.DHashMap.Internal.AssocList.Basic": {
      "path": "Std/Data/DHashMap/Internal/AssocList/Basic.olean",
      "imports": [
        "Init.NotationExtra"
      ]
    },
    "Std.Data.DHashMap.Internal.AssocList.Iterator": {
      "path": "Std/Data/DHashMap/Internal/AssocList/Iterator.olean",
      "imports": [
        "Init.Data.Nat.Lemmas",
        "Init.Data.Iterators.Consumers",
        "Init.Data.Iterators.Internal.Termination",
        "Std.Data.DHashMap.Internal.AssocList.Basic"
      ]
    },
    "Std.Data.DHashMap.Internal.AssocList.Lemmas": {
      "path": "Std/Data/DHashMap/Internal/AssocList/Lemmas.olean",
      "imports": [
        "Std.Data.DHashMap.Internal.AssocList.Basic",
        "all",
        "Std.Data.Internal.List.Associative"
      ]
    },
    "Std.Data.DHashMap.Internal.Defs": {
      "path": "Std/Data/DHashMap/Internal/Defs.olean",
      "imports": [
        "Init.Data.Array.Lemmas",
        "Std.Data.DHashMap.RawDef",
        "Std.Data.Internal.List.Defs",
        "Std.Data.DHashMap.Internal.Index"
      ]
    },
    "Std.Data.DHashMap.Internal.HashesTo": {
      "path": "Std/Data/DHashMap/Internal/HashesTo.olean",
      "imports": [
        "Init.Data.LawfulHashable",
        "Std.Data.Internal.List.Associative",
        "Std.Data.DHashMap.Internal.Defs"
      ]
    },
    "Std.Data.DHashMap.Internal.Index": {
      "path": "Std/Data/DHashMap/Internal/Index.olean",
      "imports": [
        "Init.Data.UInt.Bitwise"
      ]
    },
    "Std.Data.DHashMap.Internal.Model": {
      "path": "Std/Data/DHashMap/Internal/Model.olean",
      "imports": [
        "Init.Data.Array.TakeDrop",
        "Std.Data.DHashMap.Basic",
        "all",
        "Std.Data.DHashMap.Internal.HashesTo",
        "Std.Data.DHashMap.Internal.AssocList.Lemmas"
      ]
    },
    "Std.Data.DHashMap.Internal.Raw": {
      "path": "Std/Data/DHashMap/Internal/Raw.olean",
      "imports": [
        "Std.Data.DHashMap.Basic",
        "all"
      ]
    },
    "Std.Data.DHashMap.Internal.RawLemmas": {
      "path": "Std/Data/DHashMap/Internal/RawLemmas.olean",
      "imports": [
        "all",
        "all",
        "Std.Data.DHashMap.Internal.WF",
        "all",
        "all",
        "all",
        "Std.Data.DHashMap.Basic"
      ]
    },
    "Std.Data.DHashMap.Internal.WF": {
      "path": "Std/Data/DHashMap/Internal/WF.olean",
      "imports": [
        "all",
        "all",
        "all",
        "Std.Data.DHashMap.Internal.Model",
        "all",
        "all"
      ]
    },
    "Std.Data.DHashMap.Iterator": {
      "path": "Std/Data/DHashMap/Iterator.olean",
      "imports": [
        "Std.Data.Iterators.Producers.Array",
        "Init.Data.Iterators.Combinators.FlatMap",
        "Std.Data.DHashMap.Basic",
        "Std.Data.DHashMap.Internal.AssocList.Iterator"
      ]
    },
    "Std.Data.DHashMap.IteratorLemmas": {
      "path": "Std/Data/DHashMap/IteratorLemmas.olean",
      "imports": [
        "Std.Data.Iterators",
        "Std.Data.DHashMap.Iterator",
        "all",
        "all",
        "all",
        "Init.Data.Iterators.Lemmas.Combinators",
        "all",
        "Std.Data.DHashMap.RawLemmas",
        "Std.Data.DHashMap.Lemmas"
      ]
    },
    "Std.Data.DHashMap.Lemmas": {
      "path": "Std/Data/DHashMap/Lemmas.olean",
      "imports": [
        "Std.Data.DHashMap.Internal.RawLemmas",
        "all",
        "Std.Data.DHashMap.AdditionalOperations",
        "all"
      ]
    },
    "Std.Data.DHashMap.Raw": {
      "path": "Std/Data/DHashMap/Raw.olean",
      "imports": [
        "Init.Data.LawfulHashable",
        "Std.Data.DHashMap.Internal.Defs",
        "all"
      ]
    },
    "Std.Data.DHashMap.RawDecidableEquiv": {
      "path": "Std/Data/DHashMap/RawDecidableEquiv.olean",
      "imports": [
        "Std.Data.DHashMap.Internal.RawLemmas"
      ]
    },
    "Std.Data.DHashMap.RawDef": {
      "path": "Std/Data/DHashMap/RawDef.olean",
      "imports": [
        "Std.Data.DHashMap.Internal.AssocList.Basic"
      ]
    },
    "Std.Data.DHashMap.RawLemmas": {
      "path": "Std/Data/DHashMap/RawLemmas.olean",
      "imports": [
        "Std.Data.DHashMap.Internal.Raw",
        "Std.Data.DHashMap.Internal.RawLemmas",
        "all"
      ]
    },
    "Std.Data.DHashMap": {
      "path": "Std/Data/DHashMap.olean",
      "imports": [
        "Std.Data.DHashMap.Basic",
        "Std.Data.DHashMap.AdditionalOperations",
        "Std.Data.DHashMap.Iterator",
        "Std.Data.DHashMap.Lemmas",
        "Std.Data.DHashMap.IteratorLemmas",
        "Std.Data.DHashMap.DecidableEquiv"
      ]
    },
    "Std.Data.DTreeMap.AdditionalOperations": {
      "path": "Std/Data/DTreeMap/AdditionalOperations.olean",
      "imports": [
        "Std.Data.DTreeMap.Raw.Basic",
        "Std.Data.DTreeMap.Internal.WF.Lemmas"
      ]
    },
    "Std.Data.DTreeMap.Basic": {
      "path": "Std/Data/DTreeMap/Basic.olean",
      "imports": [
        "Std.Data.DTreeMap.Internal.WF.Defs"
      ]
    },
    "Std.Data.DTreeMap.DecidableEquiv": {
      "path": "Std/Data/DTreeMap/DecidableEquiv.olean",
      "imports": [
        "Std.Data.DTreeMap.Internal.Lemmas",
        "Std.Data.DTreeMap.Raw"
      ]
    },
    "Std.Data.DTreeMap.Internal.Balanced": {
      "path": "Std/Data/DTreeMap/Internal/Balanced.olean",
      "imports": [
        "Init.Data.AC",
        "Std.Data.DTreeMap.Internal.Def"
      ]
    },
    "Std.Data.DTreeMap.Internal.Balancing": {
      "path": "Std/Data/DTreeMap/Internal/Balancing.olean",
      "imports": [
        "Init.Data.Ord.Basic",
        "Std.Data.DTreeMap.Internal.Balanced"
      ]
    },
    "Std.Data.DTreeMap.Internal.Cell": {
      "path": "Std/Data/DTreeMap/Internal/Cell.olean",
      "imports": [
        "Std.Data.Internal.List.Associative"
      ]
    },
    "Std.Data.DTreeMap.Internal.Def": {
      "path": "Std/Data/DTreeMap/Internal/Def.olean",
      "imports": [
        "Init.Data.SInt.Basic"
      ]
    },
    "Std.Data.DTreeMap.Internal.Lemmas": {
      "path": "Std/Data/DTreeMap/Internal/Lemmas.olean",
      "imports": [
        "Std.Data.HashMap.Basic",
        "Std.Data.HashMap.Basic",
        "Std.Data.DTreeMap.Internal.WF.Lemmas",
        "Init.Data.Order.ClassesExtra"
      ]
    },
    "Std.Data.DTreeMap.Internal.Model": {
      "path": "Std/Data/DTreeMap/Internal/Model.olean",
      "imports": [
        "Std.Data.DTreeMap.Internal.WF.Defs",
        "Std.Data.DTreeMap.Internal.Cell"
      ]
    },
    "Std.Data.DTreeMap.Internal.Operations": {
      "path": "Std/Data/DTreeMap/Internal/Operations.olean",
      "imports": [
        "Std.Data.DTreeMap.Internal.Balancing",
        "Std.Data.DTreeMap.Internal.Queries",
        "Init.Data.List.Control"
      ]
    },
    "Std.Data.DTreeMap.Internal.Ordered": {
      "path": "Std/Data/DTreeMap/Internal/Ordered.olean",
      "imports": [
        "Std.Data.DTreeMap.Internal.Def",
        "Std.Data.Internal.Cut",
        "Init.Data.List.Pairwise"
      ]
    },
    "Std.Data.DTreeMap.Internal.Queries": {
      "path": "Std/Data/DTreeMap/Internal/Queries.olean",
      "imports": [
        "Init.Data.Nat.Compare",
        "Std.Data.DTreeMap.Internal.Balanced",
        "Std.Data.DTreeMap.Internal.Ordered",
        "Init.BinderPredicates"
      ]
    },
    "Std.Data.DTreeMap.Internal.WF.Defs": {
      "path": "Std/Data/DTreeMap/Internal/WF/Defs.olean",
      "imports": [
        "Std.Data.DTreeMap.Internal.Operations"
      ]
    },
    "Std.Data.DTreeMap.Internal.WF.Lemmas": {
      "path": "Std/Data/DTreeMap/Internal/WF/Lemmas.olean",
      "imports": [
        "Std.Data.DTreeMap.Internal.Model",
        "all"
      ]
    },
    "Std.Data.DTreeMap.Internal.Zipper": {
      "path": "Std/Data/DTreeMap/Internal/Zipper.olean",
      "imports": [
        "Std.Data.Iterators.Lemmas.Producers.Slice",
        "Init.Data.Slice",
        "Std.Data.DTreeMap.Internal.Lemmas"
      ]
    },
    "Std.Data.DTreeMap.Iterator": {
      "path": "Std/Data/DTreeMap/Iterator.olean",
      "imports": [
        "Std.Data.DTreeMap.Raw.Iterator"
      ]
    },
    "Std.Data.DTreeMap.Lemmas": {
      "path": "Std/Data/DTreeMap/Lemmas.olean",
      "imports": [
        "Std.Data.DTreeMap.Internal.Lemmas",
        "Std.Data.DTreeMap.AdditionalOperations"
      ]
    },
    "Std.Data.DTreeMap.Raw.AdditionalOperations": {
      "path": "Std/Data/DTreeMap/Raw/AdditionalOperations.olean",
      "imports": [
        "Std.Data.DTreeMap.AdditionalOperations"
      ]
    },
    "Std.Data.DTreeMap.Raw.Basic": {
      "path": "Std/Data/DTreeMap/Raw/Basic.olean",
      "imports": [
        "Std.Data.DTreeMap.Basic"
      ]
    },
    "Std.Data.DTreeMap.Raw.DecidableEquiv": {
      "path": "Std/Data/DTreeMap/Raw/DecidableEquiv.olean",
      "imports": [
        "Std.Data.DTreeMap.Internal.Lemmas",
        "Std.Data.DTreeMap.Raw.Basic"
      ]
    },
    "Std.Data.DTreeMap.Raw.Iterator": {
      "path": "Std/Data/DTreeMap/Raw/Iterator.olean",
      "imports": [
        "Std.Data.DTreeMap.Internal.Zipper",
        "Std.Data.DTreeMap.Raw.Basic"
      ]
    },
    "Std.Data.DTreeMap.Raw.Lemmas": {
      "path": "Std/Data/DTreeMap/Raw/Lemmas.olean",
      "imports": [
        "Std.Data.DTreeMap.Internal.Lemmas",
        "Std.Data.DTreeMap.Raw.AdditionalOperations"
      ]
    },
    "Std.Data.DTreeMap.Raw.Slice": {
      "path": "Std/Data/DTreeMap/Raw/Slice.olean",
      "imports": [
        "Std.Data.DTreeMap.Internal.Ordered",
        "Std.Data.DTreeMap.Internal.Zipper",
        "Std.Data.DTreeMap.Raw.Basic"
      ]
    },
    "Std.Data.DTreeMap.Raw.WF": {
      "path": "Std/Data/DTreeMap/Raw/WF.olean",
      "imports": [
        "Std.Data.DTreeMap.Internal.Lemmas",
        "Std.Data.DTreeMap.Raw.AdditionalOperations"
      ]
    },
    "Std.Data.DTreeMap.Raw": {
      "path": "Std/Data/DTreeMap/Raw.olean",
      "imports": [
        "Std.Data.DTreeMap.Raw.Basic",
        "Std.Data.DTreeMap.Raw.AdditionalOperations",
        "Std.Data.DTreeMap.Raw.Lemmas",
        "Std.Data.DTreeMap.Raw.WF",
        "Std.Data.DTreeMap.Raw.Iterator",
        "Std.Data.DTreeMap.Raw.Slice",
        "Std.Data.DTreeMap.Raw.DecidableEquiv"
      ]
    },
    "Std.Data.DTreeMap.Slice": {
      "path": "Std/Data/DTreeMap/Slice.olean",
      "imports": [
        "Std.Data.DTreeMap.Raw.Slice"
      ]
    },
    "Std.Data.DTreeMap": {
      "path": "Std/Data/DTreeMap.olean",
      "imports": [
        "Std.Data.DTreeMap.Basic",
        "Std.Data.DTreeMap.AdditionalOperations",
        "Std.Data.DTreeMap.Lemmas",
        "Std.Data.DTreeMap.Iterator",
        "Std.Data.DTreeMap.Slice",
        "Std.Data.DTreeMap.DecidableEquiv"
      ]
    },
    "Std.Data.ExtDHashMap.Basic": {
      "path": "Std/Data/ExtDHashMap/Basic.olean",
      "imports": [
        "Std.Data.DHashMap.Lemmas",
        "all"
      ]
    },
    "Std.Data.ExtDHashMap.Lemmas": {
      "path": "Std/Data/ExtDHashMap/Lemmas.olean",
      "imports": [
        "Std.Data.ExtDHashMap.Basic",
        "all",
        "all",
        "all",
        "all"
      ]
    },
    "Std.Data.ExtDHashMap": {
      "path": "Std/Data/ExtDHashMap.olean",
      "imports": [
        "Std.Data.ExtDHashMap.Basic",
        "Std.Data.ExtDHashMap.Lemmas"
      ]
    },
    "Std.Data.ExtDTreeMap.Basic": {
      "path": "Std/Data/ExtDTreeMap/Basic.olean",
      "imports": [
        "Std.Data.DTreeMap.Lemmas"
      ]
    },
    "Std.Data.ExtDTreeMap.Lemmas": {
      "path": "Std/Data/ExtDTreeMap/Lemmas.olean",
      "imports": [
        "Std.Data.ExtDTreeMap.Basic"
      ]
    },
    "Std.Data.ExtDTreeMap": {
      "path": "Std/Data/ExtDTreeMap.olean",
      "imports": [
        "Std.Data.ExtDTreeMap.Basic",
        "Std.Data.ExtDTreeMap.Lemmas"
      ]
    },
    "Std.Data.ExtHashMap.Basic": {
      "path": "Std/Data/ExtHashMap/Basic.olean",
      "imports": [
        "Std.Data.ExtDHashMap.Basic"
      ]
    },
    "Std.Data.ExtHashMap.Lemmas": {
      "path": "Std/Data/ExtHashMap/Lemmas.olean",
      "imports": [
        "Std.Data.ExtHashMap.Basic",
        "all",
        "Std.Data.ExtDHashMap.Lemmas"
      ]
    },
    "Std.Data.ExtHashMap": {
      "path": "Std/Data/ExtHashMap.olean",
      "imports": [
        "Std.Data.ExtHashMap.Basic",
        "Std.Data.ExtHashMap.Lemmas"
      ]
    },
    "Std.Data.ExtHashSet.Basic": {
      "path": "Std/Data/ExtHashSet/Basic.olean",
      "imports": [
        "Std.Data.ExtHashMap.Basic"
      ]
    },
    "Std.Data.ExtHashSet.Lemmas": {
      "path": "Std/Data/ExtHashSet/Lemmas.olean",
      "imports": [
        "Std.Data.ExtHashMap.Lemmas",
        "Std.Data.ExtHashSet.Basic"
      ]
    },
    "Std.Data.ExtHashSet": {
      "path": "Std/Data/ExtHashSet.olean",
      "imports": [
        "Std.Data.ExtHashSet.Basic",
        "Std.Data.ExtHashSet.Lemmas"
      ]
    },
    "Std.Data.ExtTreeMap.Basic": {
      "path": "Std/Data/ExtTreeMap/Basic.olean",
      "imports": [
        "Std.Data.ExtDTreeMap.Basic"
      ]
    },
    "Std.Data.ExtTreeMap.Lemmas": {
      "path": "Std/Data/ExtTreeMap/Lemmas.olean",
      "imports": [
        "Std.Data.ExtDTreeMap.Lemmas",
        "Std.Data.ExtTreeMap.Basic"
      ]
    },
    "Std.Data.ExtTreeMap": {
      "path": "Std/Data/ExtTreeMap.olean",
      "imports": [
        "Std.Data.ExtTreeMap.Basic",
        "Std.Data.ExtTreeMap.Lemmas"
      ]
    },
    "Std.Data.ExtTreeSet.Basic": {
      "path": "Std/Data/ExtTreeSet/Basic.olean",
      "imports": [
        "Std.Data.ExtTreeMap.Basic"
      ]
    },
    "Std.Data.ExtTreeSet.Lemmas": {
      "path": "Std/Data/ExtTreeSet/Lemmas.olean",
      "imports": [
        "Std.Data.ExtTreeMap.Lemmas",
        "Std.Data.ExtTreeSet.Basic"
      ]
    },
    "Std.Data.ExtTreeSet": {
      "path": "Std/Data/ExtTreeSet.olean",
      "imports": [
        "Std.Data.ExtTreeSet.Basic",
        "Std.Data.ExtTreeSet.Lemmas"
      ]
    },
    "Std.Data.HashMap.AdditionalOperations": {
      "path": "Std/Data/HashMap/AdditionalOperations.olean",
      "imports": [
        "Std.Data.DHashMap.AdditionalOperations",
        "Std.Data.HashMap.Basic",
        "Std.Data.HashMap.Raw"
      ]
    },
    "Std.Data.HashMap.Basic": {
      "path": "Std/Data/HashMap/Basic.olean",
      "imports": [
        "Std.Data.DHashMap.Basic"
      ]
    },
    "Std.Data.HashMap.DecidableEquiv": {
      "path": "Std/Data/HashMap/DecidableEquiv.olean",
      "imports": [
        "Std.Data.DHashMap.DecidableEquiv",
        "Std.Data.HashMap.Basic"
      ]
    },
    "Std.Data.HashMap.Iterator": {
      "path": "Std/Data/HashMap/Iterator.olean",
      "imports": [
        "Std.Data.DHashMap.Iterator",
        "Std.Data.HashMap.Basic",
        "Std.Data.HashMap.Raw"
      ]
    },
    "Std.Data.HashMap.IteratorLemmas": {
      "path": "Std/Data/HashMap/IteratorLemmas.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Combinators",
        "Std.Data.DHashMap.IteratorLemmas",
        "Std.Data.HashMap.Iterator",
        "all",
        "Std.Data.HashMap.RawLemmas",
        "Std.Data.HashMap.Lemmas",
        "all"
      ]
    },
    "Std.Data.HashMap.Lemmas": {
      "path": "Std/Data/HashMap/Lemmas.olean",
      "imports": [
        "Std.Data.DHashMap.Lemmas",
        "Std.Data.HashMap.AdditionalOperations",
        "all"
      ]
    },
    "Std.Data.HashMap.Raw": {
      "path": "Std/Data/HashMap/Raw.olean",
      "imports": [
        "Std.Data.DHashMap.Raw"
      ]
    },
    "Std.Data.HashMap.RawDecidableEquiv": {
      "path": "Std/Data/HashMap/RawDecidableEquiv.olean",
      "imports": [
        "Std.Data.DHashMap.RawDecidableEquiv",
        "Std.Data.HashMap.Raw"
      ]
    },
    "Std.Data.HashMap.RawLemmas": {
      "path": "Std/Data/HashMap/RawLemmas.olean",
      "imports": [
        "Std.Data.DHashMap.RawLemmas",
        "Std.Data.HashMap.Raw",
        "all"
      ]
    },
    "Std.Data.HashMap": {
      "path": "Std/Data/HashMap.olean",
      "imports": [
        "Std.Data.HashMap.Basic",
        "Std.Data.HashMap.AdditionalOperations",
        "Std.Data.HashMap.Iterator",
        "Std.Data.HashMap.Lemmas",
        "Std.Data.HashMap.IteratorLemmas",
        "Std.Data.HashMap.DecidableEquiv"
      ]
    },
    "Std.Data.HashSet.Basic": {
      "path": "Std/Data/HashSet/Basic.olean",
      "imports": [
        "Std.Data.HashMap.Basic"
      ]
    },
    "Std.Data.HashSet.DecidableEquiv": {
      "path": "Std/Data/HashSet/DecidableEquiv.olean",
      "imports": [
        "Std.Data.HashMap.DecidableEquiv",
        "Std.Data.HashSet.Basic"
      ]
    },
    "Std.Data.HashSet.Iterator": {
      "path": "Std/Data/HashSet/Iterator.olean",
      "imports": [
        "Std.Data.HashMap.Iterator",
        "Std.Data.HashSet.Basic",
        "Std.Data.HashSet.Raw"
      ]
    },
    "Std.Data.HashSet.IteratorLemmas": {
      "path": "Std/Data/HashSet/IteratorLemmas.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Combinators",
        "Std.Data.DHashMap.IteratorLemmas",
        "all",
        "Std.Data.HashSet.Iterator",
        "all",
        "Std.Data.HashSet.RawLemmas",
        "Std.Data.HashSet.Lemmas",
        "all"
      ]
    },
    "Std.Data.HashSet.Lemmas": {
      "path": "Std/Data/HashSet/Lemmas.olean",
      "imports": [
        "Std.Data.HashMap.Lemmas",
        "Std.Data.HashSet.Basic"
      ]
    },
    "Std.Data.HashSet.Raw": {
      "path": "Std/Data/HashSet/Raw.olean",
      "imports": [
        "Std.Data.HashMap.Raw"
      ]
    },
    "Std.Data.HashSet.RawDecidableEquiv": {
      "path": "Std/Data/HashSet/RawDecidableEquiv.olean",
      "imports": [
        "Std.Data.HashMap.RawDecidableEquiv",
        "Std.Data.HashSet.Raw"
      ]
    },
    "Std.Data.HashSet.RawLemmas": {
      "path": "Std/Data/HashSet/RawLemmas.olean",
      "imports": [
        "Std.Data.HashMap.RawLemmas",
        "Std.Data.HashSet.Raw"
      ]
    },
    "Std.Data.HashSet": {
      "path": "Std/Data/HashSet.olean",
      "imports": [
        "Std.Data.HashSet.Basic",
        "Std.Data.HashSet.Iterator",
        "Std.Data.HashSet.Lemmas",
        "Std.Data.HashSet.IteratorLemmas",
        "Std.Data.HashSet.DecidableEquiv"
      ]
    },
    "Std.Data.Internal.Cut": {
      "path": "Std/Data/Internal/Cut.olean",
      "imports": [
        "Init.Data.Order.Ord",
        "Init.RCases"
      ]
    },
    "Std.Data.Internal.List.Associative": {
      "path": "Std/Data/Internal/List/Associative.olean",
      "imports": [
        "Init.Data.Option.Attach",
        "Init.Data.List.Perm",
        "Init.Data.List.Monadic",
        "Std.Data.Internal.List.Defs",
        "all",
        "Init.Data.Order.Ord",
        "Init.Data.Subtype.Order",
        "Init.Data.Order.ClassesExtra",
        "Init.Data.Order.LemmasExtra"
      ]
    },
    "Std.Data.Internal.List.Defs": {
      "path": "Std/Data/Internal/List/Defs.olean",
      "imports": [
        "Init.BinderPredicates"
      ]
    },
    "Std.Data.Iterators.Combinators.Drop": {
      "path": "Std/Data/Iterators/Combinators/Drop.olean",
      "imports": [
        "Std.Data.Iterators.Combinators.Monadic.Drop"
      ]
    },
    "Std.Data.Iterators.Combinators.DropWhile": {
      "path": "Std/Data/Iterators/Combinators/DropWhile.olean",
      "imports": [
        "Std.Data.Iterators.Combinators.Monadic.DropWhile"
      ]
    },
    "Std.Data.Iterators.Combinators.Monadic.Drop": {
      "path": "Std/Data/Iterators/Combinators/Monadic/Drop.olean",
      "imports": [
        "Init.Data.Iterators.Consumers.Loop",
        "Init.Data.Iterators.Internal.Termination"
      ]
    },
    "Std.Data.Iterators.Combinators.Monadic.DropWhile": {
      "path": "Std/Data/Iterators/Combinators/Monadic/DropWhile.olean",
      "imports": [
        "Init.Data.Nat.Lemmas",
        "Init.Data.Iterators.Consumers.Monadic.Collect",
        "Init.Data.Iterators.Consumers.Monadic.Loop",
        "Init.Data.Iterators.Internal.Termination",
        "Init.Data.Iterators.PostconditionMonad"
      ]
    },
    "Std.Data.Iterators.Combinators.Monadic.StepSize": {
      "path": "Std/Data/Iterators/Combinators/Monadic/StepSize.olean",
      "imports": [
        "Init.Data.Iterators.Internal.Termination",
        "Init.Data.Iterators.Consumers.Monadic.Access",
        "Init.Data.Iterators.Consumers.Monadic.Collect",
        "Init.Data.Iterators.Consumers.Monadic.Loop"
      ]
    },
    "Std.Data.Iterators.Combinators.Monadic.TakeWhile": {
      "path": "Std/Data/Iterators/Combinators/Monadic/TakeWhile.olean",
      "imports": [
        "Init.Data.Nat.Lemmas",
        "Init.Data.Iterators.Consumers.Monadic.Collect",
        "Init.Data.Iterators.Consumers.Monadic.Loop",
        "Init.Data.Iterators.Internal.Termination",
        "Init.Data.Iterators.PostconditionMonad"
      ]
    },
    "Std.Data.Iterators.Combinators.Monadic.Zip": {
      "path": "Std/Data/Iterators/Combinators/Monadic/Zip.olean",
      "imports": [
        "Init.Data.Option.Lemmas",
        "Init.Data.Iterators.Consumers.Loop",
        "Init.Data.Iterators.Internal.Termination"
      ]
    },
    "Std.Data.Iterators.Combinators.Monadic": {
      "path": "Std/Data/Iterators/Combinators/Monadic.olean",
      "imports": [
        "Std.Data.Iterators.Combinators.Monadic.TakeWhile",
        "Std.Data.Iterators.Combinators.Monadic.Drop",
        "Std.Data.Iterators.Combinators.Monadic.DropWhile",
        "Std.Data.Iterators.Combinators.Monadic.StepSize",
        "Std.Data.Iterators.Combinators.Monadic.Zip"
      ]
    },
    "Std.Data.Iterators.Combinators.StepSize": {
      "path": "Std/Data/Iterators/Combinators/StepSize.olean",
      "imports": [
        "Std.Data.Iterators.Combinators.Monadic.StepSize"
      ]
    },
    "Std.Data.Iterators.Combinators.TakeWhile": {
      "path": "Std/Data/Iterators/Combinators/TakeWhile.olean",
      "imports": [
        "Std.Data.Iterators.Combinators.Monadic.TakeWhile"
      ]
    },
    "Std.Data.Iterators.Combinators.Zip": {
      "path": "Std/Data/Iterators/Combinators/Zip.olean",
      "imports": [
        "Std.Data.Iterators.Combinators.Monadic.Zip"
      ]
    },
    "Std.Data.Iterators.Combinators": {
      "path": "Std/Data/Iterators/Combinators.olean",
      "imports": [
        "Std.Data.Iterators.Combinators.Monadic",
        "Std.Data.Iterators.Combinators.TakeWhile",
        "Std.Data.Iterators.Combinators.Drop",
        "Std.Data.Iterators.Combinators.DropWhile",
        "Std.Data.Iterators.Combinators.StepSize",
        "Std.Data.Iterators.Combinators.Zip"
      ]
    },
    "Std.Data.Iterators.Lemmas.Combinators.Drop": {
      "path": "Std/Data/Iterators/Lemmas/Combinators/Drop.olean",
      "imports": [
        "Std.Data.Iterators.Combinators.Drop",
        "Std.Data.Iterators.Lemmas.Combinators.Monadic.Drop",
        "Init.Data.Iterators.Lemmas.Combinators.Take"
      ]
    },
    "Std.Data.Iterators.Lemmas.Combinators.DropWhile": {
      "path": "Std/Data/Iterators/Lemmas/Combinators/DropWhile.olean",
      "imports": [
        "Std.Data.Iterators.Combinators.DropWhile",
        "Std.Data.Iterators.Lemmas.Combinators.Monadic.DropWhile",
        "Init.Data.Iterators.Lemmas.Consumers"
      ]
    },
    "Std.Data.Iterators.Lemmas.Combinators.Monadic.Drop": {
      "path": "Std/Data/Iterators/Lemmas/Combinators/Monadic/Drop.olean",
      "imports": [
        "Std.Data.Iterators.Combinators.Monadic.Drop",
        "Init.Data.Iterators.Lemmas.Consumers.Monadic"
      ]
    },
    "Std.Data.Iterators.Lemmas.Combinators.Monadic.DropWhile": {
      "path": "Std/Data/Iterators/Lemmas/Combinators/Monadic/DropWhile.olean",
      "imports": [
        "Std.Data.Iterators.Combinators.Monadic.DropWhile",
        "Init.Data.Iterators.Lemmas.Consumers.Monadic"
      ]
    },
    "Std.Data.Iterators.Lemmas.Combinators.Monadic.FilterMap": {
      "path": "Std/Data/Iterators/Lemmas/Combinators/Monadic/FilterMap.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Combinators.Monadic.FilterMap",
        "Std.Data.Iterators.Lemmas.Equivalence.StepCongr"
      ]
    },
    "Std.Data.Iterators.Lemmas.Combinators.Monadic.TakeWhile": {
      "path": "Std/Data/Iterators/Lemmas/Combinators/Monadic/TakeWhile.olean",
      "imports": [
        "Std.Data.Iterators.Combinators.Monadic.TakeWhile",
        "Std.Data.Iterators.Lemmas.Consumers.Monadic"
      ]
    },
    "Std.Data.Iterators.Lemmas.Combinators.Monadic.Zip": {
      "path": "Std/Data/Iterators/Lemmas/Combinators/Monadic/Zip.olean",
      "imports": [
        "Std.Data.Iterators.Combinators.Monadic.Zip",
        "Init.Data.Iterators.Lemmas.Consumers.Monadic"
      ]
    },
    "Std.Data.Iterators.Lemmas.Combinators.Monadic": {
      "path": "Std/Data/Iterators/Lemmas/Combinators/Monadic.olean",
      "imports": [
        "Std.Data.Iterators.Lemmas.Combinators.Monadic.TakeWhile",
        "Std.Data.Iterators.Lemmas.Combinators.Monadic.Drop",
        "Std.Data.Iterators.Lemmas.Combinators.Monadic.DropWhile",
        "Std.Data.Iterators.Lemmas.Combinators.Monadic.FilterMap",
        "Std.Data.Iterators.Lemmas.Combinators.Monadic.Zip"
      ]
    },
    "Std.Data.Iterators.Lemmas.Combinators.TakeWhile": {
      "path": "Std/Data/Iterators/Lemmas/Combinators/TakeWhile.olean",
      "imports": [
        "Std.Data.Iterators.Combinators.TakeWhile",
        "Std.Data.Iterators.Lemmas.Combinators.Monadic.TakeWhile",
        "Std.Data.Iterators.Lemmas.Consumers"
      ]
    },
    "Std.Data.Iterators.Lemmas.Combinators.Zip": {
      "path": "Std/Data/Iterators/Lemmas/Combinators/Zip.olean",
      "imports": [
        "Std.Data.Iterators.Combinators.Zip",
        "Std.Data.Iterators.Lemmas.Combinators.Monadic.Zip",
        "Init.Data.Iterators.Lemmas.Combinators.Take"
      ]
    },
    "Std.Data.Iterators.Lemmas.Combinators": {
      "path": "Std/Data/Iterators/Lemmas/Combinators.olean",
      "imports": [
        "Std.Data.Iterators.Lemmas.Combinators.Monadic",
        "Std.Data.Iterators.Lemmas.Combinators.TakeWhile",
        "Std.Data.Iterators.Lemmas.Combinators.Drop",
        "Std.Data.Iterators.Lemmas.Combinators.DropWhile",
        "Std.Data.Iterators.Lemmas.Combinators.Zip"
      ]
    },
    "Std.Data.Iterators.Lemmas.Consumers.Collect": {
      "path": "Std/Data/Iterators/Lemmas/Consumers/Collect.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Consumers.Collect",
        "Std.Data.Iterators.Lemmas.Consumers.Monadic.Collect"
      ]
    },
    "Std.Data.Iterators.Lemmas.Consumers.Loop": {
      "path": "Std/Data/Iterators/Lemmas/Consumers/Loop.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Consumers.Loop",
        "Std.Data.Iterators.Lemmas.Consumers.Collect",
        "Std.Data.Iterators.Lemmas.Consumers.Monadic.Loop"
      ]
    },
    "Std.Data.Iterators.Lemmas.Consumers.Monadic.Collect": {
      "path": "Std/Data/Iterators/Lemmas/Consumers/Monadic/Collect.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Consumers.Monadic.Collect",
        "Std.Data.Iterators.Lemmas.Equivalence.StepCongr"
      ]
    },
    "Std.Data.Iterators.Lemmas.Consumers.Monadic.Loop": {
      "path": "Std/Data/Iterators/Lemmas/Consumers/Monadic/Loop.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Consumers.Monadic.Loop",
        "Std.Data.Iterators.Lemmas.Consumers.Monadic.Collect"
      ]
    },
    "Std.Data.Iterators.Lemmas.Consumers.Monadic": {
      "path": "Std/Data/Iterators/Lemmas/Consumers/Monadic.olean",
      "imports": [
        "Std.Data.Iterators.Lemmas.Consumers.Monadic.Collect",
        "Std.Data.Iterators.Lemmas.Consumers.Monadic.Loop"
      ]
    },
    "Std.Data.Iterators.Lemmas.Consumers": {
      "path": "Std/Data/Iterators/Lemmas/Consumers.olean",
      "imports": [
        "Std.Data.Iterators.Lemmas.Consumers.Monadic",
        "Std.Data.Iterators.Lemmas.Consumers.Collect",
        "Std.Data.Iterators.Lemmas.Consumers.Loop"
      ]
    },
    "Std.Data.Iterators.Lemmas.Equivalence.Basic": {
      "path": "Std/Data/Iterators/Lemmas/Equivalence/Basic.olean",
      "imports": [
        "Init.Internal.Order",
        "Init.Data.Iterators.Basic",
        "Std.Data.Iterators.Lemmas.Equivalence.HetT"
      ]
    },
    "Std.Data.Iterators.Lemmas.Equivalence.HetT": {
      "path": "Std/Data/Iterators/Lemmas/Equivalence/HetT.olean",
      "imports": [
        "Init.Data.Iterators.Internal.LawfulMonadLiftFunction",
        "Init.Data.Iterators.PostconditionMonad"
      ]
    },
    "Std.Data.Iterators.Lemmas.Equivalence.StepCongr": {
      "path": "Std/Data/Iterators/Lemmas/Equivalence/StepCongr.olean",
      "imports": [
        "Std.Data.Iterators.Lemmas.Equivalence.Basic"
      ]
    },
    "Std.Data.Iterators.Lemmas.Equivalence": {
      "path": "Std/Data/Iterators/Lemmas/Equivalence.olean",
      "imports": [
        "Std.Data.Iterators.Lemmas.Equivalence.HetT",
        "Std.Data.Iterators.Lemmas.Equivalence.Basic",
        "Std.Data.Iterators.Lemmas.Equivalence.StepCongr"
      ]
    },
    "Std.Data.Iterators.Lemmas.Monadic": {
      "path": "Std/Data/Iterators/Lemmas/Monadic.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Monadic.Basic"
      ]
    },
    "Std.Data.Iterators.Lemmas.Producers.Array": {
      "path": "Std/Data/Iterators/Lemmas/Producers/Array.olean",
      "imports": [
        "Std.Data.Iterators.Lemmas.Consumers.Collect",
        "Std.Data.Iterators.Producers.Array",
        "Init.Data.Iterators.Producers.List",
        "Std.Data.Iterators.Lemmas.Producers.Monadic.Array"
      ]
    },
    "Std.Data.Iterators.Lemmas.Producers.Empty": {
      "path": "Std/Data/Iterators/Lemmas/Producers/Empty.olean",
      "imports": [
        "Std.Data.Iterators.Lemmas.Producers.Monadic.Empty",
        "Init.Data.Iterators.Lemmas.Consumers",
        "Std.Data.Iterators.Producers.Empty"
      ]
    },
    "Std.Data.Iterators.Lemmas.Producers.Monadic.Array": {
      "path": "Std/Data/Iterators/Lemmas/Producers/Monadic/Array.olean",
      "imports": [
        "Std.Data.Iterators.Producers.Monadic.Array",
        "Std.Data.Iterators.Lemmas.Consumers.Monadic",
        "Std.Data.Iterators.Lemmas.Producers.Monadic.List"
      ]
    },
    "Std.Data.Iterators.Lemmas.Producers.Monadic.Empty": {
      "path": "Std/Data/Iterators/Lemmas/Producers/Monadic/Empty.olean",
      "imports": [
        "Std.Data.Iterators.Producers.Monadic.Empty",
        "Init.Data.Iterators.Lemmas.Consumers.Monadic"
      ]
    },
    "Std.Data.Iterators.Lemmas.Producers.Monadic.List": {
      "path": "Std/Data/Iterators/Lemmas/Producers/Monadic/List.olean",
      "imports": [
        "Init.Data.Iterators.Lemmas.Producers.Monadic.List",
        "Std.Data.Iterators.Lemmas.Equivalence.Basic"
      ]
    },
    "Std.Data.Iterators.Lemmas.Producers.Monadic": {
      "path": "Std/Data/Iterators/Lemmas/Producers/Monadic.olean",
      "imports": [
        "Std.Data.Iterators.Lemmas.Producers.Monadic.Array",
        "Std.Data.Iterators.Lemmas.Producers.Monadic.Empty",
        "Std.Data.Iterators.Lemmas.Producers.Monadic.List"
      ]
    },
    "Std.Data.Iterators.Lemmas.Producers.Range": {
      "path": "Std/Data/Iterators/Lemmas/Producers/Range.olean",
      "imports": [
        "Std.Data.Iterators.Producers.Range",
        "Init.Data.Range.Polymorphic.Lemmas"
      ]
    },
    "Std.Data.Iterators.Lemmas.Producers.Repeat": {
      "path": "Std/Data/Iterators/Lemmas/Producers/Repeat.olean",
      "imports": [
        "Std.Data.Iterators.Producers.Repeat",
        "Init.Data.Iterators.Lemmas.Combinators.Take"
      ]
    },
    "Std.Data.Iterators.Lemmas.Producers.Slice": {
      "path": "Std/Data/Iterators/Lemmas/Producers/Slice.olean",
      "imports": [
        "Std.Data.Iterators.Producers.Slice",
        "all",
        "Init.Data.Slice.Lemmas"
      ]
    },
    "Std.Data.Iterators.Lemmas.Producers": {
      "path": "Std/Data/Iterators/Lemmas/Producers.olean",
      "imports": [
        "Std.Data.Iterators.Lemmas.Producers.Monadic",
        "Std.Data.Iterators.Lemmas.Producers.Array",
        "Std.Data.Iterators.Lemmas.Producers.Empty",
        "Std.Data.Iterators.Lemmas.Producers.Repeat",
        "Std.Data.Iterators.Lemmas.Producers.Range",
        "Std.Data.Iterators.Lemmas.Producers.Slice"
      ]
    },
    "Std.Data.Iterators.Lemmas": {
      "path": "Std/Data/Iterators/Lemmas.olean",
      "imports": [
        "Std.Data.Iterators.Lemmas.Monadic",
        "Std.Data.Iterators.Lemmas.Combinators",
        "Std.Data.Iterators.Lemmas.Producers",
        "Std.Data.Iterators.Lemmas.Equivalence"
      ]
    },
    "Std.Data.Iterators.Producers.Array": {
      "path": "Std/Data/Iterators/Producers/Array.olean",
      "imports": [
        "Std.Data.Iterators.Producers.Monadic.Array"
      ]
    },
    "Std.Data.Iterators.Producers.Empty": {
      "path": "Std/Data/Iterators/Producers/Empty.olean",
      "imports": [
        "Std.Data.Iterators.Producers.Monadic.Empty"
      ]
    },
    "Std.Data.Iterators.Producers.Monadic.Array": {
      "path": "Std/Data/Iterators/Producers/Monadic/Array.olean",
      "imports": [
        "Init.Data.Iterators.Consumers",
        "Init.Data.Iterators.Internal.Termination"
      ]
    },
    "Std.Data.Iterators.Producers.Monadic.Empty": {
      "path": "Std/Data/Iterators/Producers/Monadic/Empty.olean",
      "imports": [
        "Init.Data.Iterators.Consumers.Loop",
        "Init.Data.Iterators.Internal.Termination"
      ]
    },
    "Std.Data.Iterators.Producers.Monadic": {
      "path": "Std/Data/Iterators/Producers/Monadic.olean",
      "imports": [
        "Std.Data.Iterators.Producers.Monadic.Array",
        "Std.Data.Iterators.Producers.Monadic.Empty"
      ]
    },
    "Std.Data.Iterators.Producers.Range": {
      "path": "Std/Data/Iterators/Producers/Range.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.Iterators"
      ]
    },
    "Std.Data.Iterators.Producers.Repeat": {
      "path": "Std/Data/Iterators/Producers/Repeat.olean",
      "imports": [
        "Init.Data.Iterators.Consumers.Monadic",
        "Init.Data.Iterators.Internal.Termination"
      ]
    },
    "Std.Data.Iterators.Producers.Slice": {
      "path": "Std/Data/Iterators/Producers/Slice.olean",
      "imports": [
        "Init.Data.Slice.Operations"
      ]
    },
    "Std.Data.Iterators.Producers": {
      "path": "Std/Data/Iterators/Producers.olean",
      "imports": [
        "Std.Data.Iterators.Producers.Monadic",
        "Std.Data.Iterators.Producers.Array",
        "Std.Data.Iterators.Producers.Empty",
        "Std.Data.Iterators.Producers.Range",
        "Std.Data.Iterators.Producers.Repeat",
        "Std.Data.Iterators.Producers.Slice"
      ]
    },
    "Std.Data.Iterators": {
      "path": "Std/Data/Iterators.olean",
      "imports": [
        "Init.Data.Iterators.Internal",
        "Std.Data.Iterators.Producers",
        "Std.Data.Iterators.Combinators",
        "Std.Data.Iterators.Lemmas"
      ]
    },
    "Std.Data.TreeMap.AdditionalOperations": {
      "path": "Std/Data/TreeMap/AdditionalOperations.olean",
      "imports": [
        "Std.Data.TreeMap.Basic",
        "Std.Data.TreeMap.Raw.Basic",
        "Std.Data.DTreeMap.AdditionalOperations"
      ]
    },
    "Std.Data.TreeMap.Basic": {
      "path": "Std/Data/TreeMap/Basic.olean",
      "imports": [
        "Std.Data.DTreeMap.Basic"
      ]
    },
    "Std.Data.TreeMap.DecidableEquiv": {
      "path": "Std/Data/TreeMap/DecidableEquiv.olean",
      "imports": [
        "Std.Data.DTreeMap.DecidableEquiv",
        "Std.Data.TreeMap.Basic"
      ]
    },
    "Std.Data.TreeMap.Iterator": {
      "path": "Std/Data/TreeMap/Iterator.olean",
      "imports": [
        "Std.Data.TreeMap.Basic",
        "Std.Data.DTreeMap.Iterator"
      ]
    },
    "Std.Data.TreeMap.Lemmas": {
      "path": "Std/Data/TreeMap/Lemmas.olean",
      "imports": [
        "Std.Data.DTreeMap.Lemmas",
        "Std.Data.TreeMap.AdditionalOperations"
      ]
    },
    "Std.Data.TreeMap.Raw.AdditionalOperations": {
      "path": "Std/Data/TreeMap/Raw/AdditionalOperations.olean",
      "imports": [
        "Std.Data.TreeMap.Basic",
        "Std.Data.TreeMap.Raw.Basic",
        "Std.Data.DTreeMap.Raw.AdditionalOperations"
      ]
    },
    "Std.Data.TreeMap.Raw.Basic": {
      "path": "Std/Data/TreeMap/Raw/Basic.olean",
      "imports": [
        "Std.Data.DTreeMap.Raw.Basic"
      ]
    },
    "Std.Data.TreeMap.Raw.DecidableEquiv": {
      "path": "Std/Data/TreeMap/Raw/DecidableEquiv.olean",
      "imports": [
        "Std.Data.DTreeMap.DecidableEquiv",
        "Std.Data.TreeMap.Raw.Basic"
      ]
    },
    "Std.Data.TreeMap.Raw.Iterator": {
      "path": "Std/Data/TreeMap/Raw/Iterator.olean",
      "imports": [
        "Std.Data.DTreeMap.Raw.Iterator",
        "Std.Data.TreeMap.Raw.Basic"
      ]
    },
    "Std.Data.TreeMap.Raw.Lemmas": {
      "path": "Std/Data/TreeMap/Raw/Lemmas.olean",
      "imports": [
        "Std.Data.DTreeMap.Raw.Lemmas",
        "Std.Data.TreeMap.Raw.AdditionalOperations"
      ]
    },
    "Std.Data.TreeMap.Raw.Slice": {
      "path": "Std/Data/TreeMap/Raw/Slice.olean",
      "imports": [
        "Std.Data.DTreeMap.Raw.Slice",
        "Std.Data.TreeMap.Raw.Basic"
      ]
    },
    "Std.Data.TreeMap.Raw.WF": {
      "path": "Std/Data/TreeMap/Raw/WF.olean",
      "imports": [
        "Std.Data.DTreeMap.Raw.WF",
        "Std.Data.TreeMap.Raw.AdditionalOperations"
      ]
    },
    "Std.Data.TreeMap.Raw": {
      "path": "Std/Data/TreeMap/Raw.olean",
      "imports": [
        "Std.Data.TreeMap.Raw.Basic",
        "Std.Data.TreeMap.Raw.AdditionalOperations",
        "Std.Data.TreeMap.Raw.Lemmas",
        "Std.Data.TreeMap.Raw.WF",
        "Std.Data.TreeMap.Raw.Iterator",
        "Std.Data.TreeMap.Raw.Slice",
        "Std.Data.TreeMap.Raw.DecidableEquiv"
      ]
    },
    "Std.Data.TreeMap.Slice": {
      "path": "Std/Data/TreeMap/Slice.olean",
      "imports": [
        "Std.Data.TreeMap.Raw.Slice",
        "Std.Data.TreeMap.Basic"
      ]
    },
    "Std.Data.TreeMap": {
      "path": "Std/Data/TreeMap.olean",
      "imports": [
        "Std.Data.TreeMap.Basic",
        "Std.Data.TreeMap.AdditionalOperations",
        "Std.Data.TreeMap.Lemmas",
        "Std.Data.TreeMap.Iterator",
        "Std.Data.TreeMap.Slice",
        "Std.Data.TreeMap.DecidableEquiv"
      ]
    },
    "Std.Data.TreeSet.AdditionalOperations": {
      "path": "Std/Data/TreeSet/AdditionalOperations.olean",
      "imports": [
        "Std.Data.TreeSet.Raw.Basic",
        "Std.Data.TreeMap.AdditionalOperations"
      ]
    },
    "Std.Data.TreeSet.Basic": {
      "path": "Std/Data/TreeSet/Basic.olean",
      "imports": [
        "Std.Data.TreeMap.Basic"
      ]
    },
    "Std.Data.TreeSet.DecidableEquiv": {
      "path": "Std/Data/TreeSet/DecidableEquiv.olean",
      "imports": [
        "Std.Data.TreeMap.DecidableEquiv",
        "Std.Data.TreeSet.Basic"
      ]
    },
    "Std.Data.TreeSet.Iterator": {
      "path": "Std/Data/TreeSet/Iterator.olean",
      "imports": [
        "Std.Data.TreeSet.Basic",
        "Std.Data.TreeMap.Iterator",
        "Std.Data.DTreeMap.Lemmas"
      ]
    },
    "Std.Data.TreeSet.Lemmas": {
      "path": "Std/Data/TreeSet/Lemmas.olean",
      "imports": [
        "Std.Data.TreeMap.Lemmas",
        "Std.Data.DTreeMap.Lemmas",
        "Std.Data.TreeSet.AdditionalOperations"
      ]
    },
    "Std.Data.TreeSet.Raw.Basic": {
      "path": "Std/Data/TreeSet/Raw/Basic.olean",
      "imports": [
        "Std.Data.TreeMap.Raw.Basic",
        "Std.Data.TreeSet.Basic"
      ]
    },
    "Std.Data.TreeSet.Raw.DecidableEquiv": {
      "path": "Std/Data/TreeSet/Raw/DecidableEquiv.olean",
      "imports": [
        "Std.Data.TreeMap.Raw.DecidableEquiv",
        "Std.Data.TreeSet.Raw.Basic"
      ]
    },
    "Std.Data.TreeSet.Raw.Iterator": {
      "path": "Std/Data/TreeSet/Raw/Iterator.olean",
      "imports": [
        "Std.Data.TreeSet.Raw.Basic",
        "Std.Data.TreeMap.Raw.Iterator",
        "Std.Data.DTreeMap.Raw.Lemmas"
      ]
    },
    "Std.Data.TreeSet.Raw.Lemmas": {
      "path": "Std/Data/TreeSet/Raw/Lemmas.olean",
      "imports": [
        "Std.Data.TreeMap.Raw.Lemmas",
        "Std.Data.DTreeMap.Raw.Lemmas",
        "Std.Data.TreeSet.Raw.Basic",
        "Init.Data.List.BasicAux",
        "Init.Data.Order.ClassesExtra"
      ]
    },
    "Std.Data.TreeSet.Raw.Slice": {
      "path": "Std/Data/TreeSet/Raw/Slice.olean",
      "imports": [
        "Std.Data.TreeMap.Raw.Slice",
        "Std.Data.TreeSet.Raw.Basic"
      ]
    },
    "Std.Data.TreeSet.Raw.WF": {
      "path": "Std/Data/TreeSet/Raw/WF.olean",
      "imports": [
        "Std.Data.TreeMap.Raw.WF",
        "Std.Data.TreeSet.AdditionalOperations"
      ]
    },
    "Std.Data.TreeSet.Raw": {
      "path": "Std/Data/TreeSet/Raw.olean",
      "imports": [
        "Std.Data.TreeSet.Raw.Basic",
        "Std.Data.TreeSet.Raw.Lemmas",
        "Std.Data.TreeSet.Raw.WF",
        "Std.Data.TreeSet.Raw.Iterator",
        "Std.Data.TreeSet.Raw.Slice",
        "Std.Data.TreeSet.Raw.DecidableEquiv"
      ]
    },
    "Std.Data.TreeSet.Slice": {
      "path": "Std/Data/TreeSet/Slice.olean",
      "imports": [
        "Std.Data.TreeSet.Raw.Slice",
        "Std.Data.TreeSet.Basic"
      ]
    },
    "Std.Data.TreeSet": {
      "path": "Std/Data/TreeSet.olean",
      "imports": [
        "Std.Data.TreeSet.Basic",
        "Std.Data.TreeSet.AdditionalOperations",
        "Std.Data.TreeSet.Lemmas",
        "Std.Data.TreeSet.Iterator",
        "Std.Data.TreeSet.Slice",
        "Std.Data.TreeSet.DecidableEquiv"
      ]
    },
    "Std.Data": {
      "path": "Std/Data.olean",
      "imports": [
        "Std.Data.DHashMap",
        "Std.Data.HashMap",
        "Std.Data.HashSet",
        "Std.Data.DTreeMap",
        "Std.Data.TreeMap",
        "Std.Data.TreeSet",
        "Std.Data.ExtDHashMap",
        "Std.Data.ExtHashMap",
        "Std.Data.ExtHashSet",
        "Std.Data.ExtDTreeMap",
        "Std.Data.ExtTreeMap",
        "Std.Data.ExtTreeSet",
        "Std.Data.DHashMap.RawLemmas",
        "Std.Data.DHashMap.RawDecidableEquiv",
        "Std.Data.HashMap.RawLemmas",
        "Std.Data.HashMap.RawDecidableEquiv",
        "Std.Data.HashSet.RawLemmas",
        "Std.Data.HashSet.RawDecidableEquiv",
        "Std.Data.DTreeMap.Raw",
        "Std.Data.TreeMap.Raw",
        "Std.Data.TreeSet.Raw",
        "Std.Data.Iterators",
        "Std.Data.ByteSlice"
      ]
    },
    "Std.Do.PostCond": {
      "path": "Std/Do/PostCond.olean",
      "imports": [
        "Std.Do.SPred"
      ]
    },
    "Std.Do.PredTrans": {
      "path": "Std/Do/PredTrans.olean",
      "imports": [
        "Init.Control.Lawful",
        "Std.Do.PostCond"
      ]
    },
    "Std.Do.SPred.DerivedLaws": {
      "path": "Std/Do/SPred/DerivedLaws.olean",
      "imports": [
        "Init.ByCases",
        "Std.Do.SPred.Laws"
      ]
    },
    "Std.Do.SPred.Laws": {
      "path": "Std/Do/SPred/Laws.olean",
      "imports": [
        "Std.Do.SPred.Notation"
      ]
    },
    "Std.Do.SPred.Notation.Basic": {
      "path": "Std/Do/SPred/Notation/Basic.olean",
      "imports": [
        "Std.Do.SPred.SPred",
        "Init.NotationExtra"
      ]
    },
    "Std.Do.SPred.Notation": {
      "path": "Std/Do/SPred/Notation.olean",
      "imports": [
        "Std.Do.SPred.SPred",
        "Std.Do.SPred.Notation.Basic"
      ]
    },
    "Std.Do.SPred.SPred": {
      "path": "Std/Do/SPred/SPred.olean",
      "imports": [
        "Init.Ext",
        "Std.Do.SPred.SVal"
      ]
    },
    "Std.Do.SPred.SVal": {
      "path": "Std/Do/SPred/SVal.olean",
      "imports": [
        "Init.Data.List.Notation",
        "Init.SimpLemmas"
      ]
    },
    "Std.Do.SPred": {
      "path": "Std/Do/SPred.olean",
      "imports": [
        "Std.Do.SPred.SVal",
        "Std.Do.SPred.SPred",
        "Std.Do.SPred.Notation",
        "Std.Do.SPred.Laws",
        "Std.Do.SPred.DerivedLaws"
      ]
    },
    "Std.Do.Triple.Basic": {
      "path": "Std/Do/Triple/Basic.olean",
      "imports": [
        "Std.Do.WP",
        "Std.Do.SPred.Notation"
      ]
    },
    "Std.Do.Triple.SpecLemmas": {
      "path": "Std/Do/Triple/SpecLemmas.olean",
      "imports": [
        "Std.Do.Triple.Basic",
        "Init.Data.Range.Polymorphic.Iterators",
        "Init.Data.Range.Polymorphic",
        "Init.Data.Slice.Array",
        "Init.Data.Iterators.ToIterator",
        "Init.Data.Iterators.Lemmas.Combinators.FilterMap"
      ]
    },
    "Std.Do.Triple": {
      "path": "Std/Do/Triple.olean",
      "imports": [
        "Std.Do.Triple.Basic",
        "Std.Do.Triple.SpecLemmas"
      ]
    },
    "Std.Do.WP.Basic": {
      "path": "Std/Do/WP/Basic.olean",
      "imports": [
        "Std.Do.PredTrans"
      ]
    },
    "Std.Do.WP.Monad": {
      "path": "Std/Do/WP/Monad.olean",
      "imports": [
        "Std.Do.WP.Basic",
        "all"
      ]
    },
    "Std.Do.WP.SimpLemmas": {
      "path": "Std/Do/WP/SimpLemmas.olean",
      "imports": [
        "Std.Do.WP.Monad"
      ]
    },
    "Std.Do.WP": {
      "path": "Std/Do/WP.olean",
      "imports": [
        "Std.Do.WP.Basic",
        "Std.Do.WP.Monad",
        "Std.Do.WP.SimpLemmas"
      ]
    },
    "Std.Do": {
      "path": "Std/Do.olean",
      "imports": [
        "Std.Do.SPred",
        "Std.Do.WP",
        "Std.Do.Triple",
        "Std.Do.PredTrans",
        "Std.Do.PostCond"
      ]
    },
    "Std.Internal.Async.Basic": {
      "path": "Std/Internal/Async/Basic.olean",
      "imports": [
        "Init.System.Promise"
      ]
    },
    "Std.Internal.Async.ContextAsync": {
      "path": "Std/Internal/Async/ContextAsync.olean",
      "imports": [
        "Std.Time",
        "Std.Internal.UV",
        "Std.Internal.Async.Basic",
        "Std.Internal.Async.Timer",
        "Std.Sync.CancellationContext"
      ]
    },
    "Std.Internal.Async.DNS": {
      "path": "Std/Internal/Async/DNS.olean",
      "imports": [
        "Std.Time",
        "Std.Internal.UV",
        "Std.Internal.Async.Basic"
      ]
    },
    "Std.Internal.Async.IO": {
      "path": "Std/Internal/Async/IO.olean",
      "imports": [
        "Std.Internal.Async.Select"
      ]
    },
    "Std.Internal.Async.Process": {
      "path": "Std/Internal/Async/Process.olean",
      "imports": [
        "Std.Time",
        "Std.Internal.UV.System",
        "Std.Data.HashMap"
      ]
    },
    "Std.Internal.Async.Select": {
      "path": "Std/Internal/Async/Select.olean",
      "imports": [
        "Init.Data.Random",
        "Std.Internal.Async.Basic",
        "Init.Data.ByteArray.Extra"
      ]
    },
    "Std.Internal.Async.Signal": {
      "path": "Std/Internal/Async/Signal.olean",
      "imports": [
        "Std.Time",
        "Std.Internal.UV.Signal",
        "Std.Internal.Async.Select"
      ]
    },
    "Std.Internal.Async.System": {
      "path": "Std/Internal/Async/System.olean",
      "imports": [
        "Std.Time",
        "Std.Internal.UV.System",
        "Std.Data.HashMap"
      ]
    },
    "Std.Internal.Async.TCP": {
      "path": "Std/Internal/Async/TCP.olean",
      "imports": [
        "Std.Time",
        "Std.Internal.UV.TCP",
        "Std.Internal.Async.Select"
      ]
    },
    "Std.Internal.Async.Timer": {
      "path": "Std/Internal/Async/Timer.olean",
      "imports": [
        "Std.Time",
        "Std.Internal.UV.Timer",
        "Std.Internal.Async.Select"
      ]
    },
    "Std.Internal.Async.UDP": {
      "path": "Std/Internal/Async/UDP.olean",
      "imports": [
        "Std.Time",
        "Std.Internal.UV.UDP",
        "Std.Internal.Async.Select"
      ]
    },
    "Std.Internal.Async": {
      "path": "Std/Internal/Async.olean",
      "imports": [
        "Std.Internal.Async.Basic",
        "Std.Internal.Async.ContextAsync",
        "Std.Internal.Async.Timer",
        "Std.Internal.Async.TCP",
        "Std.Internal.Async.UDP",
        "Std.Internal.Async.DNS",
        "Std.Internal.Async.Select",
        "Std.Internal.Async.Process",
        "Std.Internal.Async.System",
        "Std.Internal.Async.Signal",
        "Std.Internal.Async.IO"
      ]
    },
    "Std.Internal.Parsec.Basic": {
      "path": "Std/Internal/Parsec/Basic.olean",
      "imports": [
        "Init.NotationExtra",
        "Init.Data.ToString.Macro",
        "Init.Data.String.Basic"
      ]
    },
    "Std.Internal.Parsec.ByteArray": {
      "path": "Std/Internal/Parsec/ByteArray.olean",
      "imports": [
        "Std.Internal.Parsec.Basic",
        "Init.Data.String.Basic",
        "Std.Data.ByteSlice"
      ]
    },
    "Std.Internal.Parsec.String": {
      "path": "Std/Internal/Parsec/String.olean",
      "imports": [
        "Std.Internal.Parsec.Basic",
        "Init.Data.String.Slice",
        "Init.Data.String.Termination"
      ]
    },
    "Std.Internal.Parsec": {
      "path": "Std/Internal/Parsec.olean",
      "imports": [
        "Std.Internal.Parsec.Basic",
        "Std.Internal.Parsec.String",
        "Std.Internal.Parsec.ByteArray"
      ]
    },
    "Std.Internal.UV.DNS": {
      "path": "Std/Internal/UV/DNS.olean",
      "imports": [
        "Init.System.Promise",
        "Init.Data.SInt",
        "Std.Net"
      ]
    },
    "Std.Internal.UV.Loop": {
      "path": "Std/Internal/UV/Loop.olean",
      "imports": [
        "Init.System.Promise"
      ]
    },
    "Std.Internal.UV.Signal": {
      "path": "Std/Internal/UV/Signal.olean",
      "imports": [
        "Init.System.Promise",
        "Init.Data.SInt",
        "Std.Net"
      ]
    },
    "Std.Internal.UV.System": {
      "path": "Std/Internal/UV/System.olean",
      "imports": [
        "Init.System.Promise",
        "Init.Data.SInt",
        "Std.Net"
      ]
    },
    "Std.Internal.UV.TCP": {
      "path": "Std/Internal/UV/TCP.olean",
      "imports": [
        "Init.System.Promise",
        "Init.Data.SInt",
        "Std.Net"
      ]
    },
    "Std.Internal.UV.Timer": {
      "path": "Std/Internal/UV/Timer.olean",
      "imports": [
        "Init.System.Promise"
      ]
    },
    "Std.Internal.UV.UDP": {
      "path": "Std/Internal/UV/UDP.olean",
      "imports": [
        "Init.System.Promise",
        "Std.Net"
      ]
    },
    "Std.Internal.UV": {
      "path": "Std/Internal/UV.olean",
      "imports": [
        "Std.Internal.UV.Loop",
        "Std.Internal.UV.Timer",
        "Std.Internal.UV.TCP",
        "Std.Internal.UV.UDP",
        "Std.Internal.UV.System",
        "Std.Internal.UV.DNS",
        "Std.Internal.UV.Signal"
      ]
    },
    "Std.Internal": {
      "path": "Std/Internal.olean",
      "imports": [
        "Std.Internal.Async",
        "Std.Internal.Parsec",
        "Std.Internal.UV"
      ]
    },
    "Std.Net.Addr": {
      "path": "Std/Net/Addr.olean",
      "imports": [
        "Init.System.IO",
        "Init.Data.Vector.Basic"
      ]
    },
    "Std.Net": {
      "path": "Std/Net.olean",
      "imports": [
        "Std.Net.Addr"
      ]
    },
    "Std.Sat.AIG.Basic": {
      "path": "Std/Sat/AIG/Basic.olean",
      "imports": [
        "Std.Data.HashSet",
        "Init.Data.Vector.Basic",
        "Init.Data.Hashable"
      ]
    },
    "Std.Sat.AIG.CNF": {
      "path": "Std/Sat/AIG/CNF.olean",
      "imports": [
        "Std.Sat.CNF",
        "Std.Sat.AIG.Lemmas"
      ]
    },
    "Std.Sat.AIG.Cached": {
      "path": "Std/Sat/AIG/Cached.olean",
      "imports": [
        "Std.Sat.AIG.Lemmas"
      ]
    },
    "Std.Sat.AIG.CachedGates": {
      "path": "Std/Sat/AIG/CachedGates.olean",
      "imports": [
        "Std.Sat.AIG.CachedLemmas"
      ]
    },
    "Std.Sat.AIG.CachedGatesLemmas": {
      "path": "Std/Sat/AIG/CachedGatesLemmas.olean",
      "imports": [
        "Std.Sat.AIG.CachedGates"
      ]
    },
    "Std.Sat.AIG.CachedLemmas": {
      "path": "Std/Sat/AIG/CachedLemmas.olean",
      "imports": [
        "Std.Sat.AIG.Cached"
      ]
    },
    "Std.Sat.AIG.If": {
      "path": "Std/Sat/AIG/If.olean",
      "imports": [
        "Std.Sat.AIG.LawfulVecOperator"
      ]
    },
    "Std.Sat.AIG.LawfulOperator": {
      "path": "Std/Sat/AIG/LawfulOperator.olean",
      "imports": [
        "Std.Sat.AIG.Basic"
      ]
    },
    "Std.Sat.AIG.LawfulVecOperator": {
      "path": "Std/Sat/AIG/LawfulVecOperator.olean",
      "imports": [
        "Std.Sat.AIG.RefVec"
      ]
    },
    "Std.Sat.AIG.Lemmas": {
      "path": "Std/Sat/AIG/Lemmas.olean",
      "imports": [
        "Std.Sat.AIG.LawfulOperator"
      ]
    },
    "Std.Sat.AIG.RefVec": {
      "path": "Std/Sat/AIG/RefVec.olean",
      "imports": [
        "Std.Sat.AIG.CachedGatesLemmas",
        "Init.Data.Vector.Lemmas"
      ]
    },
    "Std.Sat.AIG.RefVecOperator.Fold": {
      "path": "Std/Sat/AIG/RefVecOperator/Fold.olean",
      "imports": [
        "Std.Sat.AIG.LawfulVecOperator"
      ]
    },
    "Std.Sat.AIG.RefVecOperator.Map": {
      "path": "Std/Sat/AIG/RefVecOperator/Map.olean",
      "imports": [
        "Std.Sat.AIG.LawfulVecOperator"
      ]
    },
    "Std.Sat.AIG.RefVecOperator.Zip": {
      "path": "Std/Sat/AIG/RefVecOperator/Zip.olean",
      "imports": [
        "Std.Sat.AIG.LawfulVecOperator"
      ]
    },
    "Std.Sat.AIG.RefVecOperator": {
      "path": "Std/Sat/AIG/RefVecOperator.olean",
      "imports": [
        "Std.Sat.AIG.RefVecOperator.Map",
        "Std.Sat.AIG.RefVecOperator.Zip",
        "Std.Sat.AIG.RefVecOperator.Fold"
      ]
    },
    "Std.Sat.AIG.Relabel": {
      "path": "Std/Sat/AIG/Relabel.olean",
      "imports": [
        "Std.Sat.AIG.Lemmas"
      ]
    },
    "Std.Sat.AIG.RelabelNat": {
      "path": "Std/Sat/AIG/RelabelNat.olean",
      "imports": [
        "Std.Sat.AIG.Relabel"
      ]
    },
    "Std.Sat.AIG": {
      "path": "Std/Sat/AIG.olean",
      "imports": [
        "Std.Sat.AIG.Basic",
        "Std.Sat.AIG.LawfulOperator",
        "Std.Sat.AIG.Lemmas",
        "Std.Sat.AIG.Cached",
        "Std.Sat.AIG.CachedLemmas",
        "Std.Sat.AIG.CachedGates",
        "Std.Sat.AIG.CachedGatesLemmas",
        "Std.Sat.AIG.CNF",
        "Std.Sat.AIG.Relabel",
        "Std.Sat.AIG.RelabelNat",
        "Std.Sat.AIG.RefVec",
        "Std.Sat.AIG.RefVecOperator",
        "Std.Sat.AIG.LawfulVecOperator",
        "Std.Sat.AIG.If"
      ]
    },
    "Std.Sat.CNF.Basic": {
      "path": "Std/Sat/CNF/Basic.olean",
      "imports": [
        "Std.Sat.CNF.Literal"
      ]
    },
    "Std.Sat.CNF.Dimacs": {
      "path": "Std/Sat/CNF/Dimacs.olean",
      "imports": [
        "Std.Sat.CNF.RelabelFin"
      ]
    },
    "Std.Sat.CNF.Literal": {
      "path": "Std/Sat/CNF/Literal.olean",
      "imports": [
        "Init.Data.Hashable",
        "Init.Data.ToString"
      ]
    },
    "Std.Sat.CNF.Relabel": {
      "path": "Std/Sat/CNF/Relabel.olean",
      "imports": [
        "Std.Sat.CNF.Basic"
      ]
    },
    "Std.Sat.CNF.RelabelFin": {
      "path": "Std/Sat/CNF/RelabelFin.olean",
      "imports": [
        "Init.Data.Nat.Order",
        "Std.Sat.CNF.Relabel"
      ]
    },
    "Std.Sat.CNF": {
      "path": "Std/Sat/CNF.olean",
      "imports": [
        "Std.Sat.CNF.Basic",
        "Std.Sat.CNF.Literal",
        "Std.Sat.CNF.Relabel",
        "Std.Sat.CNF.RelabelFin",
        "Std.Sat.CNF.Dimacs"
      ]
    },
    "Std.Sat": {
      "path": "Std/Sat.olean",
      "imports": [
        "Std.Sat.AIG",
        "Std.Sat.CNF"
      ]
    },
    "Std.Sync.Barrier": {
      "path": "Std/Sync/Barrier.olean",
      "imports": [
        "Std.Sync.Mutex"
      ]
    },
    "Std.Sync.Basic": {
      "path": "Std/Sync/Basic.olean",
      "imports": [
        "Init.System.IO"
      ]
    },
    "Std.Sync.Broadcast": {
      "path": "Std/Sync/Broadcast.olean",
      "imports": [
        "Std.Data",
        "Init.Data.Queue",
        "Init.Data.Vector",
        "Std.Sync.Mutex",
        "Std.Internal.Async.IO"
      ]
    },
    "Std.Sync.CancellationContext": {
      "path": "Std/Sync/CancellationContext.olean",
      "imports": [
        "Std.Data",
        "Init.System.Promise",
        "Init.Data.Queue",
        "Std.Sync.Mutex",
        "Std.Sync.CancellationToken",
        "Std.Internal.Async.Select"
      ]
    },
    "Std.Sync.CancellationToken": {
      "path": "Std/Sync/CancellationToken.olean",
      "imports": [
        "Std.Data",
        "Init.Data.Queue",
        "Std.Sync.Mutex",
        "Std.Internal.Async.Select"
      ]
    },
    "Std.Sync.Channel": {
      "path": "Std/Sync/Channel.olean",
      "imports": [
        "Init.Data.Queue",
        "Std.Sync.Mutex",
        "Std.Internal.Async.IO",
        "Init.Data.Vector.Basic"
      ]
    },
    "Std.Sync.Mutex": {
      "path": "Std/Sync/Mutex.olean",
      "imports": [
        "Std.Sync.Basic"
      ]
    },
    "Std.Sync.Notify": {
      "path": "Std/Sync/Notify.olean",
      "imports": [
        "Init.Data.Queue",
        "Std.Sync.Mutex",
        "Std.Internal.Async.Select"
      ]
    },
    "Std.Sync.RecursiveMutex": {
      "path": "Std/Sync/RecursiveMutex.olean",
      "imports": [
        "Std.Sync.Basic"
      ]
    },
    "Std.Sync.SharedMutex": {
      "path": "Std/Sync/SharedMutex.olean",
      "imports": [
        "Std.Sync.Basic"
      ]
    },
    "Std.Sync.StreamMap": {
      "path": "Std/Sync/StreamMap.olean",
      "imports": [
        "Std.Data",
        "Init.Data.Queue",
        "Std.Internal.Async.IO"
      ]
    },
    "Std.Sync": {
      "path": "Std/Sync.olean",
      "imports": [
        "Std.Sync.Basic",
        "Std.Sync.Channel",
        "Std.Sync.Mutex",
        "Std.Sync.RecursiveMutex",
        "Std.Sync.Barrier",
        "Std.Sync.SharedMutex",
        "Std.Sync.Notify",
        "Std.Sync.Broadcast",
        "Std.Sync.StreamMap",
        "Std.Sync.CancellationToken",
        "Std.Sync.CancellationContext"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Basic.olean",
      "imports": [
        "Init.Data.Hashable",
        "Std.Tactic.BVDecide.Bitblast.BoolExpr.Basic"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Carry": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Carry.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Add"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Const": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Const.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic",
        "Std.Sat.AIG.LawfulVecOperator"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Expr": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Expr.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Var",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.ShiftRight",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Append",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Replicate",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Extract",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.RotateLeft",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.RotateRight",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Mul",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Umod",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Reverse",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Clz"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Add": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/Add.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic",
        "Std.Sat.AIG.LawfulVecOperator"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Append": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/Append.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic",
        "Std.Sat.AIG.LawfulVecOperator"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Clz": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/Clz.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Const",
        "Std.Sat.AIG.If"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Eq": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/Eq.olean",
      "imports": [
        "Std.Sat.AIG.RefVecOperator"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Extract": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/Extract.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic",
        "Std.Sat.AIG.LawfulVecOperator"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.GetLsbD": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/GetLsbD.olean",
      "imports": [
        "Std.Sat.AIG.RefVec"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Mul": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/Mul.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Add",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.ShiftLeft",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Const"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Neg": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/Neg.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Add",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Not",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Const"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Not": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/Not.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic",
        "Std.Sat.AIG.RefVecOperator"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Replicate": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/Replicate.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic",
        "Std.Sat.AIG.LawfulVecOperator"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Reverse": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/Reverse.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic",
        "Std.Sat.AIG.LawfulVecOperator"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.RotateLeft": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/RotateLeft.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic",
        "Std.Sat.AIG.LawfulVecOperator"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.RotateRight": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/RotateRight.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic",
        "Std.Sat.AIG.LawfulVecOperator"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.ShiftLeft": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/ShiftLeft.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic",
        "Std.Sat.AIG.If"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.ShiftRight": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/ShiftRight.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic",
        "Std.Sat.AIG.If"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Sub": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/Sub.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Neg"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Udiv": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/Udiv.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Sub",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Eq",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Ult",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.ZeroExtend",
        "Std.Sat.AIG.If"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Ult": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/Ult.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Carry",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Not"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Umod": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/Umod.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Udiv"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.ZeroExtend": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Operations/ZeroExtend.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic",
        "Std.Sat.AIG.LawfulVecOperator"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Pred": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Pred.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.GetLsbD",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Expr"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Substructure": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Substructure.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Pred"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Var": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl/Var.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic",
        "Std.Sat.AIG.LawfulVecOperator"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Impl.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Substructure"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Basic": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Basic.olean",
      "imports": [
        "Std.Sat.AIG.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Carry": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Carry.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Add",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Carry"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Const": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Const.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Const"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Expr": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Expr.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Var",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.ShiftRight",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Append",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Replicate",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Extract",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.RotateLeft",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.RotateRight",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Mul",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Umod",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Reverse",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Clz",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Expr"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Add": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Add.olean",
      "imports": [
        "Init.Data.BitVec.Bitblast",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Add"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Append": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Append.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Append"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Clz": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Clz.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Clz",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Const"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Eq": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Eq.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Eq"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Extract": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Extract.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Extract"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.GetLsbD": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/GetLsbD.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.GetLsbD"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Mul": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Mul.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Add",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.ShiftLeft",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Const",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Mul"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Neg": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Neg.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Const",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Neg",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Not",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Add"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Not": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Not.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Not"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Replicate": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Replicate.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Replicate"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Reverse": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Reverse.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Reverse"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.RotateLeft": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/RotateLeft.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.RotateLeft"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.RotateRight": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/RotateRight.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.RotateRight"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.ShiftLeft": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/ShiftLeft.olean",
      "imports": [
        "Init.Data.BitVec.Bitblast",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.ShiftLeft"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.ShiftRight": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/ShiftRight.olean",
      "imports": [
        "Init.Data.BitVec.Bitblast",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.ShiftRight"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Sub": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Sub.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Neg",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Sub"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Udiv": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Udiv.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Sub",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.ZeroExtend",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Eq",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Ult",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.GetLsbD",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Udiv",
        "all",
        "Std.Tactic.BVDecide.Normalize.BitVec"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Ult": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Ult.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Carry",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Not",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Ult"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Umod": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/Umod.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.Udiv",
        "all",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.Umod"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Operations.ZeroExtend": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Operations/ZeroExtend.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Operations.ZeroExtend"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Pred": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Pred.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Expr",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Pred"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Var": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas/Var.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl.Var"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit/Lemmas.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas.Pred"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr/Circuit.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Impl",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit.Lemmas"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BVExpr": {
      "path": "Std/Tactic/BVDecide/Bitblast/BVExpr.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Basic",
        "Std.Tactic.BVDecide.Bitblast.BVExpr.Circuit"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BoolExpr.Basic": {
      "path": "Std/Tactic/BVDecide/Bitblast/BoolExpr/Basic.olean",
      "imports": [
        "Init.Data.String.Basic"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast.BoolExpr": {
      "path": "Std/Tactic/BVDecide/Bitblast/BoolExpr.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BoolExpr.Basic"
      ]
    },
    "Std.Tactic.BVDecide.Bitblast": {
      "path": "Std/Tactic/BVDecide/Bitblast.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast.BoolExpr",
        "Std.Tactic.BVDecide.Bitblast.BVExpr"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Actions": {
      "path": "Std/Tactic/BVDecide/LRAT/Actions.olean",
      "imports": [
        "Std.Sat.CNF"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Checker": {
      "path": "Std/Tactic/BVDecide/LRAT/Checker.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Internal.Convert",
        "Std.Tactic.BVDecide.LRAT.Internal.LRATCheckerSound"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.Actions": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/Actions.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Actions",
        "Std.Tactic.BVDecide.LRAT.Internal.Clause"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.Assignment": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/Assignment.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Internal.Entails",
        "Std.Tactic.BVDecide.LRAT.Internal.PosFin",
        "Init.Grind"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.CNF": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/CNF.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.Class"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.Clause": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/Clause.olean",
      "imports": [
        "Std.Data.HashMap",
        "Std.Sat.CNF.Basic",
        "Std.Tactic.BVDecide.LRAT.Internal.Assignment"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.Convert": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/Convert.olean",
      "imports": [
        "Std.Sat.CNF.RelabelFin",
        "Std.Tactic.BVDecide.LRAT.Internal.Formula"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.Entails": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/Entails.olean",
      "imports": [
        "Init.PropLemmas"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.Formula.Class": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/Formula/Class.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Internal.Clause"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.Formula.Implementation": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/Formula/Implementation.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.Class"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.Formula.Instance": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/Formula/Instance.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.RatAddSound"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.Formula.Lemmas": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/Formula/Lemmas.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.Implementation",
        "Std.Tactic.BVDecide.LRAT.Internal.CNF"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.Formula.RatAddResult": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/Formula/RatAddResult.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.RupAddSound"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.Formula.RatAddSound": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/Formula/RatAddSound.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.RatAddResult"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.Formula.RupAddResult": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/Formula/RupAddResult.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.Lemmas"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.Formula.RupAddSound": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/Formula/RupAddSound.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.RupAddResult"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.Formula": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/Formula.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.Lemmas",
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.Class",
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.Implementation",
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.Instance",
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.RatAddResult",
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.RatAddSound",
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.RupAddResult",
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.RupAddSound"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.LRATChecker": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/LRATChecker.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Actions",
        "Std.Tactic.BVDecide.LRAT.Internal.Formula.Class"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.LRATCheckerSound": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/LRATCheckerSound.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Internal.LRATChecker",
        "Std.Tactic.BVDecide.LRAT.Internal.CNF",
        "Std.Tactic.BVDecide.LRAT.Internal.Actions"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Internal.PosFin": {
      "path": "Std/Tactic/BVDecide/LRAT/Internal/PosFin.olean",
      "imports": [
        "Init.Data.Hashable"
      ]
    },
    "Std.Tactic.BVDecide.LRAT.Parser": {
      "path": "Std/Tactic/BVDecide/LRAT/Parser.olean",
      "imports": [
        "Init.System.IO",
        "Std.Tactic.BVDecide.LRAT.Actions",
        "Std.Internal.Parsec"
      ]
    },
    "Std.Tactic.BVDecide.LRAT": {
      "path": "Std/Tactic/BVDecide/LRAT.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Actions",
        "Std.Tactic.BVDecide.LRAT.Checker",
        "Std.Tactic.BVDecide.LRAT.Parser"
      ]
    },
    "Std.Tactic.BVDecide.Normalize.BitVec": {
      "path": "Std/Tactic/BVDecide/Normalize/BitVec.olean",
      "imports": [
        "Init.Data.BitVec.Bitblast",
        "Init.Data.AC",
        "Std.Tactic.BVDecide.Normalize.Bool",
        "Std.Tactic.BVDecide.Normalize.Canonicalize",
        "Init.Data.SInt.Basic"
      ]
    },
    "Std.Tactic.BVDecide.Normalize.Bool": {
      "path": "Std/Tactic/BVDecide/Normalize/Bool.olean",
      "imports": [
        "Init.Data.BitVec.Lemmas",
        "Init.Data.BitVec.Decidable",
        "Init.Data.BEq"
      ]
    },
    "Std.Tactic.BVDecide.Normalize.Canonicalize": {
      "path": "Std/Tactic/BVDecide/Normalize/Canonicalize.olean",
      "imports": [
        "Init.Data.BitVec.Lemmas",
        "Std.Tactic.BVDecide.Syntax"
      ]
    },
    "Std.Tactic.BVDecide.Normalize.Equal": {
      "path": "Std/Tactic/BVDecide/Normalize/Equal.olean",
      "imports": [
        "Init.Data.BitVec.Lemmas"
      ]
    },
    "Std.Tactic.BVDecide.Normalize.Prop": {
      "path": "Std/Tactic/BVDecide/Normalize/Prop.olean",
      "imports": [
        "Init.SimpLemmas"
      ]
    },
    "Std.Tactic.BVDecide.Normalize": {
      "path": "Std/Tactic/BVDecide/Normalize.olean",
      "imports": [
        "Std.Tactic.BVDecide.Normalize.BitVec",
        "Std.Tactic.BVDecide.Normalize.Bool",
        "Std.Tactic.BVDecide.Normalize.Canonicalize",
        "Std.Tactic.BVDecide.Normalize.Equal",
        "Std.Tactic.BVDecide.Normalize.Prop"
      ]
    },
    "Std.Tactic.BVDecide.Reflect": {
      "path": "Std/Tactic/BVDecide/Reflect.olean",
      "imports": [
        "Std.Tactic.BVDecide.LRAT.Checker",
        "Std.Tactic.BVDecide.LRAT.Parser",
        "Std.Tactic.BVDecide.Bitblast",
        "Std.Sat.AIG.CNF",
        "Std.Sat.AIG.RelabelNat"
      ]
    },
    "Std.Tactic.BVDecide.Syntax": {
      "path": "Std/Tactic/BVDecide/Syntax.olean",
      "imports": [
        "Init.Simproc"
      ]
    },
    "Std.Tactic.BVDecide": {
      "path": "Std/Tactic/BVDecide.olean",
      "imports": [
        "Std.Tactic.BVDecide.Bitblast",
        "Std.Tactic.BVDecide.LRAT",
        "Std.Tactic.BVDecide.Normalize",
        "Std.Tactic.BVDecide.Reflect",
        "Std.Tactic.BVDecide.Syntax"
      ]
    },
    "Std.Tactic.Do.ProofMode": {
      "path": "Std/Tactic/Do/ProofMode.olean",
      "imports": [
        "Std.Do.SPred.SPred"
      ]
    },
    "Std.Tactic.Do.Syntax": {
      "path": "Std/Tactic/Do/Syntax.olean",
      "imports": [
        "Std.Do",
        "Std.Tactic.Do.ProofMode"
      ]
    },
    "Std.Tactic.Do": {
      "path": "Std/Tactic/Do.olean",
      "imports": [
        "Std.Tactic.Do.ProofMode",
        "Std.Tactic.Do.Syntax"
      ]
    },
    "Std.Tactic": {
      "path": "Std/Tactic.olean",
      "imports": [
        "Std.Tactic.BVDecide",
        "Std.Tactic.Do"
      ]
    },
    "Std.Time.Date.Basic": {
      "path": "Std/Time/Date/Basic.olean",
      "imports": [
        "Std.Time.Date.Unit.Basic",
        "Std.Time.Date.ValidDate"
      ]
    },
    "Std.Time.Date.PlainDate": {
      "path": "Std/Time/Date/PlainDate.olean",
      "imports": [
        "Std.Time.Date.Basic",
        "all",
        "all"
      ]
    },
    "Std.Time.Date.Unit.Basic": {
      "path": "Std/Time/Date/Unit/Basic.olean",
      "imports": [
        "Std.Time.Date.Unit.Year",
        "Std.Time.Date.Unit.Weekday",
        "Std.Time.Date.Unit.Week"
      ]
    },
    "Std.Time.Date.Unit.Day": {
      "path": "Std/Time/Date/Unit/Day.olean",
      "imports": [
        "Std.Time.Time"
      ]
    },
    "Std.Time.Date.Unit.Month": {
      "path": "Std/Time/Date/Unit/Month.olean",
      "imports": [
        "Std.Time.Date.Unit.Day"
      ]
    },
    "Std.Time.Date.Unit.Week": {
      "path": "Std/Time/Date/Unit/Week.olean",
      "imports": [
        "Std.Time.Date.Unit.Day"
      ]
    },
    "Std.Time.Date.Unit.Weekday": {
      "path": "Std/Time/Date/Unit/Weekday.olean",
      "imports": [
        "Std.Time.Date.Unit.Day"
      ]
    },
    "Std.Time.Date.Unit.Year": {
      "path": "Std/Time/Date/Unit/Year.olean",
      "imports": [
        "Std.Time.Date.Unit.Month"
      ]
    },
    "Std.Time.Date.ValidDate": {
      "path": "Std/Time/Date/ValidDate.olean",
      "imports": [
        "Std.Time.Date.Unit.Month",
        "all"
      ]
    },
    "Std.Time.Date": {
      "path": "Std/Time/Date.olean",
      "imports": [
        "Std.Time.Date.Basic",
        "Std.Time.Date.PlainDate"
      ]
    },
    "Std.Time.DateTime.PlainDateTime": {
      "path": "Std/Time/DateTime/PlainDateTime.olean",
      "imports": [
        "Std.Time.DateTime.Timestamp"
      ]
    },
    "Std.Time.DateTime.Timestamp": {
      "path": "Std/Time/DateTime/Timestamp.olean",
      "imports": [
        "Init.System.IO",
        "Std.Time.Duration"
      ]
    },
    "Std.Time.DateTime": {
      "path": "Std/Time/DateTime.olean",
      "imports": [
        "Std.Time.DateTime.Timestamp",
        "Std.Time.DateTime.PlainDateTime",
        "all"
      ]
    },
    "Std.Time.Duration": {
      "path": "Std/Time/Duration.olean",
      "imports": [
        "Std.Time.Date"
      ]
    },
    "Std.Time.Format.Basic": {
      "path": "Std/Time/Format/Basic.olean",
      "imports": [
        "Std.Time.Zoned",
        "Init.Data.String.TakeDrop",
        "Init.Data.String.Search"
      ]
    },
    "Std.Time.Format": {
      "path": "Std/Time/Format.olean",
      "imports": [
        "Std.Time.Notation.Spec",
        "Std.Time.Format.Basic",
        "all"
      ]
    },
    "Std.Time.Internal.Bounded": {
      "path": "Std/Time/Internal/Bounded.olean",
      "imports": [
        "Init.Data.Int.DivMod.Lemmas",
        "Init.Data.Order.Ord",
        "Init.Data.Subtype.Basic"
      ]
    },
    "Std.Time.Internal.UnitVal": {
      "path": "Std/Time/Internal/UnitVal.olean",
      "imports": [
        "Init.Data.Order.Ord",
        "Init.Data.Rat.Basic"
      ]
    },
    "Std.Time.Internal": {
      "path": "Std/Time/Internal.olean",
      "imports": [
        "Std.Time.Internal.Bounded",
        "Std.Time.Internal.UnitVal"
      ]
    },
    "Std.Time.Notation.Spec": {
      "path": "Std/Time/Notation/Spec.olean",
      "imports": [
        "Std.Time.Format.Basic",
        "Std.Time.Format.Basic"
      ]
    },
    "Std.Time.Notation": {
      "path": "Std/Time/Notation.olean",
      "imports": [
        "Std.Time.Format",
        "Std.Time.Format"
      ]
    },
    "Std.Time.Time.Basic": {
      "path": "Std/Time/Time/Basic.olean",
      "imports": [
        "Std.Time.Time.Unit.Basic"
      ]
    },
    "Std.Time.Time.HourMarker": {
      "path": "Std/Time/Time/HourMarker.olean",
      "imports": [
        "Std.Time.Time.Basic"
      ]
    },
    "Std.Time.Time.PlainTime": {
      "path": "Std/Time/Time/PlainTime.olean",
      "imports": [
        "Std.Time.Time.Basic"
      ]
    },
    "Std.Time.Time.Unit.Basic": {
      "path": "Std/Time/Time/Unit/Basic.olean",
      "imports": [
        "Std.Time.Time.Unit.Hour",
        "Std.Time.Time.Unit.Millisecond"
      ]
    },
    "Std.Time.Time.Unit.Hour": {
      "path": "Std/Time/Time/Unit/Hour.olean",
      "imports": [
        "Std.Time.Time.Unit.Minute"
      ]
    },
    "Std.Time.Time.Unit.Millisecond": {
      "path": "Std/Time/Time/Unit/Millisecond.olean",
      "imports": [
        "Std.Time.Time.Unit.Nanosecond"
      ]
    },
    "Std.Time.Time.Unit.Minute": {
      "path": "Std/Time/Time/Unit/Minute.olean",
      "imports": [
        "Std.Time.Time.Unit.Second"
      ]
    },
    "Std.Time.Time.Unit.Nanosecond": {
      "path": "Std/Time/Time/Unit/Nanosecond.olean",
      "imports": [
        "Std.Time.Internal"
      ]
    },
    "Std.Time.Time.Unit.Second": {
      "path": "Std/Time/Time/Unit/Second.olean",
      "imports": [
        "Std.Time.Time.Unit.Nanosecond"
      ]
    },
    "Std.Time.Time": {
      "path": "Std/Time/Time.olean",
      "imports": [
        "Std.Time.Time.Basic",
        "Std.Time.Time.HourMarker",
        "Std.Time.Time.PlainTime"
      ]
    },
    "Std.Time.Zoned.Database.Basic": {
      "path": "Std/Time/Zoned/Database/Basic.olean",
      "imports": [
        "Std.Time.Zoned.ZoneRules",
        "Std.Time.Zoned.Database.TzIf"
      ]
    },
    "Std.Time.Zoned.Database.TZdb": {
      "path": "Std/Time/Zoned/Database/TZdb.olean",
      "imports": [
        "Std.Time.Zoned.Database.Basic",
        "Init.Data.String.TakeDrop"
      ]
    },
    "Std.Time.Zoned.Database.TzIf": {
      "path": "Std/Time/Zoned/Database/TzIf.olean",
      "imports": [
        "Init.Data.Range.Polymorphic.Iterators",
        "Std.Internal.Parsec",
        "Init.Data.ByteArray.Extra"
      ]
    },
    "Std.Time.Zoned.Database.Windows": {
      "path": "Std/Time/Zoned/Database/Windows.olean",
      "imports": [
        "Init.Data.SInt.Basic",
        "Std.Time.Zoned.Database.Basic"
      ]
    },
    "Std.Time.Zoned.Database": {
      "path": "Std/Time/Zoned/Database.olean",
      "imports": [
        "Std.Time.Zoned.ZonedDateTime",
        "Std.Time.Zoned.Database.Basic",
        "Std.Time.Zoned.Database.TZdb",
        "Std.Time.Zoned.Database.Windows"
      ]
    },
    "Std.Time.Zoned.DateTime": {
      "path": "Std/Time/Zoned/DateTime.olean",
      "imports": [
        "Std.Time.DateTime",
        "Std.Time.Zoned.TimeZone",
        "all",
        "all",
        "all"
      ]
    },
    "Std.Time.Zoned.Offset": {
      "path": "Std/Time/Zoned/Offset.olean",
      "imports": [
        "Std.Time.Time"
      ]
    },
    "Std.Time.Zoned.TimeZone": {
      "path": "Std/Time/Zoned/TimeZone.olean",
      "imports": [
        "Std.Time.Zoned.Offset"
      ]
    },
    "Std.Time.Zoned.ZoneRules": {
      "path": "Std/Time/Zoned/ZoneRules.olean",
      "imports": [
        "Std.Time.DateTime",
        "Std.Time.Zoned.TimeZone"
      ]
    },
    "Std.Time.Zoned.ZonedDateTime": {
      "path": "Std/Time/Zoned/ZonedDateTime.olean",
      "imports": [
        "Std.Time.Zoned.DateTime",
        "Std.Time.Zoned.ZoneRules",
        "all"
      ]
    },
    "Std.Time.Zoned": {
      "path": "Std/Time/Zoned.olean",
      "imports": [
        "Std.Time.Zoned.DateTime",
        "Std.Time.Zoned.ZoneRules",
        "Std.Time.Zoned.ZonedDateTime",
        "Std.Time.Zoned.Database"
      ]
    },
    "Std.Time": {
      "path": "Std/Time.olean",
      "imports": [
        "Std.Time.Time",
        "Std.Time.Date",
        "Std.Time.Zoned",
        "Std.Time.Format",
        "Std.Time.DateTime",
        "Std.Time.Notation",
        "Std.Time.Duration",
        "Std.Time.Zoned.Database"
      ]
    },
    "Std": {
      "path": "Std.olean",
      "imports": [
        "Std.Data",
        "Std.Do",
        "Std.Sat",
        "Std.Sync",
        "Std.Time",
        "Std.Tactic",
        "Std.Internal",
        "Std.Net"
      ]
    }
  }
}